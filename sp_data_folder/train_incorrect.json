[
    {
        "db_id": "farm",
        "query": "What is the average number of working horses of farms with more than 5000 total number of horses?",
        "sql_query": "SELECT avg(Working_Horses) FROM farm WHERE Total_Horses  >  5000",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "Working_Horses"
                }
            },
            "from": "farm",
            "where": {
                "gt": [
                    "Total_Horses",
                    5000
                ]
            }
        },
        "sql_ans": [
            [
                3977.7500000000005
            ]
        ],
        "cypher_query": "MATCH (farm:`farm.farm`)\nWHERE farm.Total_Horses > 5000\nRETURN avg(farm.Working_Horses)",
        "cypher_ans": [
            [
                3977.75
            ]
        ]
    },
    {
        "db_id": "farm",
        "query": "Give the average number of working horses on farms with more than 5000 total horses.",
        "sql_query": "SELECT avg(Working_Horses) FROM farm WHERE Total_Horses  >  5000",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "Working_Horses"
                }
            },
            "from": "farm",
            "where": {
                "gt": [
                    "Total_Horses",
                    5000
                ]
            }
        },
        "sql_ans": [
            [
                3977.7500000000005
            ]
        ],
        "cypher_query": "MATCH (farm:`farm.farm`)\nWHERE farm.Total_Horses > 5000\nRETURN avg(farm.Working_Horses)",
        "cypher_ans": [
            [
                3977.75
            ]
        ]
    },
    {
        "db_id": "farm",
        "query": "Please show the different statuses of cities and the average population of cities with each status.",
        "sql_query": "SELECT Status ,  avg(Population) FROM city GROUP BY Status",
        "parsed_sql": {
            "select": [
                {
                    "value": "Status"
                },
                {
                    "value": {
                        "avg": "Population"
                    }
                }
            ],
            "from": "city",
            "groupby": {
                "value": "Status"
            }
        },
        "sql_ans": [
            [
                "Town",
                5706.0
            ],
            [
                "Village",
                1009.75
            ]
        ],
        "cypher_query": "MATCH (city:`farm.city`)\nWITH city.Status AS Status, count(city.Status) AS count\nRETURN Status,count",
        "cypher_ans": [
            [
                "Town",
                1
            ],
            [
                "Village",
                4
            ]
        ]
    },
    {
        "db_id": "farm",
        "query": "What are the statuses and average populations of each city?",
        "sql_query": "SELECT Status ,  avg(Population) FROM city GROUP BY Status",
        "parsed_sql": {
            "select": [
                {
                    "value": "Status"
                },
                {
                    "value": {
                        "avg": "Population"
                    }
                }
            ],
            "from": "city",
            "groupby": {
                "value": "Status"
            }
        },
        "sql_ans": [
            [
                "Town",
                5706.0
            ],
            [
                "Village",
                1009.75
            ]
        ],
        "cypher_query": "MATCH (city:`farm.city`)\nWITH city.Status AS Status, count(city.Status) AS count\nRETURN Status,count",
        "cypher_ans": [
            [
                "Town",
                1
            ],
            [
                "Village",
                4
            ]
        ]
    },
    {
        "db_id": "student_assessment",
        "query": "List the id of students who never attends courses?",
        "sql_query": "SELECT student_id FROM students WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)",
        "parsed_sql": {
            "select": {
                "value": "student_id"
            },
            "from": "students",
            "where": {
                "nin": [
                    "student_id",
                    {
                        "select": {
                            "value": "student_id"
                        },
                        "from": "student_course_attendance"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                131
            ],
            [
                181
            ]
        ],
        "cypher_query": "MATCH (students:`student_assessment.Students`)\nWHERE NOT (students:`student_assessment.Students`)-[:`student_assessment.Student_Course_Attendance`]-()\nRETURN students.student_id",
        "cypher_ans": [
            [
                111
            ],
            [
                121
            ],
            [
                131
            ],
            [
                141
            ],
            [
                151
            ],
            [
                161
            ],
            [
                171
            ],
            [
                181
            ]
        ]
    },
    {
        "db_id": "student_assessment",
        "query": "What are the  ids of every student who has never attended a course?",
        "sql_query": "SELECT student_id FROM students WHERE student_id NOT IN (SELECT student_id FROM student_course_attendance)",
        "parsed_sql": {
            "select": {
                "value": "student_id"
            },
            "from": "students",
            "where": {
                "nin": [
                    "student_id",
                    {
                        "select": {
                            "value": "student_id"
                        },
                        "from": "student_course_attendance"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                131
            ],
            [
                181
            ]
        ],
        "cypher_query": "MATCH (students:`student_assessment.Students`)\nWHERE NOT (students:`student_assessment.Students`)-[:`student_assessment.Student_Course_Attendance`]-()\nRETURN students.student_id",
        "cypher_ans": [
            [
                111
            ],
            [
                121
            ],
            [
                131
            ],
            [
                141
            ],
            [
                151
            ],
            [
                161
            ],
            [
                171
            ],
            [
                181
            ]
        ]
    },
    {
        "db_id": "student_assessment",
        "query": "How many students attend course English?",
        "sql_query": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"English\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "courses",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "student_course_attendance",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.course_id",
                            "T2.course_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.course_name",
                    "English"
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (T1:`student_assessment.Courses`)-[T2:`student_assessment.Student_Course_Attendance`]-()\nWHERE T1.course_name = 'English'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "student_assessment",
        "query": "How many students are attending English courses?",
        "sql_query": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T1.course_name = \"English\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "courses",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "student_course_attendance",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.course_id",
                            "T2.course_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.course_name",
                    "English"
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (T1:`student_assessment.Courses`)-[T2:`student_assessment.Student_Course_Attendance`]-()\nWHERE T1.course_name = 'English'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "student_assessment",
        "query": "How many courses do the student whose id is 171 attend?",
        "sql_query": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "courses",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "student_course_attendance",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.course_id",
                            "T2.course_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.student_id",
                    171
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`student_assessment.Courses`)-[T2:`student_assessment.Student_Course_Attendance`]-()\nWHERE T2.student_id = 171\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "student_assessment",
        "query": "How many courses does the student with id 171 actually attend?",
        "sql_query": "SELECT count(*) FROM courses AS T1 JOIN student_course_attendance AS T2 ON T1.course_id = T2.course_id WHERE T2.student_id = 171",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "courses",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "student_course_attendance",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.course_id",
                            "T2.course_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.student_id",
                    171
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`student_assessment.Courses`)-[T2:`student_assessment.Student_Course_Attendance`]-()\nWHERE T2.student_id = 171\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "What is the average latitude and longitude of stations located in San Jose city?",
        "sql_query": "SELECT avg(lat) ,  avg(long) FROM station WHERE city  =  \"San Jose\"",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "lat"
                    }
                },
                {
                    "value": {
                        "avg": "long"
                    }
                }
            ],
            "from": "station",
            "where": {
                "eq": [
                    "city",
                    "San Jose"
                ]
            }
        },
        "sql_ans": [
            [
                37.3364135625,
                -121.89160575
            ]
        ],
        "cypher_query": "MATCH (station:`bike_1.station`)\nWHERE station.city = 'San Jose'\nRETURN avg(station.lat),avg(station.long)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "What is the average latitude and longitude in San Jose?",
        "sql_query": "SELECT avg(lat) ,  avg(long) FROM station WHERE city  =  \"San Jose\"",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "lat"
                    }
                },
                {
                    "value": {
                        "avg": "long"
                    }
                }
            ],
            "from": "station",
            "where": {
                "eq": [
                    "city",
                    "San Jose"
                ]
            }
        },
        "sql_ans": [
            [
                37.3364135625,
                -121.89160575
            ]
        ],
        "cypher_query": "MATCH (station:`bike_1.station`)\nWHERE station.city = 'San Jose'\nRETURN avg(station.lat),avg(station.long)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "From the trip record, find the number of unique bikes.",
        "sql_query": "SELECT count(DISTINCT bike_id) FROM trip",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "bike_id"
                        }
                    }
                }
            },
            "from": "trip"
        },
        "sql_ans": [
            [
                530
            ]
        ],
        "cypher_query": "MATCH (trip:`bike_1.trip`)\nRETURN count(DISTINCT trip.bike_id)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "How many different bike ids are there?",
        "sql_query": "SELECT count(DISTINCT bike_id) FROM trip",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "bike_id"
                        }
                    }
                }
            },
            "from": "trip"
        },
        "sql_ans": [
            [
                530
            ]
        ],
        "cypher_query": "MATCH (trip:`bike_1.trip`)\nRETURN count(DISTINCT trip.bike_id)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "What is the number of distinct cities the stations are located at?",
        "sql_query": "SELECT count(DISTINCT city) FROM station",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "city"
                        }
                    }
                }
            },
            "from": "station"
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (station:`bike_1.station`)\nRETURN count(DISTINCT station.city)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "How many different cities have these stations?",
        "sql_query": "SELECT count(DISTINCT city) FROM station",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "city"
                        }
                    }
                }
            },
            "from": "station"
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (station:`bike_1.station`)\nRETURN count(DISTINCT station.city)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "How many stations does Mountain View city has?",
        "sql_query": "SELECT COUNT(*) FROM station WHERE city  =  \"Mountain View\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "station",
            "where": {
                "eq": [
                    "city",
                    "Mountain View"
                ]
            }
        },
        "sql_ans": [
            [
                7
            ]
        ],
        "cypher_query": "MATCH (station:`bike_1.station`)\nWHERE station.city = 'Mountain View'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "How many stations are in Mountain View?",
        "sql_query": "SELECT COUNT(*) FROM station WHERE city  =  \"Mountain View\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "station",
            "where": {
                "eq": [
                    "city",
                    "Mountain View"
                ]
            }
        },
        "sql_ans": [
            [
                7
            ]
        ],
        "cypher_query": "MATCH (station:`bike_1.station`)\nWHERE station.city = 'Mountain View'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "How many days had both mean humidity above 50 and mean visibility above 8?",
        "sql_query": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  50 AND mean_visibility_miles  >  8",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "weather",
            "where": {
                "and": [
                    {
                        "gt": [
                            "mean_humidity",
                            50
                        ]
                    },
                    {
                        "gt": [
                            "mean_visibility_miles",
                            8
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3013
            ]
        ],
        "cypher_query": "MATCH (weather:`bike_1.weather`)\nWHERE weather.mean_humidity > 50 AND weather.mean_visibility_miles > 8\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "What is the number of days that had an average humity above 50 and an average visibility above 8?",
        "sql_query": "SELECT COUNT(*) FROM weather WHERE mean_humidity  >  50 AND mean_visibility_miles  >  8",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "weather",
            "where": {
                "and": [
                    {
                        "gt": [
                            "mean_humidity",
                            50
                        ]
                    },
                    {
                        "gt": [
                            "mean_visibility_miles",
                            8
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3013
            ]
        ],
        "cypher_query": "MATCH (weather:`bike_1.weather`)\nWHERE weather.mean_humidity > 50 AND weather.mean_visibility_miles > 8\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "What is the average bike availability in stations that are not located in Palo Alto?",
        "sql_query": "SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "bikes_available"
                }
            },
            "from": "status",
            "where": {
                "nin": [
                    "station_id",
                    {
                        "select": {
                            "value": "id"
                        },
                        "from": "station",
                        "where": {
                            "eq": [
                                "city",
                                "Palo Alto"
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                7.657901422764228
            ]
        ],
        "cypher_query": "MATCH (status:`bike_1.status`)\nWHERE NOT (status:`bike_1.status`)-[]-(:`bike_1.station { city : 'Palo Alto' }`)\nRETURN avg(status.bikes_available)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "What is the average bike availablility for stations not in Palo Alto?",
        "sql_query": "SELECT avg(bikes_available) FROM status WHERE station_id NOT IN (SELECT id FROM station WHERE city  =  \"Palo Alto\")",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "bikes_available"
                }
            },
            "from": "status",
            "where": {
                "nin": [
                    "station_id",
                    {
                        "select": {
                            "value": "id"
                        },
                        "from": "station",
                        "where": {
                            "eq": [
                                "city",
                                "Palo Alto"
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                7.657901422764228
            ]
        ],
        "cypher_query": "MATCH (status:`bike_1.status`)\nWHERE NOT (status:`bike_1.status`)-[]-(:`bike_1.station { city : 'Palo Alto' }`)\nRETURN avg(status.bikes_available)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "Count the number of trips that did not end in San Francisco city.",
        "sql_query": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city !=  \"San Francisco\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "trip",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "station",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.end_station_id",
                            "T2.id"
                        ]
                    }
                }
            ],
            "where": {
                "neq": [
                    "T2.city",
                    "San Francisco"
                ]
            }
        },
        "sql_ans": [
            [
                999
            ]
        ],
        "cypher_query": "MATCH (T1:`bike_1.trip`)-[]-(T2:`bike_1.station`)\nWHERE T2.city <> 'San Francisco'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "How many trips did not end in San Francisco?",
        "sql_query": "SELECT count(*) FROM trip AS T1 JOIN station AS T2 ON T1.end_station_id  =  T2.id WHERE T2.city != \"San Francisco\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "trip",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "station",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.end_station_id",
                            "T2.id"
                        ]
                    }
                }
            ],
            "where": {
                "neq": [
                    "T2.city",
                    "San Francisco"
                ]
            }
        },
        "sql_ans": [
            [
                999
            ]
        ],
        "cypher_query": "MATCH (T1:`bike_1.trip`)-[]-(T2:`bike_1.station`)\nWHERE T2.city <> 'San Francisco'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "What is the average latitude and longitude of the starting points of all trips?",
        "sql_query": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "T1.lat"
                    }
                },
                {
                    "value": {
                        "avg": "T1.long"
                    }
                }
            ],
            "from": [
                {
                    "value": "station",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "trip",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.id",
                            "T2.start_station_id"
                        ]
                    }
                }
            ]
        },
        "sql_ans": [
            [
                37.74618133538529,
                -122.36134722346611
            ]
        ],
        "cypher_query": "MATCH (T1:`bike_1.station`)-[]-(T2:`bike_1.trip`)\nRETURN avg(T1.lat),avg(T1.long)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "bike_1",
        "query": "What is the average latitude and longitude of all starting stations for the trips?",
        "sql_query": "SELECT avg(T1.lat) ,  avg(T1.long) FROM station AS T1 JOIN trip AS T2 ON T1.id  =  T2.start_station_id",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "T1.lat"
                    }
                },
                {
                    "value": {
                        "avg": "T1.long"
                    }
                }
            ],
            "from": [
                {
                    "value": "station",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "trip",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.id",
                            "T2.start_station_id"
                        ]
                    }
                }
            ]
        },
        "sql_ans": [
            [
                37.74618133538529,
                -122.36134722346611
            ]
        ],
        "cypher_query": "MATCH (T1:`bike_1.station`)-[]-(T2:`bike_1.trip`)\nRETURN avg(T1.lat),avg(T1.long)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "book_2",
        "query": "List the publication dates of publications with 3 lowest prices.",
        "sql_query": "SELECT Publication_Date FROM publication ORDER BY Price ASC LIMIT 3",
        "parsed_sql": {
            "select": {
                "value": "Publication_Date"
            },
            "from": "publication",
            "orderby": {
                "value": "Price",
                "sort": "asc"
            },
            "limit": 3
        },
        "sql_ans": [
            [
                "March 2007"
            ],
            [
                "April 2007"
            ],
            [
                "October 2005"
            ]
        ],
        "cypher_query": "MATCH (publication:`book_2.publication`)\nRETURN publication.Publication_Date\nORDER BY publication.Price ASC\nLIMIT 3",
        "cypher_ans": [
            [
                "March 2007"
            ],
            [
                "April 2007"
            ],
            [
                "August 2008"
            ]
        ]
    },
    {
        "db_id": "twitter_1",
        "query": "How many followers does each user have?",
        "sql_query": "SELECT count(*) FROM follows",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "follows"
        },
        "sql_ans": [
            [
                9
            ]
        ],
        "cypher_query": "MATCH ()-[follows:`twitter_1.follows`]-()\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "product_catalog",
        "query": "Which catalog publisher has published the most catalogs?",
        "sql_query": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "catalog_publisher"
            },
            "from": "catalogs",
            "groupby": {
                "value": "catalog_publisher"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Russel-Gislason Lemon shop"
            ]
        ],
        "cypher_query": "MATCH (catalogs:`product_catalog.Catalogs`)\nWITH count(catalogs.catalog_publisher) AS count, catalogs.catalog_publisher AS catalog_publisher\nRETURN catalog_publisher\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Murray Coffee shop"
            ]
        ]
    },
    {
        "db_id": "product_catalog",
        "query": "Find the catalog publisher that has the most catalogs.",
        "sql_query": "SELECT catalog_publisher FROM catalogs GROUP BY catalog_publisher ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "catalog_publisher"
            },
            "from": "catalogs",
            "groupby": {
                "value": "catalog_publisher"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Russel-Gislason Lemon shop"
            ]
        ],
        "cypher_query": "MATCH (catalogs:`product_catalog.Catalogs`)\nWITH count(catalogs.catalog_publisher) AS count, catalogs.catalog_publisher AS catalog_publisher\nRETURN catalog_publisher\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Murray Coffee shop"
            ]
        ]
    },
    {
        "db_id": "product_catalog",
        "query": "What are the average and minimum price (in Euro) of all products?",
        "sql_query": "SELECT avg(price_in_euros) ,  min(price_in_euros) FROM catalog_contents",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "price_in_euros"
                    }
                },
                {
                    "value": {
                        "min": "price_in_euros"
                    }
                }
            ],
            "from": "catalog_contents"
        },
        "sql_ans": [
            [
                492.8633333333334,
                159.84
            ]
        ],
        "cypher_query": "MATCH (catalog_contents:`product_catalog.Catalog_Contents`)\nRETURN avg(catalog_contents.price_in_euros),min(catalog_contents.price_in_euros)",
        "cypher_ans": [
            [
                492.8633333333333,
                159.84
            ]
        ]
    },
    {
        "db_id": "product_catalog",
        "query": "Give me the average and minimum price (in Euro) of the products.",
        "sql_query": "SELECT avg(price_in_euros) ,  min(price_in_euros) FROM catalog_contents",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "price_in_euros"
                    }
                },
                {
                    "value": {
                        "min": "price_in_euros"
                    }
                }
            ],
            "from": "catalog_contents"
        },
        "sql_ans": [
            [
                492.8633333333334,
                159.84
            ]
        ],
        "cypher_query": "MATCH (catalog_contents:`product_catalog.Catalog_Contents`)\nRETURN avg(catalog_contents.price_in_euros),min(catalog_contents.price_in_euros)",
        "cypher_ans": [
            [
                492.8633333333333,
                159.84
            ]
        ]
    },
    {
        "db_id": "flight_1",
        "query": "What is average and maximum salary of all employees.",
        "sql_query": "SELECT avg(salary) ,  max(salary) FROM Employee",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "salary"
                    }
                },
                {
                    "value": {
                        "max": "salary"
                    }
                }
            ],
            "from": "Employee"
        },
        "sql_ans": [
            [
                109915.3870967742,
                289950
            ]
        ],
        "cypher_query": "MATCH (employee:`flight_1.employee`)\nRETURN avg(employee.salary),max(employee.salary)",
        "cypher_ans": [
            [
                109915.38709677421,
                289950
            ]
        ]
    },
    {
        "db_id": "flight_1",
        "query": "What is the average and largest salary of all employees?",
        "sql_query": "SELECT avg(salary) ,  max(salary) FROM Employee",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "salary"
                    }
                },
                {
                    "value": {
                        "max": "salary"
                    }
                }
            ],
            "from": "Employee"
        },
        "sql_ans": [
            [
                109915.3870967742,
                289950
            ]
        ],
        "cypher_query": "MATCH (employee:`flight_1.employee`)\nRETURN avg(employee.salary),max(employee.salary)",
        "cypher_ans": [
            [
                109915.38709677421,
                289950
            ]
        ]
    },
    {
        "db_id": "flight_1",
        "query": "What is the average distance and average price for flights from Los Angeles.",
        "sql_query": "SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  \"Los Angeles\"",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "distance"
                    }
                },
                {
                    "value": {
                        "avg": "price"
                    }
                }
            ],
            "from": "Flight",
            "where": {
                "eq": [
                    "origin",
                    "Los Angeles"
                ]
            }
        },
        "sql_ans": [
            [
                3247.625,
                345.16
            ]
        ],
        "cypher_query": "MATCH (flight:`flight_1.flight`)\nWHERE flight.origin = 'Los Angeles'\nRETURN avg(flight.distance),avg(flight.price)",
        "cypher_ans": [
            [
                3247.625,
                345.15999999999997
            ]
        ]
    },
    {
        "db_id": "flight_1",
        "query": "What is the average distance and price for all flights from LA?",
        "sql_query": "SELECT avg(distance) ,  avg(price) FROM Flight WHERE origin  =  \"Los Angeles\"",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "distance"
                    }
                },
                {
                    "value": {
                        "avg": "price"
                    }
                }
            ],
            "from": "Flight",
            "where": {
                "eq": [
                    "origin",
                    "Los Angeles"
                ]
            }
        },
        "sql_ans": [
            [
                3247.625,
                345.16
            ]
        ],
        "cypher_query": "MATCH (flight:`flight_1.flight`)\nWHERE flight.origin = 'Los Angeles'\nRETURN avg(flight.distance),avg(flight.price)",
        "cypher_ans": [
            [
                3247.625,
                345.15999999999997
            ]
        ]
    },
    {
        "db_id": "flight_1",
        "query": "Which destination has least number of flights?",
        "sql_query": "SELECT destination FROM Flight GROUP BY destination ORDER BY count(*) LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "destination"
            },
            "from": "Flight",
            "groupby": {
                "value": "destination"
            },
            "orderby": {
                "value": {
                    "count": "*"
                }
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Boston"
            ]
        ],
        "cypher_query": "MATCH (flight:`flight_1.flight`)\nWITH count(flight.destination) AS count, flight.destination AS destination\nRETURN destination\nORDER BY count\nLIMIT 1",
        "cypher_ans": [
            [
                "Washington D.C."
            ]
        ]
    },
    {
        "db_id": "flight_1",
        "query": "What destination has the fewest number of flights?",
        "sql_query": "SELECT destination FROM Flight GROUP BY destination ORDER BY count(*) LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "destination"
            },
            "from": "Flight",
            "groupby": {
                "value": "destination"
            },
            "orderby": {
                "value": {
                    "count": "*"
                }
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Boston"
            ]
        ],
        "cypher_query": "MATCH (flight:`flight_1.flight`)\nWITH count(flight.destination) AS count, flight.destination AS destination\nRETURN destination\nORDER BY count\nLIMIT 1",
        "cypher_ans": [
            [
                "Washington D.C."
            ]
        ]
    },
    {
        "db_id": "flight_1",
        "query": "How many employees have certificate.",
        "sql_query": "SELECT count(DISTINCT eid) FROM Certificate",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "eid"
                        }
                    }
                }
            },
            "from": "Certificate"
        },
        "sql_ans": [
            [
                20
            ]
        ],
        "cypher_query": "MATCH ()-[certificate:`flight_1.certificate`]-()\nRETURN count(DISTINCT certificate.eid)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_1",
        "query": "What is the count of distinct employees with certificates?",
        "sql_query": "SELECT count(DISTINCT eid) FROM Certificate",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "eid"
                        }
                    }
                }
            },
            "from": "Certificate"
        },
        "sql_ans": [
            [
                20
            ]
        ],
        "cypher_query": "MATCH ()-[certificate:`flight_1.certificate`]-()\nRETURN count(DISTINCT certificate.eid)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_1",
        "query": "Show the name of aircraft which fewest people have its certificate.",
        "sql_query": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T2.name"
            },
            "from": [
                {
                    "value": "Certificate",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Aircraft",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T2.aid",
                            "T1.aid"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.aid"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Boeing 737-800"
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`flight_1.certificate`]-(T2:`flight_1.aircraft`)\nWITH T2.name AS name, count(T1.aid) AS count\nRETURN name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Boeing 747-400"
            ]
        ]
    },
    {
        "db_id": "flight_1",
        "query": "What are the names of the aircraft that the least people are certified to fly?",
        "sql_query": "SELECT T2.name FROM Certificate AS T1 JOIN Aircraft AS T2 ON T2.aid  =  T1.aid GROUP BY T1.aid ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T2.name"
            },
            "from": [
                {
                    "value": "Certificate",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Aircraft",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T2.aid",
                            "T1.aid"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.aid"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Boeing 737-800"
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`flight_1.certificate`]-(T2:`flight_1.aircraft`)\nWITH T2.name AS name, count(T1.aid) AS count\nRETURN name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Boeing 747-400"
            ]
        ]
    },
    {
        "db_id": "allergy_1",
        "query": "Show the minimum, average, and maximum age of all students.",
        "sql_query": "SELECT min(age) ,  avg(age) ,  max(age) FROM Student",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "min": "age"
                    }
                },
                {
                    "value": {
                        "avg": "age"
                    }
                },
                {
                    "value": {
                        "max": "age"
                    }
                }
            ],
            "from": "Student"
        },
        "sql_ans": [
            [
                16,
                19.558823529411764,
                27
            ]
        ],
        "cypher_query": "MATCH (student:`allergy_1.Student`)\nRETURN min(student.Age),avg(student.Age),max(student.Age)",
        "cypher_ans": [
            [
                16,
                19.558823529411768,
                27
            ]
        ]
    },
    {
        "db_id": "allergy_1",
        "query": "What is the minimum, mean, and maximum age across all students?",
        "sql_query": "SELECT min(age) ,  avg(age) ,  max(age) FROM Student",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "min": "age"
                    }
                },
                {
                    "value": {
                        "avg": "age"
                    }
                },
                {
                    "value": {
                        "max": "age"
                    }
                }
            ],
            "from": "Student"
        },
        "sql_ans": [
            [
                16,
                19.558823529411764,
                27
            ]
        ],
        "cypher_query": "MATCH (student:`allergy_1.Student`)\nRETURN min(student.Age),avg(student.Age),max(student.Age)",
        "cypher_ans": [
            [
                16,
                19.558823529411768,
                27
            ]
        ]
    },
    {
        "db_id": "allergy_1",
        "query": "Show the average age for male and female students.",
        "sql_query": "SELECT avg(age) ,  sex FROM Student GROUP BY sex",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "age"
                    }
                },
                {
                    "value": "sex"
                }
            ],
            "from": "Student",
            "groupby": {
                "value": "sex"
            }
        },
        "sql_ans": [
            [
                19.7,
                "F"
            ],
            [
                19.5,
                "M"
            ]
        ],
        "cypher_query": "MATCH (student:`allergy_1.Student`)\nWITH student.Sex AS Sex, count(student.Sex) AS count\nRETURN count,Sex",
        "cypher_ans": [
            [
                10,
                "F"
            ],
            [
                24,
                "M"
            ]
        ]
    },
    {
        "db_id": "allergy_1",
        "query": "What are the average ages for male and female students?",
        "sql_query": "SELECT avg(age) ,  sex FROM Student GROUP BY sex",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "age"
                    }
                },
                {
                    "value": "sex"
                }
            ],
            "from": "Student",
            "groupby": {
                "value": "sex"
            }
        },
        "sql_ans": [
            [
                19.7,
                "F"
            ],
            [
                19.5,
                "M"
            ]
        ],
        "cypher_query": "MATCH (student:`allergy_1.Student`)\nWITH student.Sex AS Sex, count(student.Sex) AS count\nRETURN count,Sex",
        "cypher_ans": [
            [
                10,
                "F"
            ],
            [
                24,
                "M"
            ]
        ]
    },
    {
        "db_id": "allergy_1",
        "query": "How many students have cat allergies?",
        "sql_query": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  \"Cat\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Has_allergy",
            "where": {
                "eq": [
                    "Allergy",
                    "Cat"
                ]
            }
        },
        "sql_ans": [
            [
                4
            ]
        ],
        "cypher_query": "MATCH (has_allergy:`allergy_1.Has_Allergy`)\nWHERE has_allergy.Allergy = 'Cat'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "allergy_1",
        "query": "How many students are affected by cat allergies?",
        "sql_query": "SELECT count(*) FROM Has_allergy WHERE Allergy  =  \"Cat\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Has_allergy",
            "where": {
                "eq": [
                    "Allergy",
                    "Cat"
                ]
            }
        },
        "sql_ans": [
            [
                4
            ]
        ],
        "cypher_query": "MATCH (has_allergy:`allergy_1.Has_Allergy`)\nWHERE has_allergy.Allergy = 'Cat'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "allergy_1",
        "query": "How many female students have milk or egg allergies?",
        "sql_query": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  \"F\" AND T1.allergy  =  \"Milk\" OR T1.allergy  =  \"Eggs\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "has_allergy",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Student",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.StuID",
                            "T2.StuID"
                        ]
                    }
                }
            ],
            "where": {
                "or": [
                    {
                        "and": [
                            {
                                "eq": [
                                    "T2.sex",
                                    "F"
                                ]
                            },
                            {
                                "eq": [
                                    "T1.allergy",
                                    "Milk"
                                ]
                            }
                        ]
                    },
                    {
                        "eq": [
                            "T1.allergy",
                            "Eggs"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                4
            ]
        ],
        "cypher_query": "MATCH (T1:`allergy_1.Has_Allergy`)-[]-(T2:`allergy_1.Student`)\nWHERE T2.Sex = 'F' AND T1.Allergy = 'Milk' OR T1.Allergy = 'Eggs'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "allergy_1",
        "query": "How many students who are female are allergic to milk or eggs?",
        "sql_query": "SELECT count(*) FROM has_allergy AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID WHERE T2.sex  =  \"F\" AND T1.allergy  =  \"Milk\" OR T1.allergy  =  \"Eggs\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "has_allergy",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Student",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.StuID",
                            "T2.StuID"
                        ]
                    }
                }
            ],
            "where": {
                "or": [
                    {
                        "and": [
                            {
                                "eq": [
                                    "T2.sex",
                                    "F"
                                ]
                            },
                            {
                                "eq": [
                                    "T1.allergy",
                                    "Milk"
                                ]
                            }
                        ]
                    },
                    {
                        "eq": [
                            "T1.allergy",
                            "Eggs"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                4
            ]
        ],
        "cypher_query": "MATCH (T1:`allergy_1.Has_Allergy`)-[]-(T2:`allergy_1.Student`)\nWHERE T2.Sex = 'F' AND T1.Allergy = 'Milk' OR T1.Allergy = 'Eggs'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "allergy_1",
        "query": "How many students have a food allergy?",
        "sql_query": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  \"food\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "Has_allergy",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Allergy_type",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.allergy",
                            "T2.allergy"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.allergytype",
                    "food"
                ]
            }
        },
        "sql_ans": [
            [
                28
            ]
        ],
        "cypher_query": "MATCH (T1:`allergy_1.Has_Allergy`)-[]-(T2:`allergy_1.Allergy_Type`)\nWHERE T2.AllergyType = 'food'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "allergy_1",
        "query": "How many students are affected by food related allergies?",
        "sql_query": "SELECT count(*) FROM Has_allergy AS T1 JOIN Allergy_type AS T2 ON T1.allergy  =  T2.allergy WHERE T2.allergytype  =  \"food\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "Has_allergy",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Allergy_type",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.allergy",
                            "T2.allergy"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.allergytype",
                    "food"
                ]
            }
        },
        "sql_ans": [
            [
                28
            ]
        ],
        "cypher_query": "MATCH (T1:`allergy_1.Has_Allergy`)-[]-(T2:`allergy_1.Allergy_Type`)\nWHERE T2.AllergyType = 'food'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "allergy_1",
        "query": "List the first and last name of the students who do not have any food type allergy.",
        "sql_query": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"food\")",
        "parsed_sql": {
            "select": [
                {
                    "value": "fname"
                },
                {
                    "value": "lname"
                }
            ],
            "from": "Student",
            "where": {
                "nin": [
                    "StuID",
                    {
                        "select": {
                            "value": "T1.StuID"
                        },
                        "from": [
                            {
                                "value": "Has_allergy",
                                "name": "T1",
                                "is_table": true
                            },
                            {
                                "join": {
                                    "name": "T2",
                                    "value": "Allergy_Type",
                                    "is_table": true
                                },
                                "on": {
                                    "eq": [
                                        "T1.Allergy",
                                        "T2.Allergy"
                                    ]
                                }
                            }
                        ],
                        "where": {
                            "eq": [
                                "T2.allergytype",
                                "food"
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Linda",
                "Smith"
            ],
            [
                "Shiela",
                "Jones"
            ],
            [
                "Jandy",
                "Nelson"
            ],
            [
                "Eric",
                "Tai"
            ],
            [
                "David",
                "Adams"
            ],
            [
                "Steven",
                "Davis"
            ],
            [
                "Bruce",
                "Wilson"
            ],
            [
                "Arthur",
                "Pang"
            ],
            [
                "Ian",
                "Thornton"
            ],
            [
                "George",
                "Andreou"
            ],
            [
                "Stacy",
                "Prater"
            ],
            [
                "Mark",
                "Goldman"
            ],
            [
                "Eric",
                "Pang"
            ],
            [
                "Paul",
                "Brody"
            ],
            [
                "Eric",
                "Rugh"
            ],
            [
                "Lisa",
                "Cheng"
            ],
            [
                "Eric",
                "Brown"
            ],
            [
                "William",
                "Simms"
            ],
            [
                "Eric",
                "Epp"
            ],
            [
                "Sarah",
                "Schmidt"
            ]
        ],
        "cypher_query": "MATCH (student:`allergy_1.Student`)\nWHERE NOT (student:`allergy_1.Student`)-[]-(:`allergy_1.Has_Allergy`)-[]-(:`allergy_1.Allergy_Type { AllergyType : 'food' }`)\nRETURN student.Fname,student.LName",
        "cypher_ans": [
            [
                "Linda",
                "Smith"
            ],
            [
                "Tracy",
                "Kim"
            ],
            [
                "Shiela",
                "Jones"
            ],
            [
                "Dinesh",
                "Kumar"
            ],
            [
                "Paul",
                "Gompers"
            ],
            [
                "Andy",
                "Schultz"
            ],
            [
                "Lisa",
                "Apap"
            ],
            [
                "Jandy",
                "Nelson"
            ],
            [
                "Eric",
                "Tai"
            ],
            [
                "Derek",
                "Lee"
            ],
            [
                "David",
                "Adams"
            ],
            [
                "Steven",
                "Davis"
            ],
            [
                "Charles",
                "Norris"
            ],
            [
                "Susan",
                "Lee"
            ],
            [
                "Mark",
                "Schwartz"
            ],
            [
                "Bruce",
                "Wilson"
            ],
            [
                "Michael",
                "Leighton"
            ],
            [
                "Arthur",
                "Pang"
            ],
            [
                "Ian",
                "Thornton"
            ],
            [
                "George",
                "Andreou"
            ],
            [
                "Michael",
                "Woods"
            ],
            [
                "David",
                "Shieber"
            ],
            [
                "Stacy",
                "Prater"
            ],
            [
                "Mark",
                "Goldman"
            ],
            [
                "Eric",
                "Pang"
            ],
            [
                "Paul",
                "Brody"
            ],
            [
                "Eric",
                "Rugh"
            ],
            [
                "Jun",
                "Han"
            ],
            [
                "Lisa",
                "Cheng"
            ],
            [
                "Sarah",
                "Smith"
            ],
            [
                "Eric",
                "Brown"
            ],
            [
                "William",
                "Simms"
            ],
            [
                "Eric",
                "Epp"
            ],
            [
                "Sarah",
                "Schmidt"
            ]
        ]
    },
    {
        "db_id": "allergy_1",
        "query": "What is the full name of each student who is not allergic to any type of food.",
        "sql_query": "SELECT fname ,  lname FROM Student WHERE StuID NOT IN (SELECT T1.StuID FROM Has_allergy AS T1 JOIN Allergy_Type AS T2 ON T1.Allergy  =  T2.Allergy WHERE T2.allergytype  =  \"food\")",
        "parsed_sql": {
            "select": [
                {
                    "value": "fname"
                },
                {
                    "value": "lname"
                }
            ],
            "from": "Student",
            "where": {
                "nin": [
                    "StuID",
                    {
                        "select": {
                            "value": "T1.StuID"
                        },
                        "from": [
                            {
                                "value": "Has_allergy",
                                "name": "T1",
                                "is_table": true
                            },
                            {
                                "join": {
                                    "name": "T2",
                                    "value": "Allergy_Type",
                                    "is_table": true
                                },
                                "on": {
                                    "eq": [
                                        "T1.Allergy",
                                        "T2.Allergy"
                                    ]
                                }
                            }
                        ],
                        "where": {
                            "eq": [
                                "T2.allergytype",
                                "food"
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Linda",
                "Smith"
            ],
            [
                "Shiela",
                "Jones"
            ],
            [
                "Jandy",
                "Nelson"
            ],
            [
                "Eric",
                "Tai"
            ],
            [
                "David",
                "Adams"
            ],
            [
                "Steven",
                "Davis"
            ],
            [
                "Bruce",
                "Wilson"
            ],
            [
                "Arthur",
                "Pang"
            ],
            [
                "Ian",
                "Thornton"
            ],
            [
                "George",
                "Andreou"
            ],
            [
                "Stacy",
                "Prater"
            ],
            [
                "Mark",
                "Goldman"
            ],
            [
                "Eric",
                "Pang"
            ],
            [
                "Paul",
                "Brody"
            ],
            [
                "Eric",
                "Rugh"
            ],
            [
                "Lisa",
                "Cheng"
            ],
            [
                "Eric",
                "Brown"
            ],
            [
                "William",
                "Simms"
            ],
            [
                "Eric",
                "Epp"
            ],
            [
                "Sarah",
                "Schmidt"
            ]
        ],
        "cypher_query": "MATCH (student:`allergy_1.Student`)\nWHERE NOT (student:`allergy_1.Student`)-[]-(:`allergy_1.Has_Allergy`)-[]-(:`allergy_1.Allergy_Type { AllergyType : 'food' }`)\nRETURN student.Fname,student.LName",
        "cypher_ans": [
            [
                "Linda",
                "Smith"
            ],
            [
                "Tracy",
                "Kim"
            ],
            [
                "Shiela",
                "Jones"
            ],
            [
                "Dinesh",
                "Kumar"
            ],
            [
                "Paul",
                "Gompers"
            ],
            [
                "Andy",
                "Schultz"
            ],
            [
                "Lisa",
                "Apap"
            ],
            [
                "Jandy",
                "Nelson"
            ],
            [
                "Eric",
                "Tai"
            ],
            [
                "Derek",
                "Lee"
            ],
            [
                "David",
                "Adams"
            ],
            [
                "Steven",
                "Davis"
            ],
            [
                "Charles",
                "Norris"
            ],
            [
                "Susan",
                "Lee"
            ],
            [
                "Mark",
                "Schwartz"
            ],
            [
                "Bruce",
                "Wilson"
            ],
            [
                "Michael",
                "Leighton"
            ],
            [
                "Arthur",
                "Pang"
            ],
            [
                "Ian",
                "Thornton"
            ],
            [
                "George",
                "Andreou"
            ],
            [
                "Michael",
                "Woods"
            ],
            [
                "David",
                "Shieber"
            ],
            [
                "Stacy",
                "Prater"
            ],
            [
                "Mark",
                "Goldman"
            ],
            [
                "Eric",
                "Pang"
            ],
            [
                "Paul",
                "Brody"
            ],
            [
                "Eric",
                "Rugh"
            ],
            [
                "Jun",
                "Han"
            ],
            [
                "Lisa",
                "Cheng"
            ],
            [
                "Sarah",
                "Smith"
            ],
            [
                "Eric",
                "Brown"
            ],
            [
                "William",
                "Simms"
            ],
            [
                "Eric",
                "Epp"
            ],
            [
                "Sarah",
                "Schmidt"
            ]
        ]
    },
    {
        "db_id": "allergy_1",
        "query": "Find the first name and major of the students who are not allegry to soy.",
        "sql_query": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  \"Soy\")",
        "parsed_sql": {
            "select": [
                {
                    "value": "fname"
                },
                {
                    "value": "major"
                }
            ],
            "from": "Student",
            "where": {
                "nin": [
                    "StuID",
                    {
                        "select": {
                            "value": "StuID"
                        },
                        "from": "Has_allergy",
                        "where": {
                            "eq": [
                                "Allergy",
                                "Soy"
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Linda",
                600
            ],
            [
                "Tracy",
                600
            ],
            [
                "Shiela",
                600
            ],
            [
                "Dinesh",
                600
            ],
            [
                "Paul",
                600
            ],
            [
                "Andy",
                600
            ],
            [
                "Lisa",
                600
            ],
            [
                "Jandy",
                600
            ],
            [
                "Eric",
                600
            ],
            [
                "Derek",
                600
            ],
            [
                "David",
                600
            ],
            [
                "Steven",
                600
            ],
            [
                "Charles",
                600
            ],
            [
                "Mark",
                600
            ],
            [
                "Bruce",
                600
            ],
            [
                "Arthur",
                600
            ],
            [
                "Ian",
                520
            ],
            [
                "George",
                520
            ],
            [
                "Michael",
                540
            ],
            [
                "David",
                520
            ],
            [
                "Stacy",
                540
            ],
            [
                "Mark",
                520
            ],
            [
                "Eric",
                520
            ],
            [
                "Paul",
                520
            ],
            [
                "Eric",
                550
            ],
            [
                "Lisa",
                550
            ],
            [
                "Eric",
                550
            ],
            [
                "William",
                550
            ],
            [
                "Eric",
                50
            ],
            [
                "Sarah",
                50
            ]
        ],
        "cypher_query": "MATCH (student:`allergy_1.Student`)\nWHERE NOT (student:`allergy_1.Student`)-[]-(:`allergy_1.Has_Allergy { Allergy : 'Soy' }`)\nRETURN student.Fname,student.Major",
        "cypher_ans": [
            [
                "Linda",
                600
            ],
            [
                "Tracy",
                600
            ],
            [
                "Shiela",
                600
            ],
            [
                "Dinesh",
                600
            ],
            [
                "Paul",
                600
            ],
            [
                "Andy",
                600
            ],
            [
                "Lisa",
                600
            ],
            [
                "Jandy",
                600
            ],
            [
                "Eric",
                600
            ],
            [
                "Derek",
                600
            ],
            [
                "David",
                600
            ],
            [
                "Steven",
                600
            ],
            [
                "Charles",
                600
            ],
            [
                "Susan",
                600
            ],
            [
                "Mark",
                600
            ],
            [
                "Bruce",
                600
            ],
            [
                "Michael",
                600
            ],
            [
                "Arthur",
                600
            ],
            [
                "Ian",
                520
            ],
            [
                "George",
                520
            ],
            [
                "Michael",
                540
            ],
            [
                "David",
                520
            ],
            [
                "Stacy",
                540
            ],
            [
                "Mark",
                520
            ],
            [
                "Eric",
                520
            ],
            [
                "Paul",
                520
            ],
            [
                "Eric",
                550
            ],
            [
                "Jun",
                100
            ],
            [
                "Lisa",
                550
            ],
            [
                "Sarah",
                550
            ],
            [
                "Eric",
                550
            ],
            [
                "William",
                550
            ],
            [
                "Eric",
                50
            ],
            [
                "Sarah",
                50
            ]
        ]
    },
    {
        "db_id": "allergy_1",
        "query": "What are the first name and major of the students who are able to consume soy?",
        "sql_query": "SELECT fname ,  major FROM Student WHERE StuID NOT IN (SELECT StuID FROM Has_allergy WHERE Allergy  =  \"Soy\")",
        "parsed_sql": {
            "select": [
                {
                    "value": "fname"
                },
                {
                    "value": "major"
                }
            ],
            "from": "Student",
            "where": {
                "nin": [
                    "StuID",
                    {
                        "select": {
                            "value": "StuID"
                        },
                        "from": "Has_allergy",
                        "where": {
                            "eq": [
                                "Allergy",
                                "Soy"
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Linda",
                600
            ],
            [
                "Tracy",
                600
            ],
            [
                "Shiela",
                600
            ],
            [
                "Dinesh",
                600
            ],
            [
                "Paul",
                600
            ],
            [
                "Andy",
                600
            ],
            [
                "Lisa",
                600
            ],
            [
                "Jandy",
                600
            ],
            [
                "Eric",
                600
            ],
            [
                "Derek",
                600
            ],
            [
                "David",
                600
            ],
            [
                "Steven",
                600
            ],
            [
                "Charles",
                600
            ],
            [
                "Mark",
                600
            ],
            [
                "Bruce",
                600
            ],
            [
                "Arthur",
                600
            ],
            [
                "Ian",
                520
            ],
            [
                "George",
                520
            ],
            [
                "Michael",
                540
            ],
            [
                "David",
                520
            ],
            [
                "Stacy",
                540
            ],
            [
                "Mark",
                520
            ],
            [
                "Eric",
                520
            ],
            [
                "Paul",
                520
            ],
            [
                "Eric",
                550
            ],
            [
                "Lisa",
                550
            ],
            [
                "Eric",
                550
            ],
            [
                "William",
                550
            ],
            [
                "Eric",
                50
            ],
            [
                "Sarah",
                50
            ]
        ],
        "cypher_query": "MATCH (student:`allergy_1.Student`)\nWHERE NOT (student:`allergy_1.Student`)-[]-(:`allergy_1.Has_Allergy { Allergy : 'Soy' }`)\nRETURN student.Fname,student.Major",
        "cypher_ans": [
            [
                "Linda",
                600
            ],
            [
                "Tracy",
                600
            ],
            [
                "Shiela",
                600
            ],
            [
                "Dinesh",
                600
            ],
            [
                "Paul",
                600
            ],
            [
                "Andy",
                600
            ],
            [
                "Lisa",
                600
            ],
            [
                "Jandy",
                600
            ],
            [
                "Eric",
                600
            ],
            [
                "Derek",
                600
            ],
            [
                "David",
                600
            ],
            [
                "Steven",
                600
            ],
            [
                "Charles",
                600
            ],
            [
                "Susan",
                600
            ],
            [
                "Mark",
                600
            ],
            [
                "Bruce",
                600
            ],
            [
                "Michael",
                600
            ],
            [
                "Arthur",
                600
            ],
            [
                "Ian",
                520
            ],
            [
                "George",
                520
            ],
            [
                "Michael",
                540
            ],
            [
                "David",
                520
            ],
            [
                "Stacy",
                540
            ],
            [
                "Mark",
                520
            ],
            [
                "Eric",
                520
            ],
            [
                "Paul",
                520
            ],
            [
                "Eric",
                550
            ],
            [
                "Jun",
                100
            ],
            [
                "Lisa",
                550
            ],
            [
                "Sarah",
                550
            ],
            [
                "Eric",
                550
            ],
            [
                "William",
                550
            ],
            [
                "Eric",
                50
            ],
            [
                "Sarah",
                50
            ]
        ]
    },
    {
        "db_id": "store_1",
        "query": "List the number of invoices from Chicago, IL.",
        "sql_query": "SELECT COUNT(*) FROM invoices WHERE billing_city  =  \"Chicago\" AND billing_state  =  \"IL\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "invoices",
            "where": {
                "and": [
                    {
                        "eq": [
                            "billing_city",
                            "Chicago"
                        ]
                    },
                    {
                        "eq": [
                            "billing_state",
                            "IL"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                7
            ]
        ],
        "cypher_query": "MATCH (invoices:`store_1.invoices`)\nWHERE invoices.billing_city = 'Chicago' AND invoices.billing_state = 'IL'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "store_1",
        "query": "How many invoices were billed from Chicago, IL?",
        "sql_query": "SELECT COUNT(*) FROM invoices WHERE billing_city  =  \"Chicago\" AND billing_state  =  \"IL\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "invoices",
            "where": {
                "and": [
                    {
                        "eq": [
                            "billing_city",
                            "Chicago"
                        ]
                    },
                    {
                        "eq": [
                            "billing_state",
                            "IL"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                7
            ]
        ],
        "cypher_query": "MATCH (invoices:`store_1.invoices`)\nWHERE invoices.billing_city = 'Chicago' AND invoices.billing_state = 'IL'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "store_1",
        "query": "How many albums does Billy Cobham has?",
        "sql_query": "SELECT count(*) FROM albums AS T1 JOIN artists AS T2 ON  T1.artist_id = T2.id WHERE T2.name = \"Billy Cobham\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "albums",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "artists",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.artist_id",
                            "T2.id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.name",
                    "Billy Cobham"
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`store_1.albums`)-[]-(T2:`store_1.artists`)\nWHERE T2.name = 'Billy Cobham'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "store_1",
        "query": "How many albums has Billy Cobam released?",
        "sql_query": "SELECT count(*) FROM albums AS T1 JOIN artists AS T2 ON  T1.artist_id = T2.id WHERE T2.name = \"Billy Cobham\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "albums",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "artists",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.artist_id",
                            "T2.id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.name",
                    "Billy Cobham"
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`store_1.albums`)-[]-(T2:`store_1.artists`)\nWHERE T2.name = 'Billy Cobham'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "store_1",
        "query": "How many customers live in Prague city?",
        "sql_query": "SELECT count(*) FROM customers WHERE city = \"Prague\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "customers",
            "where": {
                "eq": [
                    "city",
                    "Prague"
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (customers:`store_1.customers`)\nWHERE customers.city = 'Prague'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "store_1",
        "query": "How many customers live in the city of Prague?",
        "sql_query": "SELECT count(*) FROM customers WHERE city = \"Prague\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "customers",
            "where": {
                "eq": [
                    "city",
                    "Prague"
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (customers:`store_1.customers`)\nWHERE customers.city = 'Prague'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "store_1",
        "query": "How many customers in state of CA?",
        "sql_query": "SELECT count(*) FROM customers WHERE state = \"CA\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "customers",
            "where": {
                "eq": [
                    "state",
                    "CA"
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (customers:`store_1.customers`)\nWHERE customers.state = 'CA'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "store_1",
        "query": "How many customers are from California?",
        "sql_query": "SELECT count(*) FROM customers WHERE state = \"CA\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "customers",
            "where": {
                "eq": [
                    "state",
                    "CA"
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (customers:`store_1.customers`)\nWHERE customers.state = 'CA'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "store_1",
        "query": "How many customers does Steve Johnson support?",
        "sql_query": "SELECT count(*) FROM employees AS T1 JOIN customers AS T2 ON T2.support_rep_id = T1.id WHERE T1.first_name = \"Steve\" AND T1.last_name = \"Johnson\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "employees",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "customers",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T2.support_rep_id",
                            "T1.id"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.first_name",
                            "Steve"
                        ]
                    },
                    {
                        "eq": [
                            "T1.last_name",
                            "Johnson"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                18
            ]
        ],
        "cypher_query": "MATCH (T1:`store_1.employees`)-[]-(T2:`store_1.customers`)\nWHERE T1.first_name = 'Steve' AND T1.last_name = 'Johnson'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "store_1",
        "query": "What is the count of customers that Steve Johnson supports?",
        "sql_query": "SELECT count(*) FROM employees AS T1 JOIN customers AS T2 ON T2.support_rep_id = T1.id WHERE T1.first_name = \"Steve\" AND T1.last_name = \"Johnson\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "employees",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "customers",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T2.support_rep_id",
                            "T1.id"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.first_name",
                            "Steve"
                        ]
                    },
                    {
                        "eq": [
                            "T1.last_name",
                            "Johnson"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                18
            ]
        ],
        "cypher_query": "MATCH (T1:`store_1.employees`)-[]-(T2:`store_1.customers`)\nWHERE T1.first_name = 'Steve' AND T1.last_name = 'Johnson'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "store_1",
        "query": "How many employees are living in Canada?",
        "sql_query": "SELECT count(*) FROM employees WHERE country = \"Canada\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "employees",
            "where": {
                "eq": [
                    "country",
                    "Canada"
                ]
            }
        },
        "sql_ans": [
            [
                8
            ]
        ],
        "cypher_query": "MATCH (employees:`store_1.employees`)\nWHERE employees.country = 'Canada'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "store_1",
        "query": "How many employees live in Canada?",
        "sql_query": "SELECT count(*) FROM employees WHERE country = \"Canada\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "employees",
            "where": {
                "eq": [
                    "country",
                    "Canada"
                ]
            }
        },
        "sql_ans": [
            [
                8
            ]
        ],
        "cypher_query": "MATCH (employees:`store_1.employees`)\nWHERE employees.country = 'Canada'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "store_1",
        "query": "How many orders does Lucas Mancini has?",
        "sql_query": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = \"Lucas\" AND T1.last_name = \"Mancini\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "customers",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "invoices",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.first_name",
                            "Lucas"
                        ]
                    },
                    {
                        "eq": [
                            "T1.last_name",
                            "Mancini"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                7
            ]
        ],
        "cypher_query": "MATCH (T1:`store_1.customers`)-[]-(T2:`store_1.invoices`)\nWHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "store_1",
        "query": "How many orders does Luca Mancini have in his invoices?",
        "sql_query": "SELECT count(*) FROM customers AS T1 JOIN invoices AS T2 ON T1.id = T2.customer_id WHERE T1.first_name = \"Lucas\" AND T1.last_name = \"Mancini\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "customers",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "invoices",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.first_name",
                            "Lucas"
                        ]
                    },
                    {
                        "eq": [
                            "T1.last_name",
                            "Mancini"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                7
            ]
        ],
        "cypher_query": "MATCH (T1:`store_1.customers`)-[]-(T2:`store_1.invoices`)\nWHERE T1.first_name = 'Lucas' AND T1.last_name = 'Mancini'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "journal_committee",
        "query": "Please show the most common age of editors.",
        "sql_query": "SELECT Age FROM editor GROUP BY Age ORDER BY COUNT(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "Age"
            },
            "from": "editor",
            "groupby": {
                "value": "Age"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                54.0
            ]
        ],
        "cypher_query": "MATCH (editor:`journal_committee.editor`)\nWITH count(editor.Age) AS count, editor.Age AS Age\nRETURN Age\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                34.0
            ]
        ]
    },
    {
        "db_id": "customers_card_transactions",
        "query": "How many accounts does the customer with first name Art and last name Turcotte have?",
        "sql_query": "SELECT count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  \"Art\" AND T2.customer_last_name  =  \"Turcotte\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "Accounts",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Customers",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.customer_id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T2.customer_first_name",
                            "Art"
                        ]
                    },
                    {
                        "eq": [
                            "T2.customer_last_name",
                            "Turcotte"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (T1:`customers_card_transactions.Accounts`)-[]-(T2:`customers_card_transactions.Customers`)\nWHERE T2.customer_first_name = 'Art' AND T2.customer_last_name = 'Turcotte'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "customers_card_transactions",
        "query": "Return the number of accounts that the customer with the first name Art and last name Turcotte has.",
        "sql_query": "SELECT count(*) FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  \"Art\" AND T2.customer_last_name  =  \"Turcotte\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "Accounts",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Customers",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.customer_id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T2.customer_first_name",
                            "Art"
                        ]
                    },
                    {
                        "eq": [
                            "T2.customer_last_name",
                            "Turcotte"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (T1:`customers_card_transactions.Accounts`)-[]-(T2:`customers_card_transactions.Customers`)\nWHERE T2.customer_first_name = 'Art' AND T2.customer_last_name = 'Turcotte'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "customers_card_transactions",
        "query": "Show the number of all customers without an account.",
        "sql_query": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Customers",
            "where": {
                "nin": [
                    "customer_id",
                    {
                        "select": {
                            "value": "customer_id"
                        },
                        "from": "Accounts"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                6
            ]
        ],
        "cypher_query": "MATCH (customers:`customers_card_transactions.Customers`)\nWHERE NOT (customers:`customers_card_transactions.Customers`)-[]-(:`customers_card_transactions.Accounts`)\nRETURN count(*)",
        "cypher_ans": [
            [
                15
            ]
        ]
    },
    {
        "db_id": "customers_card_transactions",
        "query": "How many customers do not have an account?",
        "sql_query": "SELECT count(*) FROM Customers WHERE customer_id NOT IN (SELECT customer_id FROM Accounts)",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Customers",
            "where": {
                "nin": [
                    "customer_id",
                    {
                        "select": {
                            "value": "customer_id"
                        },
                        "from": "Accounts"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                6
            ]
        ],
        "cypher_query": "MATCH (customers:`customers_card_transactions.Customers`)\nWHERE NOT (customers:`customers_card_transactions.Customers`)-[]-(:`customers_card_transactions.Accounts`)\nRETURN count(*)",
        "cypher_ans": [
            [
                15
            ]
        ]
    },
    {
        "db_id": "customers_card_transactions",
        "query": "How many credit cards does customer Blanche Huels have?",
        "sql_query": "SELECT count(*) FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  \"Blanche\" AND T2.customer_last_name  =  \"Huels\" AND T1.card_type_code  =  \"Credit\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "Customers_cards",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Customers",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.customer_id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T2.customer_first_name",
                            "Blanche"
                        ]
                    },
                    {
                        "eq": [
                            "T2.customer_last_name",
                            "Huels"
                        ]
                    },
                    {
                        "eq": [
                            "T1.card_type_code",
                            "Credit"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`customers_card_transactions.Customers_Cards`)-[]-(T2:`customers_card_transactions.Customers`)\nWHERE T2.customer_first_name = 'Blanche' AND T2.customer_last_name = 'Huels' AND T1.card_type_code = 'Credit'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "customers_card_transactions",
        "query": "Count the number of credit cards that the customer with first name Blanche and last name Huels has.",
        "sql_query": "SELECT count(*) FROM Customers_cards AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id WHERE T2.customer_first_name  =  \"Blanche\" AND T2.customer_last_name  =  \"Huels\" AND T1.card_type_code  =  \"Credit\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "Customers_cards",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Customers",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.customer_id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T2.customer_first_name",
                            "Blanche"
                        ]
                    },
                    {
                        "eq": [
                            "T2.customer_last_name",
                            "Huels"
                        ]
                    },
                    {
                        "eq": [
                            "T1.card_type_code",
                            "Credit"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`customers_card_transactions.Customers_Cards`)-[]-(T2:`customers_card_transactions.Customers`)\nWHERE T2.customer_first_name = 'Blanche' AND T2.customer_last_name = 'Huels' AND T1.card_type_code = 'Credit'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "customers_card_transactions",
        "query": "What is the customer id with most number of cards, and how many does he have?",
        "sql_query": "SELECT customer_id ,  count(*) FROM Customers_cards GROUP BY customer_id ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "customer_id"
                },
                {
                    "value": {
                        "count": "*"
                    }
                }
            ],
            "from": "Customers_cards",
            "groupby": {
                "value": "customer_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                10,
                2
            ]
        ],
        "cypher_query": "MATCH (customers_cards:`customers_card_transactions.Customers_Cards`)\nWITH count(customers_cards.customer_id) AS count, customers_cards.customer_id AS customer_id\nRETURN customer_id,count\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                9,
                2
            ]
        ]
    },
    {
        "db_id": "customers_card_transactions",
        "query": "Return the id of the customer who has the most cards, as well as the number of cards.",
        "sql_query": "SELECT customer_id ,  count(*) FROM Customers_cards GROUP BY customer_id ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "customer_id"
                },
                {
                    "value": {
                        "count": "*"
                    }
                }
            ],
            "from": "Customers_cards",
            "groupby": {
                "value": "customer_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                10,
                2
            ]
        ],
        "cypher_query": "MATCH (customers_cards:`customers_card_transactions.Customers_Cards`)\nWITH count(customers_cards.customer_id) AS count, customers_cards.customer_id AS customer_id\nRETURN customer_id,count\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                9,
                2
            ]
        ]
    },
    {
        "db_id": "customers_card_transactions",
        "query": "Show the number of transaction types.",
        "sql_query": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "transaction_type"
                        }
                    }
                }
            },
            "from": "Financial_Transactions"
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (financial_transactions:`customers_card_transactions.Financial_Transactions`)\nRETURN count(DISTINCT financial_transactions.transaction_type)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "customers_card_transactions",
        "query": "How many different types of transactions are there?",
        "sql_query": "SELECT count(DISTINCT transaction_type) FROM Financial_Transactions",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "transaction_type"
                        }
                    }
                }
            },
            "from": "Financial_Transactions"
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (financial_transactions:`customers_card_transactions.Financial_Transactions`)\nRETURN count(DISTINCT financial_transactions.transaction_type)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "race_track",
        "query": "Show all track names that have had no races.",
        "sql_query": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "parsed_sql": {
            "select": {
                "value": "name"
            },
            "from": "track",
            "where": {
                "nin": [
                    "track_id",
                    {
                        "select": {
                            "value": "track_id"
                        },
                        "from": "race"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Darlington Raceway"
            ],
            [
                "Michigan International Speedway"
            ],
            [
                "Phoenix International Raceway"
            ]
        ],
        "cypher_query": "MATCH (track:`race_track.track`)\nWHERE NOT (track:`race_track.track`)-[]-(:`race_track.race`)\nRETURN track.Name",
        "cypher_ans": [
            [
                "Auto Club Speedway"
            ],
            [
                "Chicagoland Speedway"
            ],
            [
                "Darlington Raceway"
            ],
            [
                "Daytona International Speedway"
            ],
            [
                "Homestead-Miami Speedway"
            ],
            [
                "Kansas Speedway"
            ],
            [
                "Martinsville Speedway"
            ],
            [
                "Michigan International Speedway"
            ],
            [
                "Phoenix International Raceway"
            ]
        ]
    },
    {
        "db_id": "race_track",
        "query": "Return the names of tracks that have no had any races.",
        "sql_query": "SELECT name FROM track WHERE track_id NOT IN (SELECT track_id FROM race)",
        "parsed_sql": {
            "select": {
                "value": "name"
            },
            "from": "track",
            "where": {
                "nin": [
                    "track_id",
                    {
                        "select": {
                            "value": "track_id"
                        },
                        "from": "race"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Darlington Raceway"
            ],
            [
                "Michigan International Speedway"
            ],
            [
                "Phoenix International Raceway"
            ]
        ],
        "cypher_query": "MATCH (track:`race_track.track`)\nWHERE NOT (track:`race_track.track`)-[]-(:`race_track.race`)\nRETURN track.Name",
        "cypher_ans": [
            [
                "Auto Club Speedway"
            ],
            [
                "Chicagoland Speedway"
            ],
            [
                "Darlington Raceway"
            ],
            [
                "Daytona International Speedway"
            ],
            [
                "Homestead-Miami Speedway"
            ],
            [
                "Kansas Speedway"
            ],
            [
                "Martinsville Speedway"
            ],
            [
                "Michigan International Speedway"
            ],
            [
                "Phoenix International Raceway"
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "How many albums are there?",
        "sql_query": "SELECT count(*) FROM ALBUM",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "ALBUM"
        },
        "sql_ans": [
            [
                347
            ]
        ],
        "cypher_query": "MATCH (album:`chinook_1.Album`)\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "Find the number of albums.",
        "sql_query": "SELECT count(*) FROM ALBUM",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "ALBUM"
        },
        "sql_ans": [
            [
                347
            ]
        ],
        "cypher_query": "MATCH (album:`chinook_1.Album`)\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "Hom many albums does the artist \"Metallica\" have?",
        "sql_query": "SELECT COUNT(*) FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId WHERE T2.Name  =  \"Metallica\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "ALBUM",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "ARTIST",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.ArtistId",
                            "T2.ArtistId"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.Name",
                    "Metallica"
                ]
            }
        },
        "sql_ans": [
            [
                10
            ]
        ],
        "cypher_query": "MATCH (T1:`chinook_1.Album`)-[]-(T2:`chinook_1.Artist`)\nWHERE T2.Name = 'Metallica'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "Find the number of albums by the artist \"Metallica\".",
        "sql_query": "SELECT COUNT(*) FROM ALBUM AS T1 JOIN ARTIST AS T2 ON T1.ArtistId  =  T2.ArtistId WHERE T2.Name  =  \"Metallica\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "ALBUM",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "ARTIST",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.ArtistId",
                            "T2.ArtistId"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.Name",
                    "Metallica"
                ]
            }
        },
        "sql_ans": [
            [
                10
            ]
        ],
        "cypher_query": "MATCH (T1:`chinook_1.Album`)-[]-(T2:`chinook_1.Artist`)\nWHERE T2.Name = 'Metallica'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "What is the average unit price of all the tracks?",
        "sql_query": "SELECT AVG(UnitPrice) FROM TRACK",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "UnitPrice"
                }
            },
            "from": "TRACK"
        },
        "sql_ans": [
            [
                1.0508050242648312
            ]
        ],
        "cypher_query": "MATCH (track:`chinook_1.Track`)\nRETURN avg(track.UnitPrice)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "Find the average unit price for a track.",
        "sql_query": "SELECT AVG(UnitPrice) FROM TRACK",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "UnitPrice"
                }
            },
            "from": "TRACK"
        },
        "sql_ans": [
            [
                1.0508050242648312
            ]
        ],
        "cypher_query": "MATCH (track:`chinook_1.Track`)\nRETURN avg(track.UnitPrice)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "What are the durations of the longest and the shortest tracks in milliseconds?",
        "sql_query": "SELECT max(Milliseconds) ,  min(Milliseconds) FROM TRACK",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "Milliseconds"
                    }
                },
                {
                    "value": {
                        "min": "Milliseconds"
                    }
                }
            ],
            "from": "TRACK"
        },
        "sql_ans": [
            [
                5286953,
                1071
            ]
        ],
        "cypher_query": "MATCH (track:`chinook_1.Track`)\nRETURN max(track.Milliseconds),min(track.Milliseconds)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "Find the maximum and minimum durations of tracks in milliseconds.",
        "sql_query": "SELECT max(Milliseconds) ,  min(Milliseconds) FROM TRACK",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "Milliseconds"
                    }
                },
                {
                    "value": {
                        "min": "Milliseconds"
                    }
                }
            ],
            "from": "TRACK"
        },
        "sql_ans": [
            [
                5286953,
                1071
            ]
        ],
        "cypher_query": "MATCH (track:`chinook_1.Track`)\nRETURN max(track.Milliseconds),min(track.Milliseconds)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "How many tracks belong to rock genre?",
        "sql_query": "SELECT COUNT(*) FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId WHERE T1.Name  =  \"Rock\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "GENRE",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "TRACK",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.GenreId",
                            "T2.GenreId"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.Name",
                    "Rock"
                ]
            }
        },
        "sql_ans": [
            [
                1297
            ]
        ],
        "cypher_query": "MATCH (T1:`chinook_1.Genre`)-[]-(T2:`chinook_1.Track`)\nWHERE T1.Name = 'Rock'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "Count the number of tracks that are part of the rock genre.",
        "sql_query": "SELECT COUNT(*) FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId WHERE T1.Name  =  \"Rock\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "GENRE",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "TRACK",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.GenreId",
                            "T2.GenreId"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.Name",
                    "Rock"
                ]
            }
        },
        "sql_ans": [
            [
                1297
            ]
        ],
        "cypher_query": "MATCH (T1:`chinook_1.Genre`)-[]-(T2:`chinook_1.Track`)\nWHERE T1.Name = 'Rock'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "What is the average unit price of tracks that belong to Jazz genre?",
        "sql_query": "SELECT AVG(UnitPrice) FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId WHERE T1.Name  =  \"Jazz\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "UnitPrice"
                }
            },
            "from": [
                {
                    "value": "GENRE",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "TRACK",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.GenreId",
                            "T2.GenreId"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.Name",
                    "Jazz"
                ]
            }
        },
        "sql_ans": [
            [
                0.9899999999999978
            ]
        ],
        "cypher_query": "MATCH (T1:`chinook_1.Genre`)-[]-(T2:`chinook_1.Track`)\nWHERE T1.Name = 'Jazz'\nRETURN avg(T2.UnitPrice)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "Find the average unit price of jazz tracks.",
        "sql_query": "SELECT AVG(UnitPrice) FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId WHERE T1.Name  =  \"Jazz\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "UnitPrice"
                }
            },
            "from": [
                {
                    "value": "GENRE",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "TRACK",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.GenreId",
                            "T2.GenreId"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.Name",
                    "Jazz"
                ]
            }
        },
        "sql_ans": [
            [
                0.9899999999999978
            ]
        ],
        "cypher_query": "MATCH (T1:`chinook_1.Genre`)-[]-(T2:`chinook_1.Track`)\nWHERE T1.Name = 'Jazz'\nRETURN avg(T2.UnitPrice)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "How many customers have email that contains \"gmail.com\"?",
        "sql_query": "SELECT COUNT(*) FROM CUSTOMER WHERE Email LIKE \"%gmail.com%\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "CUSTOMER",
            "where": {
                "like": [
                    "Email",
                    "%gmail\\.com%"
                ]
            }
        },
        "sql_ans": [
            [
                8
            ]
        ],
        "cypher_query": "MATCH (customer:`chinook_1.Customer`)\nWHERE customer.Email =~'.*[\"|\"]%gmail\\.com%\".*'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "Count the number of customers that have an email containing \"gmail.com\".",
        "sql_query": "SELECT COUNT(*) FROM CUSTOMER WHERE Email LIKE \"%gmail.com%\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "CUSTOMER",
            "where": {
                "like": [
                    "Email",
                    "%gmail\\.com%"
                ]
            }
        },
        "sql_ans": [
            [
                8
            ]
        ],
        "cypher_query": "MATCH (customer:`chinook_1.Customer`)\nWHERE customer.Email =~'.*[\"|\"]%gmail\\.com%\".*'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "How many distinct cities does the employees live in?",
        "sql_query": "SELECT COUNT(DISTINCT city) FROM EMPLOYEE",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "city"
                        }
                    }
                }
            },
            "from": "EMPLOYEE"
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (employee:`chinook_1.Employee`)\nRETURN count(DISTINCT employee.City)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "Find the number of different cities that employees live in.",
        "sql_query": "SELECT COUNT(DISTINCT city) FROM EMPLOYEE",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "city"
                        }
                    }
                }
            },
            "from": "EMPLOYEE"
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (employee:`chinook_1.Employee`)\nRETURN count(DISTINCT employee.City)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "How many tracks are in the AAC audio file media type?",
        "sql_query": "SELECT COUNT(*) FROM MEDIATYPE AS T1 JOIN TRACK AS T2 ON T1.MediaTypeId  =  T2.MediaTypeId WHERE T1.Name  =  \"AAC audio file\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "MEDIATYPE",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "TRACK",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.MediaTypeId",
                            "T2.MediaTypeId"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.Name",
                    "AAC audio file"
                ]
            }
        },
        "sql_ans": [
            [
                11
            ]
        ],
        "cypher_query": "MATCH (T1:`chinook_1.MediaType`)-[]-(T2:`chinook_1.Track`)\nWHERE T1.Name = 'AAC audio file'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "Count the number of tracks that are of the media type \"AAC audio file\".",
        "sql_query": "SELECT COUNT(*) FROM MEDIATYPE AS T1 JOIN TRACK AS T2 ON T1.MediaTypeId  =  T2.MediaTypeId WHERE T1.Name  =  \"AAC audio file\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "MEDIATYPE",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "TRACK",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.MediaTypeId",
                            "T2.MediaTypeId"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.Name",
                    "AAC audio file"
                ]
            }
        },
        "sql_ans": [
            [
                11
            ]
        ],
        "cypher_query": "MATCH (T1:`chinook_1.MediaType`)-[]-(T2:`chinook_1.Track`)\nWHERE T1.Name = 'AAC audio file'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "What is the average duration in milliseconds of tracks that belong to Latin or Pop genre?",
        "sql_query": "SELECT AVG(Milliseconds) FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId WHERE T1.Name  =  \"Latin\" OR T1.Name  =  \"Pop\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "Milliseconds"
                }
            },
            "from": [
                {
                    "value": "GENRE",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "TRACK",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.GenreId",
                            "T2.GenreId"
                        ]
                    }
                }
            ],
            "where": {
                "or": [
                    {
                        "eq": [
                            "T1.Name",
                            "Latin"
                        ]
                    },
                    {
                        "eq": [
                            "T1.Name",
                            "Pop"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                232566.4274322169
            ]
        ],
        "cypher_query": "MATCH (T1:`chinook_1.Genre`)-[]-(T2:`chinook_1.Track`)\nWHERE T1.Name = 'Latin' OR T1.Name = 'Pop'\nRETURN avg(T2.Milliseconds)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "Find the average millisecond length of Latin and Pop tracks.",
        "sql_query": "SELECT AVG(Milliseconds) FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId WHERE T1.Name  =  \"Latin\" OR T1.Name  =  \"Pop\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "Milliseconds"
                }
            },
            "from": [
                {
                    "value": "GENRE",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "TRACK",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.GenreId",
                            "T2.GenreId"
                        ]
                    }
                }
            ],
            "where": {
                "or": [
                    {
                        "eq": [
                            "T1.Name",
                            "Latin"
                        ]
                    },
                    {
                        "eq": [
                            "T1.Name",
                            "Pop"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                232566.4274322169
            ]
        ],
        "cypher_query": "MATCH (T1:`chinook_1.Genre`)-[]-(T2:`chinook_1.Track`)\nWHERE T1.Name = 'Latin' OR T1.Name = 'Pop'\nRETURN avg(T2.Milliseconds)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "What is the average unit price of rock tracks?",
        "sql_query": "SELECT AVG(T2.UnitPrice) FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId WHERE T1.Name  =  \"Rock\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T2.UnitPrice"
                }
            },
            "from": [
                {
                    "value": "GENRE",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "TRACK",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.GenreId",
                            "T2.GenreId"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.Name",
                    "Rock"
                ]
            }
        },
        "sql_ans": [
            [
                0.9900000000000079
            ]
        ],
        "cypher_query": "MATCH (T1:`chinook_1.Genre`)-[]-(T2:`chinook_1.Track`)\nWHERE T1.Name = 'Rock'\nRETURN avg(T2.UnitPrice)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "Find the average unit price of tracks from the Rock genre.",
        "sql_query": "SELECT AVG(T2.UnitPrice) FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId WHERE T1.Name  =  \"Rock\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T2.UnitPrice"
                }
            },
            "from": [
                {
                    "value": "GENRE",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "TRACK",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.GenreId",
                            "T2.GenreId"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.Name",
                    "Rock"
                ]
            }
        },
        "sql_ans": [
            [
                0.9900000000000079
            ]
        ],
        "cypher_query": "MATCH (T1:`chinook_1.Genre`)-[]-(T2:`chinook_1.Track`)\nWHERE T1.Name = 'Rock'\nRETURN avg(T2.UnitPrice)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "What are the duration of the longest and shortest pop tracks in milliseconds?",
        "sql_query": "SELECT max(Milliseconds) ,  min(Milliseconds) FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId WHERE T1.Name  =  \"Pop\"",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "Milliseconds"
                    }
                },
                {
                    "value": {
                        "min": "Milliseconds"
                    }
                }
            ],
            "from": [
                {
                    "value": "GENRE",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "TRACK",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.GenreId",
                            "T2.GenreId"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.Name",
                    "Pop"
                ]
            }
        },
        "sql_ans": [
            [
                663426,
                129666
            ]
        ],
        "cypher_query": "MATCH (T1:`chinook_1.Genre`)-[]-(T2:`chinook_1.Track`)\nWHERE T1.Name = 'Pop'\nRETURN max(T2.Milliseconds),min(T2.Milliseconds)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "Find the maximum and minimum millisecond lengths of pop tracks.",
        "sql_query": "SELECT max(Milliseconds) ,  min(Milliseconds) FROM GENRE AS T1 JOIN TRACK AS T2 ON T1.GenreId  =  T2.GenreId WHERE T1.Name  =  \"Pop\"",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "Milliseconds"
                    }
                },
                {
                    "value": {
                        "min": "Milliseconds"
                    }
                }
            ],
            "from": [
                {
                    "value": "GENRE",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "TRACK",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.GenreId",
                            "T2.GenreId"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.Name",
                    "Pop"
                ]
            }
        },
        "sql_ans": [
            [
                663426,
                129666
            ]
        ],
        "cypher_query": "MATCH (T1:`chinook_1.Genre`)-[]-(T2:`chinook_1.Track`)\nWHERE T1.Name = 'Pop'\nRETURN max(T2.Milliseconds),min(T2.Milliseconds)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "How many artists do not have any album?",
        "sql_query": "SELECT count(*) FROM ARTIST WHERE artistid NOT IN(SELECT artistid FROM ALBUM)",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "ARTIST",
            "where": {
                "nin": [
                    "artistid",
                    {
                        "select": {
                            "value": "artistid"
                        },
                        "from": "ALBUM"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                71
            ]
        ],
        "cypher_query": "MATCH (artist:`chinook_1.Artist`)\nWHERE NOT (artist:`chinook_1.Artist`)-[]-(:`chinook_1.Album`)\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "chinook_1",
        "query": "Cound the number of artists who have not released an album.",
        "sql_query": "SELECT count(*) FROM ARTIST WHERE artistid NOT IN(SELECT artistid FROM ALBUM)",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "ARTIST",
            "where": {
                "nin": [
                    "artistid",
                    {
                        "select": {
                            "value": "artistid"
                        },
                        "from": "ALBUM"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                71
            ]
        ],
        "cypher_query": "MATCH (artist:`chinook_1.Artist`)\nWHERE NOT (artist:`chinook_1.Artist`)-[]-(:`chinook_1.Album`)\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "query": "What is the most common interaction type between enzymes and medicine? And how many are there?",
        "sql_query": "SELECT interaction_type ,  count(*) FROM medicine_enzyme_interaction GROUP BY interaction_type ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "interaction_type"
                },
                {
                    "value": {
                        "count": "*"
                    }
                }
            ],
            "from": "medicine_enzyme_interaction",
            "groupby": {
                "value": "interaction_type"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "inhibitor",
                11
            ]
        ],
        "cypher_query": "MATCH ()-[medicine_enzyme_interaction:`medicine_enzyme_interaction.medicine_enzyme_interaction`]-()\nWITH medicine_enzyme_interaction.interaction_type AS interaction_type, count(medicine_enzyme_interaction.interaction_type) AS count\nRETURN interaction_type,count\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "inhibitor",
                22
            ]
        ]
    },
    {
        "db_id": "medicine_enzyme_interaction",
        "query": "What are the most common types of interactions between enzymes and medicine, and how many types are there?",
        "sql_query": "SELECT interaction_type ,  count(*) FROM medicine_enzyme_interaction GROUP BY interaction_type ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "interaction_type"
                },
                {
                    "value": {
                        "count": "*"
                    }
                }
            ],
            "from": "medicine_enzyme_interaction",
            "groupby": {
                "value": "interaction_type"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "inhibitor",
                11
            ]
        ],
        "cypher_query": "MATCH ()-[medicine_enzyme_interaction:`medicine_enzyme_interaction.medicine_enzyme_interaction`]-()\nWITH medicine_enzyme_interaction.interaction_type AS interaction_type, count(medicine_enzyme_interaction.interaction_type) AS count\nRETURN interaction_type,count\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "inhibitor",
                22
            ]
        ]
    },
    {
        "db_id": "university_basketball",
        "query": "Find how many school locations have the word 'NY'.",
        "sql_query": "SELECT count(*) FROM university WHERE LOCATION LIKE \"%NY%\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "university",
            "where": {
                "like": [
                    "LOCATION",
                    "%NY%"
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (university:`university_basketball.university`)\nWHERE university.Location =~'.*[\"|\"]%NY%\".*'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "university_basketball",
        "query": "How many universities have a location that contains NY?",
        "sql_query": "SELECT count(*) FROM university WHERE LOCATION LIKE \"%NY%\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "university",
            "where": {
                "like": [
                    "LOCATION",
                    "%NY%"
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (university:`university_basketball.university`)\nWHERE university.Location =~'.*[\"|\"]%NY%\".*'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "phone_1",
        "query": "What is maximum and minimum RAM size of phone produced by company named \"Nokia Corporation\"?",
        "sql_query": "SELECT max(T1.RAM_MiB) ,  min(T1.RAM_MiB) FROM chip_model AS T1 JOIN phone AS T2 ON T1.Model_name  =  T2.chip_model WHERE T2.Company_name = \"Nokia Corporation\";",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "T1.RAM_MiB"
                    }
                },
                {
                    "value": {
                        "min": "T1.RAM_MiB"
                    }
                }
            ],
            "from": [
                {
                    "value": "chip_model",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "phone",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Model_name",
                            "T2.chip_model"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.Company_name",
                    "Nokia Corporation"
                ]
            }
        },
        "sql_ans": [
            [
                32.0,
                32.0
            ]
        ],
        "cypher_query": "MATCH (T1:`phone_1.chip_model`)-[]-(T2:`phone_1.phone`)\nWHERE T2.Company_name = 'Nokia Corporation'\nRETURN max(T1.RAM_MiB),min(T1.RAM_MiB)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "phone_1",
        "query": "What is the average ROM size of phones produced by the company named \"Nokia Corporation\"?",
        "sql_query": "SELECT avg(T1.ROM_MiB) FROM chip_model AS T1 JOIN phone AS T2 ON T1.Model_name  =  T2.chip_model WHERE T2.Company_name = \"Nokia Corporation\";",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T1.ROM_MiB"
                }
            },
            "from": [
                {
                    "value": "chip_model",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "phone",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Model_name",
                            "T2.chip_model"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.Company_name",
                    "Nokia Corporation"
                ]
            }
        },
        "sql_ans": [
            [
                32.0
            ]
        ],
        "cypher_query": "MATCH (T1:`phone_1.chip_model`)-[]-(T2:`phone_1.phone`)\nWHERE T2.Company_name = 'Nokia Corporation'\nRETURN avg(T1.ROM_MiB)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "phone_1",
        "query": "Find the name of the company that has the least number of phone models. List the company name and the number of phone model produced by that company.",
        "sql_query": "SELECT Company_name ,  count(*) FROM phone GROUP BY Company_name ORDER BY count(*) ASC LIMIT 1;",
        "parsed_sql": {
            "select": [
                {
                    "value": "Company_name"
                },
                {
                    "value": {
                        "count": "*"
                    }
                }
            ],
            "from": "phone",
            "groupby": {
                "value": "Company_name"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "asc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "HTC Corporation",
                1
            ]
        ],
        "cypher_query": "MATCH (phone:`phone_1.phone`)\nWITH phone.Company_name AS Company_name, count(phone.Company_name) AS count\nRETURN Company_name,count\nORDER BY count ASC\nLIMIT 1",
        "cypher_ans": [
            [
                "Sony Mobile Communications",
                1
            ]
        ]
    },
    {
        "db_id": "phone_1",
        "query": "Find the average ram mib size of the chip models that are never used by any phone.",
        "sql_query": "SELECT avg(RAM_MiB) FROM chip_model WHERE model_name NOT IN (SELECT chip_model FROM phone)",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "RAM_MiB"
                }
            },
            "from": "chip_model",
            "where": {
                "nin": [
                    "model_name",
                    {
                        "select": {
                            "value": "chip_model"
                        },
                        "from": "phone"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                60.0
            ]
        ],
        "cypher_query": "MATCH (chip_model:`phone_1.chip_model`)\nWHERE NOT (chip_model:`phone_1.chip_model`)-[]-(:`phone_1.phone`)\nRETURN avg(chip_model.RAM_MiB)",
        "cypher_ans": [
            [
                57.142857142857146
            ]
        ]
    },
    {
        "db_id": "match_season",
        "query": "What are the names of teams that do no have match season record?",
        "sql_query": "SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "parsed_sql": {
            "select": {
                "value": "Name"
            },
            "from": "team",
            "where": {
                "nin": [
                    "Team_id",
                    {
                        "select": {
                            "value": "Team"
                        },
                        "from": "match_season"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Brown Erdman"
            ],
            [
                "Los Angeles Galaxy"
            ],
            [
                "Berneice Hand"
            ]
        ],
        "cypher_query": "MATCH (team:`match_season.team`)\nWHERE NOT (team:`match_season.team`)-[]-(:`match_season.match_season`)\nRETURN team.Name",
        "cypher_ans": [
            [
                "Columbus Crew"
            ],
            [
                "Evalyn Feil"
            ],
            [
                "Anais VonRueden"
            ],
            [
                "Miami Fusion"
            ],
            [
                "Enrique Osinski"
            ],
            [
                "Brown Erdman"
            ],
            [
                "Los Angeles Galaxy"
            ],
            [
                "Berneice Hand"
            ],
            [
                "Ryley Goldner"
            ],
            [
                "D.C. United"
            ]
        ]
    },
    {
        "db_id": "match_season",
        "query": "Return the names of teams that have no match season record.",
        "sql_query": "SELECT Name FROM team WHERE Team_id NOT IN (SELECT Team FROM match_season)",
        "parsed_sql": {
            "select": {
                "value": "Name"
            },
            "from": "team",
            "where": {
                "nin": [
                    "Team_id",
                    {
                        "select": {
                            "value": "Team"
                        },
                        "from": "match_season"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Brown Erdman"
            ],
            [
                "Los Angeles Galaxy"
            ],
            [
                "Berneice Hand"
            ]
        ],
        "cypher_query": "MATCH (team:`match_season.team`)\nWHERE NOT (team:`match_season.team`)-[]-(:`match_season.match_season`)\nRETURN team.Name",
        "cypher_ans": [
            [
                "Columbus Crew"
            ],
            [
                "Evalyn Feil"
            ],
            [
                "Anais VonRueden"
            ],
            [
                "Miami Fusion"
            ],
            [
                "Enrique Osinski"
            ],
            [
                "Brown Erdman"
            ],
            [
                "Los Angeles Galaxy"
            ],
            [
                "Berneice Hand"
            ],
            [
                "Ryley Goldner"
            ],
            [
                "D.C. United"
            ]
        ]
    },
    {
        "db_id": "apartment_rentals",
        "query": "What is the average number of bedrooms of all apartments?",
        "sql_query": "SELECT avg(bedroom_count) FROM Apartments",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "bedroom_count"
                }
            },
            "from": "Apartments"
        },
        "sql_ans": [
            [
                4.466666666666667
            ]
        ],
        "cypher_query": "MATCH (apartments:`apartment_rentals.Apartments`)\nRETURN avg(apartments.bedroom_count)",
        "cypher_ans": [
            [
                4.466666666666666
            ]
        ]
    },
    {
        "db_id": "apartment_rentals",
        "query": "Find the average number of bedrooms of all the apartments.",
        "sql_query": "SELECT avg(bedroom_count) FROM Apartments",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "bedroom_count"
                }
            },
            "from": "Apartments"
        },
        "sql_ans": [
            [
                4.466666666666667
            ]
        ],
        "cypher_query": "MATCH (apartments:`apartment_rentals.Apartments`)\nRETURN avg(apartments.bedroom_count)",
        "cypher_ans": [
            [
                4.466666666666666
            ]
        ]
    },
    {
        "db_id": "apartment_rentals",
        "query": "Show the average room count of the apartments that have booking status code \"Provisional\".",
        "sql_query": "SELECT avg(room_count) FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  \"Provisional\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "room_count"
                }
            },
            "from": [
                {
                    "value": "Apartment_Bookings",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Apartments",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.apt_id",
                            "T2.apt_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.booking_status_code",
                    "Provisional"
                ]
            }
        },
        "sql_ans": [
            [
                6.5
            ]
        ],
        "cypher_query": "MATCH (T1:`apartment_rentals.Apartment_Bookings`)-[]-(T2:`apartment_rentals.Apartments`)\nWHERE T1.booking_status_code = 'Provisional'\nRETURN avg(T2.room_count)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "apartment_rentals",
        "query": "What is the average room count of the apartments whose booking status code is \"Provisional\"?",
        "sql_query": "SELECT avg(room_count) FROM Apartment_Bookings AS T1 JOIN Apartments AS T2 ON T1.apt_id  =  T2.apt_id WHERE T1.booking_status_code  =  \"Provisional\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "room_count"
                }
            },
            "from": [
                {
                    "value": "Apartment_Bookings",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Apartments",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.apt_id",
                            "T2.apt_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.booking_status_code",
                    "Provisional"
                ]
            }
        },
        "sql_ans": [
            [
                6.5
            ]
        ],
        "cypher_query": "MATCH (T1:`apartment_rentals.Apartment_Bookings`)-[]-(T2:`apartment_rentals.Apartments`)\nWHERE T1.booking_status_code = 'Provisional'\nRETURN avg(T2.room_count)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "soccer_1",
        "query": "How many leagues are there in England?",
        "sql_query": "SELECT count(*) FROM Country AS T1 JOIN League AS T2 ON T1.id  =  T2.country_id WHERE T1.name  =  \"England\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "Country",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "League",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.id",
                            "T2.country_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.name",
                    "England"
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`soccer_1.Country`)-[]-(T2:`soccer_1.League`)\nWHERE T1.name = 'England'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "soccer_1",
        "query": "What is the average weight of all players?",
        "sql_query": "SELECT avg(weight) FROM Player",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "weight"
                }
            },
            "from": "Player"
        },
        "sql_ans": [
            [
                168.38028933092224
            ]
        ],
        "cypher_query": "MATCH (player:`soccer_1.Player`)\nRETURN avg(player.weight)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "soccer_1",
        "query": "What is the maximum and minimum height of all players?",
        "sql_query": "SELECT max(weight) ,  min(weight) FROM Player",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "weight"
                    }
                },
                {
                    "value": {
                        "min": "weight"
                    }
                }
            ],
            "from": "Player"
        },
        "sql_ans": [
            [
                243,
                117
            ]
        ],
        "cypher_query": "MATCH (player:`soccer_1.Player`)\nRETURN max(player.weight),min(player.weight)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "performance_attendance",
        "query": "What is the average number of attendees for performances?",
        "sql_query": "SELECT avg(Attendance) FROM performance",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "Attendance"
                }
            },
            "from": "performance"
        },
        "sql_ans": [
            [
                1649.1666666666667
            ]
        ],
        "cypher_query": "MATCH (performance:`performance_attendance.performance`)\nRETURN avg(performance.Attendance)",
        "cypher_ans": [
            [
                1649.1666666666665
            ]
        ]
    },
    {
        "db_id": "performance_attendance",
        "query": "List the names of members who did not attend any performance.",
        "sql_query": "SELECT Name FROM member WHERE Member_ID NOT IN (SELECT Member_ID FROM member_attendance)",
        "parsed_sql": {
            "select": {
                "value": "Name"
            },
            "from": "member",
            "where": {
                "nin": [
                    "Member_ID",
                    {
                        "select": {
                            "value": "Member_ID"
                        },
                        "from": "member_attendance"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Andrew Moten"
            ],
            [
                "Corey Allen"
            ],
            [
                "John Eubanks"
            ],
            [
                "Joshua Pittman"
            ]
        ],
        "cypher_query": "MATCH (member:`performance_attendance.member`)\nWHERE NOT (member:`performance_attendance.member`)-[:`performance_attendance.member_attendance`]-()\nRETURN member.Name",
        "cypher_ans": [
            [
                "Wilfredo Ruiz"
            ],
            [
                "Luis Gonz\u00e1lez"
            ],
            [
                "H\u00e9ctor Campana"
            ],
            [
                "H\u00e9ctor Campana"
            ],
            [
                "Juan Espil"
            ],
            [
                "Andrew Moten"
            ],
            [
                "Charlie Burke"
            ],
            [
                "Corey Allen"
            ],
            [
                "John Eubanks"
            ],
            [
                "Joshua Pittman"
            ],
            [
                "Joseph Bunn"
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "Count the number of rooms that are not in the Lamberton building.",
        "sql_query": "SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "classroom",
            "where": {
                "neq": [
                    "building",
                    {
                        "literal": "Lamberton"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                28
            ]
        ],
        "cypher_query": "MATCH (classroom:`college_2.classroom`)\nWHERE classroom.building <> 'Lamberton'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "How many classrooms are not in Lamberton?",
        "sql_query": "SELECT count(*) FROM classroom WHERE building != 'Lamberton'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "classroom",
            "where": {
                "neq": [
                    "building",
                    {
                        "literal": "Lamberton"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                28
            ]
        ],
        "cypher_query": "MATCH (classroom:`college_2.classroom`)\nWHERE classroom.building <> 'Lamberton'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "How many rooms does the Lamberton building have?",
        "sql_query": "SELECT count(*) FROM classroom WHERE building  =  'Lamberton'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "classroom",
            "where": {
                "eq": [
                    "building",
                    {
                        "literal": "Lamberton"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (classroom:`college_2.classroom`)\nWHERE classroom.building = 'Lamberton'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "Count the number of classrooms in Lamberton.",
        "sql_query": "SELECT count(*) FROM classroom WHERE building  =  'Lamberton'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "classroom",
            "where": {
                "eq": [
                    "building",
                    {
                        "literal": "Lamberton"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (classroom:`college_2.classroom`)\nWHERE classroom.building = 'Lamberton'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "How many students have advisors?",
        "sql_query": "SELECT count(DISTINCT s_id) FROM advisor",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "s_id"
                        }
                    }
                }
            },
            "from": "advisor"
        },
        "sql_ans": [
            [
                2000
            ]
        ],
        "cypher_query": "MATCH (advisor:`college_2.advisor`)\nRETURN count(DISTINCT advisor.s_ID)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "Count the number of students who have advisors.",
        "sql_query": "SELECT count(DISTINCT s_id) FROM advisor",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "s_id"
                        }
                    }
                }
            },
            "from": "advisor"
        },
        "sql_ans": [
            [
                2000
            ]
        ],
        "cypher_query": "MATCH (advisor:`college_2.advisor`)\nRETURN count(DISTINCT advisor.s_ID)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "How many departments offer courses?",
        "sql_query": "SELECT count(DISTINCT dept_name) FROM course",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "dept_name"
                        }
                    }
                }
            },
            "from": "course"
        },
        "sql_ans": [
            [
                20
            ]
        ],
        "cypher_query": "MATCH (course:`college_2.course`)\nRETURN count(DISTINCT course.dept_name)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "Count the number of departments which offer courses.",
        "sql_query": "SELECT count(DISTINCT dept_name) FROM course",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "dept_name"
                        }
                    }
                }
            },
            "from": "course"
        },
        "sql_ans": [
            [
                20
            ]
        ],
        "cypher_query": "MATCH (course:`college_2.course`)\nRETURN count(DISTINCT course.dept_name)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "How many different courses offered by Physics department?",
        "sql_query": "SELECT count(DISTINCT course_id) FROM course WHERE dept_name  =  'Physics'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "course_id"
                        }
                    }
                }
            },
            "from": "course",
            "where": {
                "eq": [
                    "dept_name",
                    {
                        "literal": "Physics"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                10
            ]
        ],
        "cypher_query": "MATCH (course:`college_2.course`)\nWHERE course.dept_name = 'Physics'\nRETURN count(DISTINCT course.course_id)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "Count the number of courses in the Physics department.",
        "sql_query": "SELECT count(DISTINCT course_id) FROM course WHERE dept_name  =  'Physics'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "course_id"
                        }
                    }
                }
            },
            "from": "course",
            "where": {
                "eq": [
                    "dept_name",
                    {
                        "literal": "Physics"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                10
            ]
        ],
        "cypher_query": "MATCH (course:`college_2.course`)\nWHERE course.dept_name = 'Physics'\nRETURN count(DISTINCT course.course_id)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "How many courses that do not have prerequisite?",
        "sql_query": "SELECT count(*) FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq)",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "course",
            "where": {
                "nin": [
                    "course_id",
                    {
                        "select": {
                            "value": "course_id"
                        },
                        "from": "prereq"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                121
            ]
        ],
        "cypher_query": "MATCH (course:`college_2.course`)\nWHERE NOT (course:`college_2.course`)-[:`college_2.prereq`]-()\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "Count the number of courses without prerequisites.",
        "sql_query": "SELECT count(*) FROM course WHERE course_id NOT IN (SELECT course_id FROM prereq)",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "course",
            "where": {
                "nin": [
                    "course_id",
                    {
                        "select": {
                            "value": "course_id"
                        },
                        "from": "prereq"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                121
            ]
        ],
        "cypher_query": "MATCH (course:`college_2.course`)\nWHERE NOT (course:`college_2.course`)-[:`college_2.prereq`]-()\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "How many different instructors have taught some course?",
        "sql_query": "SELECT COUNT (DISTINCT id) FROM teaches",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "id"
                        }
                    }
                }
            },
            "from": "teaches"
        },
        "sql_ans": [
            [
                31
            ]
        ],
        "cypher_query": "MATCH (teaches:`college_2.teaches`)\nRETURN count(DISTINCT teaches.ID)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "Count the number of distinct instructors who have taught a course.",
        "sql_query": "SELECT COUNT (DISTINCT id) FROM teaches",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "id"
                        }
                    }
                }
            },
            "from": "teaches"
        },
        "sql_ans": [
            [
                31
            ]
        ],
        "cypher_query": "MATCH (teaches:`college_2.teaches`)\nRETURN count(DISTINCT teaches.ID)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "How many rooms whose capacity is less than 50 does the Lamberton building have?",
        "sql_query": "SELECT count(*) FROM classroom WHERE building  =  'Lamberton' AND capacity  <  50",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "classroom",
            "where": {
                "and": [
                    {
                        "eq": [
                            "building",
                            {
                                "literal": "Lamberton"
                            }
                        ]
                    },
                    {
                        "lt": [
                            "capacity",
                            50
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (classroom:`college_2.classroom`)\nWHERE classroom.building = 'Lamberton' AND classroom.capacity < 50\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "Count the number of rooms in Lamberton with capacity lower than 50.",
        "sql_query": "SELECT count(*) FROM classroom WHERE building  =  'Lamberton' AND capacity  <  50",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "classroom",
            "where": {
                "and": [
                    {
                        "eq": [
                            "building",
                            {
                                "literal": "Lamberton"
                            }
                        ]
                    },
                    {
                        "lt": [
                            "capacity",
                            50
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (classroom:`college_2.classroom`)\nWHERE classroom.building = 'Lamberton' AND classroom.capacity < 50\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "Find the total number of instructors who teach a course in the Spring 2010 semester.",
        "sql_query": "SELECT COUNT (DISTINCT ID) FROM teaches WHERE semester  =  'Spring' AND YEAR  =  2010",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "ID"
                        }
                    }
                }
            },
            "from": "teaches",
            "where": {
                "and": [
                    {
                        "eq": [
                            "semester",
                            {
                                "literal": "Spring"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "YEAR",
                            2010
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (teaches:`college_2.teaches`)\nWHERE teaches.semester = 'Spring' AND teaches.year = 2010\nRETURN count(DISTINCT teaches.ID)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_2",
        "query": "How many instructors teach a course in the Spring of 2010?",
        "sql_query": "SELECT COUNT (DISTINCT ID) FROM teaches WHERE semester  =  'Spring' AND YEAR  =  2010",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "ID"
                        }
                    }
                }
            },
            "from": "teaches",
            "where": {
                "and": [
                    {
                        "eq": [
                            "semester",
                            {
                                "literal": "Spring"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "YEAR",
                            2010
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (teaches:`college_2.teaches`)\nWHERE teaches.semester = 'Spring' AND teaches.year = 2010\nRETURN count(DISTINCT teaches.ID)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "debate",
        "query": "List the names of people that have not been on the affirmative side of debates.",
        "sql_query": "SELECT Name FROM people WHERE People_id NOT IN (SELECT Affirmative FROM debate_people)",
        "parsed_sql": {
            "select": {
                "value": "Name"
            },
            "from": "people",
            "where": {
                "nin": [
                    "People_id",
                    {
                        "select": {
                            "value": "Affirmative"
                        },
                        "from": "debate_people"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Daniel Sickles"
            ],
            [
                "John Cochrane"
            ],
            [
                "George Briggs"
            ],
            [
                "Horace F. Clark"
            ],
            [
                "John B. Haskin"
            ],
            [
                "Charles Van Wyck"
            ]
        ],
        "cypher_query": "MATCH (people:`debate.people`)\nWHERE NOT (people:`debate.people`)-[]-(:`debate.debate_people`)\nRETURN people.Name",
        "cypher_ans": [
            [
                "Luther C. Carter"
            ],
            [
                "James Humphrey"
            ],
            [
                "Daniel Sickles"
            ],
            [
                "Thomas J. Barr"
            ],
            [
                "William B. Maclay"
            ],
            [
                "John Cochrane"
            ],
            [
                "George Briggs"
            ],
            [
                "Horace F. Clark"
            ],
            [
                "John B. Haskin"
            ],
            [
                "Charles Van Wyck"
            ]
        ]
    },
    {
        "db_id": "customers_and_invoices",
        "query": "What is the customer id, first and last name with most number of accounts.",
        "sql_query": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "T1.customer_id"
                },
                {
                    "value": "T2.customer_first_name"
                },
                {
                    "value": "T2.customer_last_name"
                }
            ],
            "from": [
                {
                    "value": "Accounts",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Customers",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.customer_id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.customer_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                13,
                "Kieran",
                "Auer"
            ]
        ],
        "cypher_query": "MATCH (T1:`customers_and_invoices.Accounts`)-[]-(T2:`customers_and_invoices.Customers`)\nWITH T2.customer_last_name AS customer_last_name, T2.customer_first_name AS customer_first_name, count(T1.customer_id) AS count, T1.customer_id AS customer_id\nRETURN customer_id,customer_first_name,customer_last_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                8,
                "Meaghan",
                "Keeling"
            ]
        ]
    },
    {
        "db_id": "customers_and_invoices",
        "query": "Return the id and full name of the customer with the most accounts.",
        "sql_query": "SELECT T1.customer_id ,  T2.customer_first_name ,  T2.customer_last_name FROM Accounts AS T1 JOIN Customers AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "T1.customer_id"
                },
                {
                    "value": "T2.customer_first_name"
                },
                {
                    "value": "T2.customer_last_name"
                }
            ],
            "from": [
                {
                    "value": "Accounts",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Customers",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.customer_id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.customer_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                13,
                "Kieran",
                "Auer"
            ]
        ],
        "cypher_query": "MATCH (T1:`customers_and_invoices.Accounts`)-[]-(T2:`customers_and_invoices.Customers`)\nWITH T2.customer_last_name AS customer_last_name, T2.customer_first_name AS customer_first_name, count(T1.customer_id) AS count, T1.customer_id AS customer_id\nRETURN customer_id,customer_first_name,customer_last_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                8,
                "Meaghan",
                "Keeling"
            ]
        ]
    },
    {
        "db_id": "customers_and_invoices",
        "query": "How many transactions do we have?",
        "sql_query": "SELECT count(*) FROM Financial_transactions",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Financial_transactions"
        },
        "sql_ans": [
            [
                15
            ]
        ],
        "cypher_query": "MATCH (financial_transactions:`customers_and_invoices.Financial_Transactions`)\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "customers_and_invoices",
        "query": "Count the number of transactions.",
        "sql_query": "SELECT count(*) FROM Financial_transactions",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Financial_transactions"
        },
        "sql_ans": [
            [
                15
            ]
        ],
        "cypher_query": "MATCH (financial_transactions:`customers_and_invoices.Financial_Transactions`)\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "customers_and_invoices",
        "query": "How many transaction does account with name 337 have?",
        "sql_query": "SELECT count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id WHERE T2.account_name  =  \"337\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "Financial_transactions",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Accounts",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.account_id",
                            "T2.account_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.account_name",
                    "337"
                ]
            }
        },
        "sql_ans": [
            [
                4
            ]
        ],
        "cypher_query": "MATCH (T1:`customers_and_invoices.Financial_Transactions`)-[]-(T2:`customers_and_invoices.Accounts`)\nWHERE T2.account_name = '337'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "customers_and_invoices",
        "query": "Count the number of financial transactions that the account with the name 337 has.",
        "sql_query": "SELECT count(*) FROM Financial_transactions AS T1 JOIN Accounts AS T2 ON T1.account_id  =  T2.account_id WHERE T2.account_name  =  \"337\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "Financial_transactions",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Accounts",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.account_id",
                            "T2.account_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.account_name",
                    "337"
                ]
            }
        },
        "sql_ans": [
            [
                4
            ]
        ],
        "cypher_query": "MATCH (T1:`customers_and_invoices.Financial_Transactions`)-[]-(T2:`customers_and_invoices.Accounts`)\nWHERE T2.account_name = '337'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "customers_and_invoices",
        "query": "How many products were not included in any order?",
        "sql_query": "SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "products",
            "where": {
                "nin": [
                    "product_id",
                    {
                        "select": {
                            "value": "product_id"
                        },
                        "from": "Order_items"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (products:`customers_and_invoices.Products`)\nWHERE NOT (products:`customers_and_invoices.Products`)-[]-(:`customers_and_invoices.Order_Items`)\nRETURN count(*)",
        "cypher_ans": [
            [
                15
            ]
        ]
    },
    {
        "db_id": "customers_and_invoices",
        "query": "Count the number of products that were never ordered.",
        "sql_query": "SELECT count(*) FROM products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "products",
            "where": {
                "nin": [
                    "product_id",
                    {
                        "select": {
                            "value": "product_id"
                        },
                        "from": "Order_items"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (products:`customers_and_invoices.Products`)\nWHERE NOT (products:`customers_and_invoices.Products`)-[]-(:`customers_and_invoices.Order_Items`)\nRETURN count(*)",
        "cypher_ans": [
            [
                15
            ]
        ]
    },
    {
        "db_id": "wedding",
        "query": "How many weddings are there in year 2016?",
        "sql_query": "SELECT count(*) FROM wedding WHERE YEAR  =  2016",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "wedding",
            "where": {
                "eq": [
                    "YEAR",
                    2016
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (wedding:`wedding.wedding`)\nWHERE wedding.Year = 2016\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "wedding",
        "query": "How many churches have a wedding in year 2016?",
        "sql_query": "SELECT COUNT (DISTINCT church_id) FROM wedding WHERE YEAR  =  2016",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "church_id"
                        }
                    }
                }
            },
            "from": "wedding",
            "where": {
                "eq": [
                    "YEAR",
                    2016
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (wedding:`wedding.wedding`)\nWHERE wedding.Year = 2016\nRETURN count(DISTINCT wedding.Church_ID)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "theme_gallery",
        "query": "Show the average, minimum, and maximum ticket prices for exhibitions for all years before 2009.",
        "sql_query": "SELECT avg(ticket_price) ,  min(ticket_price) ,  max(ticket_price) FROM exhibition WHERE YEAR  <  2009",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "ticket_price"
                    }
                },
                {
                    "value": {
                        "min": "ticket_price"
                    }
                },
                {
                    "value": {
                        "max": "ticket_price"
                    }
                }
            ],
            "from": "exhibition",
            "where": {
                "lt": [
                    "YEAR",
                    2009
                ]
            }
        },
        "sql_ans": [
            [
                20.35,
                14.95,
                29.95
            ]
        ],
        "cypher_query": "MATCH (exhibition:`theme_gallery.exhibition`)\nWHERE exhibition.Year < 2009\nRETURN avg(exhibition.Ticket_Price),min(exhibition.Ticket_Price),max(exhibition.Ticket_Price)",
        "cypher_ans": [
            [
                20.349999999999998,
                14.95,
                29.95
            ]
        ]
    },
    {
        "db_id": "theme_gallery",
        "query": "What are the average, minimum, and maximum ticket prices for exhibitions that happened prior to 2009?",
        "sql_query": "SELECT avg(ticket_price) ,  min(ticket_price) ,  max(ticket_price) FROM exhibition WHERE YEAR  <  2009",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "ticket_price"
                    }
                },
                {
                    "value": {
                        "min": "ticket_price"
                    }
                },
                {
                    "value": {
                        "max": "ticket_price"
                    }
                }
            ],
            "from": "exhibition",
            "where": {
                "lt": [
                    "YEAR",
                    2009
                ]
            }
        },
        "sql_ans": [
            [
                20.35,
                14.95,
                29.95
            ]
        ],
        "cypher_query": "MATCH (exhibition:`theme_gallery.exhibition`)\nWHERE exhibition.Year < 2009\nRETURN avg(exhibition.Ticket_Price),min(exhibition.Ticket_Price),max(exhibition.Ticket_Price)",
        "cypher_ans": [
            [
                20.349999999999998,
                14.95,
                29.95
            ]
        ]
    },
    {
        "db_id": "epinions_1",
        "query": "Find the average and maximum rating of all reviews.",
        "sql_query": "SELECT avg(rating) ,  max(rating) FROM review",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "rating"
                    }
                },
                {
                    "value": {
                        "max": "rating"
                    }
                }
            ],
            "from": "review"
        },
        "sql_ans": [
            [
                7.142857142857143,
                10
            ]
        ],
        "cypher_query": "MATCH (review:`epinions_1.review`)\nRETURN avg(review.rating),max(review.rating)",
        "cypher_ans": [
            [
                7.142857142857142,
                10
            ]
        ]
    },
    {
        "db_id": "epinions_1",
        "query": "Find the number of items that did not receive any review.",
        "sql_query": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "item",
            "where": {
                "nin": [
                    "i_id",
                    {
                        "select": {
                            "value": "i_id"
                        },
                        "from": "review"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (item:`epinions_1.item`)\nWHERE NOT (item:`epinions_1.item`)-[]-(:`epinions_1.review`)\nRETURN count(*)",
        "cypher_ans": [
            [
                8
            ]
        ]
    },
    {
        "db_id": "epinions_1",
        "query": "Find the names of users who did not leave any review.",
        "sql_query": "SELECT name FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)",
        "parsed_sql": {
            "select": {
                "value": "name"
            },
            "from": "useracct",
            "where": {
                "nin": [
                    "u_id",
                    {
                        "select": {
                            "value": "u_id"
                        },
                        "from": "review"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Terry"
            ],
            [
                "Nancy"
            ],
            [
                "Rosie"
            ],
            [
                "Roxi"
            ],
            [
                "Emily"
            ]
        ],
        "cypher_query": "MATCH (useracct:`epinions_1.useracct`)\nWHERE NOT (useracct:`epinions_1.useracct`)-[]-(:`epinions_1.review`)\nRETURN useracct.name",
        "cypher_ans": [
            [
                "Helen"
            ],
            [
                "Mark"
            ],
            [
                "Terry"
            ],
            [
                "Nancy"
            ],
            [
                "Rosie"
            ],
            [
                "Roxi"
            ],
            [
                "Emily"
            ]
        ]
    },
    {
        "db_id": "epinions_1",
        "query": "Find the names of the items that did not receive any review.",
        "sql_query": "SELECT title FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "parsed_sql": {
            "select": {
                "value": "title"
            },
            "from": "item",
            "where": {
                "nin": [
                    "i_id",
                    {
                        "select": {
                            "value": "i_id"
                        },
                        "from": "review"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "pear"
            ],
            [
                "apple"
            ],
            [
                "blue hoodie"
            ]
        ],
        "cypher_query": "MATCH (item:`epinions_1.item`)\nWHERE NOT (item:`epinions_1.item`)-[]-(:`epinions_1.review`)\nRETURN item.title",
        "cypher_ans": [
            [
                "pear"
            ],
            [
                "orange"
            ],
            [
                "apple"
            ],
            [
                "shampoo"
            ],
            [
                "avocado"
            ],
            [
                "comb"
            ],
            [
                "blue hoodie"
            ],
            [
                "cup"
            ]
        ]
    },
    {
        "db_id": "epinions_1",
        "query": "Find the names of users who did not leave any review.",
        "sql_query": "SELECT name FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)",
        "parsed_sql": {
            "select": {
                "value": "name"
            },
            "from": "useracct",
            "where": {
                "nin": [
                    "u_id",
                    {
                        "select": {
                            "value": "u_id"
                        },
                        "from": "review"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Terry"
            ],
            [
                "Nancy"
            ],
            [
                "Rosie"
            ],
            [
                "Roxi"
            ],
            [
                "Emily"
            ]
        ],
        "cypher_query": "MATCH (useracct:`epinions_1.useracct`)\nWHERE NOT (useracct:`epinions_1.useracct`)-[]-(:`epinions_1.review`)\nRETURN useracct.name",
        "cypher_ans": [
            [
                "Helen"
            ],
            [
                "Mark"
            ],
            [
                "Terry"
            ],
            [
                "Nancy"
            ],
            [
                "Rosie"
            ],
            [
                "Roxi"
            ],
            [
                "Emily"
            ]
        ]
    },
    {
        "db_id": "epinions_1",
        "query": "Find the number of users who did not write any review.",
        "sql_query": "SELECT count(*) FROM useracct WHERE u_id NOT IN (SELECT u_id FROM review)",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "useracct",
            "where": {
                "nin": [
                    "u_id",
                    {
                        "select": {
                            "value": "u_id"
                        },
                        "from": "review"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (useracct:`epinions_1.useracct`)\nWHERE NOT (useracct:`epinions_1.useracct`)-[]-(:`epinions_1.review`)\nRETURN count(*)",
        "cypher_ans": [
            [
                7
            ]
        ]
    },
    {
        "db_id": "epinions_1",
        "query": "Find the number of items without any review.",
        "sql_query": "SELECT count(*) FROM item WHERE i_id NOT IN (SELECT i_id FROM review)",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "item",
            "where": {
                "nin": [
                    "i_id",
                    {
                        "select": {
                            "value": "i_id"
                        },
                        "from": "review"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (item:`epinions_1.item`)\nWHERE NOT (item:`epinions_1.item`)-[]-(:`epinions_1.review`)\nRETURN count(*)",
        "cypher_ans": [
            [
                8
            ]
        ]
    },
    {
        "db_id": "riding_club",
        "query": "Please show the most common occupation of players.",
        "sql_query": "SELECT Occupation FROM player GROUP BY Occupation ORDER BY COUNT(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "Occupation"
            },
            "from": "player",
            "groupby": {
                "value": "Occupation"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Student"
            ]
        ],
        "cypher_query": "MATCH (player:`riding_club.player`)\nWITH player.Occupation AS Occupation, count(player.Occupation) AS count\nRETURN Occupation\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Retired"
            ]
        ]
    },
    {
        "db_id": "riding_club",
        "query": "Show the names and genders of players with a coach starting after 2011.",
        "sql_query": "SELECT T3.Player_name ,  T3.gender FROM player_coach AS T1 JOIN coach AS T2 ON T1.Coach_ID  =  T2.Coach_ID JOIN player AS T3 ON T1.Player_ID  =  T3.Player_ID WHERE T1.Starting_year  >  2011",
        "parsed_sql": {
            "select": [
                {
                    "value": "T3.Player_name"
                },
                {
                    "value": "T3.gender"
                }
            ],
            "from": [
                {
                    "value": "player_coach",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "coach",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Coach_ID",
                            "T2.Coach_ID"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "player",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Player_ID",
                            "T3.Player_ID"
                        ]
                    }
                }
            ],
            "where": {
                "gt": [
                    "T1.Starting_year",
                    2011
                ]
            }
        },
        "sql_ans": [
            [
                "Niki Ashton",
                "F"
            ],
            [
                "Ron Strynadka",
                "M"
            ],
            [
                "Ross Eadie",
                "M"
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`riding_club.player_coach`]-(T2:`riding_club.coach`)-[]-(T3:`riding_club.player`)\nWHERE T1.Starting_year > 2011\nRETURN T3.Player_name,T3.Gender",
        "cypher_ans": [
            [
                "Jean Luc Bouch\u00e9",
                "M"
            ],
            [
                "Fiona Shiells",
                "F"
            ],
            [
                "Patricia Cordner",
                "F"
            ]
        ]
    },
    {
        "db_id": "browser_web",
        "query": "What is the maximum, minimum and average market share of the listed browsers?",
        "sql_query": "SELECT max(market_share) ,  min(market_share) ,  avg(market_share) FROM browser",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "market_share"
                    }
                },
                {
                    "value": {
                        "min": "market_share"
                    }
                },
                {
                    "value": {
                        "avg": "market_share"
                    }
                }
            ],
            "from": "browser"
        },
        "sql_ans": [
            [
                28.96,
                1.2,
                14.2025
            ]
        ],
        "cypher_query": "MATCH (browser:`browser_web.browser`)\nRETURN max(browser.market_share),min(browser.market_share),avg(browser.market_share)",
        "cypher_ans": [
            [
                28.96,
                1.2,
                14.202499999999999
            ]
        ]
    },
    {
        "db_id": "browser_web",
        "query": "When did the web accelerator 'CACHEbox' and browser 'Internet Explorer' become compatible?",
        "sql_query": "SELECT T1.compatible_since_year FROM accelerator_compatible_browser AS T1 JOIN browser AS T2 ON T1.browser_id  =  T2.id JOIN web_client_accelerator AS T3 ON T1.accelerator_id  =  T3.id WHERE T3.name  =  'CACHEbox' AND T2.name  =  'Internet Explorer'",
        "parsed_sql": {
            "select": {
                "value": "T1.compatible_since_year"
            },
            "from": [
                {
                    "value": "accelerator_compatible_browser",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "browser",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.browser_id",
                            "T2.id"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "web_client_accelerator",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.accelerator_id",
                            "T3.id"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T3.name",
                            {
                                "literal": "CACHEbox"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "T2.name",
                            {
                                "literal": "Internet Explorer"
                            }
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1995
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`browser_web.accelerator_compatible_browser`]-(T2:`browser_web.browser`)-[]-(T3:`browser_web.Web_client_accelerator`)\nWHERE T3.name = 'CACHEbox' AND T2.name = 'Internet Explorer'\nRETURN T1.compatible_since_year",
        "cypher_ans": [
            [
                2005
            ],
            [
                2010
            ]
        ]
    },
    {
        "db_id": "wrestler",
        "query": "List the names of wrestlers that have not been eliminated.",
        "sql_query": "SELECT Name FROM wrestler WHERE Wrestler_ID NOT IN (SELECT Wrestler_ID FROM elimination)",
        "parsed_sql": {
            "select": {
                "value": "Name"
            },
            "from": "wrestler",
            "where": {
                "nin": [
                    "Wrestler_ID",
                    {
                        "select": {
                            "value": "Wrestler_ID"
                        },
                        "from": "elimination"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Villa\u00f1o IV"
            ],
            [
                "The Great Sasuke \u00a7"
            ],
            [
                "Jushin Liger \u00a7"
            ],
            [
                "Shinjiro Otani \u00a7"
            ]
        ],
        "cypher_query": "MATCH (wrestler:`wrestler.wrestler`)\nWHERE NOT (wrestler:`wrestler.wrestler`)-[]-(:`wrestler.Elimination`)\nRETURN wrestler.Name",
        "cypher_ans": [
            [
                "Rey Misterio Sr."
            ],
            [
                "Fishman"
            ],
            [
                "Villa\u00f1o IV"
            ],
            [
                "Gran Hamada"
            ],
            [
                "El Samurai"
            ],
            [
                "The Great Sasuke \u00a7"
            ],
            [
                "\u00daltimo Drag\u00f3n \u00a7"
            ],
            [
                "Jushin Liger \u00a7"
            ],
            [
                "El Samurai \u00a7"
            ],
            [
                "Shinjiro Otani \u00a7"
            ]
        ]
    },
    {
        "db_id": "wrestler",
        "query": "What are the names of wrestlers who have never been eliminated?",
        "sql_query": "SELECT Name FROM wrestler WHERE Wrestler_ID NOT IN (SELECT Wrestler_ID FROM elimination)",
        "parsed_sql": {
            "select": {
                "value": "Name"
            },
            "from": "wrestler",
            "where": {
                "nin": [
                    "Wrestler_ID",
                    {
                        "select": {
                            "value": "Wrestler_ID"
                        },
                        "from": "elimination"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Villa\u00f1o IV"
            ],
            [
                "The Great Sasuke \u00a7"
            ],
            [
                "Jushin Liger \u00a7"
            ],
            [
                "Shinjiro Otani \u00a7"
            ]
        ],
        "cypher_query": "MATCH (wrestler:`wrestler.wrestler`)\nWHERE NOT (wrestler:`wrestler.wrestler`)-[]-(:`wrestler.Elimination`)\nRETURN wrestler.Name",
        "cypher_ans": [
            [
                "Rey Misterio Sr."
            ],
            [
                "Fishman"
            ],
            [
                "Villa\u00f1o IV"
            ],
            [
                "Gran Hamada"
            ],
            [
                "El Samurai"
            ],
            [
                "The Great Sasuke \u00a7"
            ],
            [
                "\u00daltimo Drag\u00f3n \u00a7"
            ],
            [
                "Jushin Liger \u00a7"
            ],
            [
                "El Samurai \u00a7"
            ],
            [
                "Shinjiro Otani \u00a7"
            ]
        ]
    },
    {
        "db_id": "school_finance",
        "query": "List the names of the schools without any endowment.",
        "sql_query": "SELECT school_name FROM school WHERE school_id NOT IN (SELECT school_id FROM endowment)",
        "parsed_sql": {
            "select": {
                "value": "school_name"
            },
            "from": "school",
            "where": {
                "nin": [
                    "school_id",
                    {
                        "select": {
                            "value": "school_id"
                        },
                        "from": "endowment"
                    }
                ]
            }
        },
        "sql_ans": [],
        "cypher_query": "MATCH (school:`school_finance.School`)\nWHERE NOT (school:`school_finance.School`)-[]-(:`school_finance.endowment`)\nRETURN school.School_name",
        "cypher_ans": [
            [
                "Bremen"
            ],
            [
                "Culver Community"
            ],
            [
                "Glenn"
            ],
            [
                "Jimtown"
            ],
            [
                "Knox Community"
            ],
            [
                "LaVille"
            ],
            [
                "New Prairie 1"
            ],
            [
                "Triton"
            ]
        ]
    },
    {
        "db_id": "protein_institute",
        "query": "How many proteins are associated with an institution in a building with at least 20 floors?",
        "sql_query": "SELECT count(*) FROM institution AS T1 JOIN protein AS T2 ON T1.institution_id  =  T2.institution_id JOIN building AS T3 ON T3.building_id  =  T1.building_id WHERE T3.floors  >=  20",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "institution",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "protein",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.institution_id",
                            "T2.institution_id"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "building",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T3.building_id",
                            "T1.building_id"
                        ]
                    }
                }
            ],
            "where": {
                "gte": [
                    "T3.floors",
                    20
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (T1:`protein_institute.Institution`)-[]-(T3:`protein_institute.building`)-[]-(T1:`protein_institute.Institution`)-[]-(T2:`protein_institute.protein`)\nWHERE T3.Floors >= 20\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "cinema",
        "query": "Show cinema name, film title, date, and price for each record in schedule.",
        "sql_query": "SELECT T3.name ,  T2.title ,  T1.date ,  T1.price FROM schedule AS T1 JOIN film AS T2 ON T1.film_id  =  T2.film_id JOIN cinema AS T3 ON T1.cinema_id  =  T3.cinema_id",
        "parsed_sql": {
            "select": [
                {
                    "value": "T3.name"
                },
                {
                    "value": "T2.title"
                },
                {
                    "value": "T1.date"
                },
                {
                    "value": "T1.price"
                }
            ],
            "from": [
                {
                    "value": "schedule",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "film",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.film_id",
                            "T2.film_id"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "cinema",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.cinema_id",
                            "T3.cinema_id"
                        ]
                    }
                }
            ]
        },
        "sql_ans": [
            [
                "Codling",
                "The Case of the Mystery Weekend",
                "21 May",
                12.99
            ],
            [
                "Codling",
                "The Case of the Smart Dummy",
                "21 May",
                12.99
            ],
            [
                "Codling",
                "The Case: Off the Record",
                "21 Jun",
                8.99
            ],
            [
                "Carrowleagh",
                "The Case of the Mystery Weekend",
                "11 July",
                9.99
            ],
            [
                "Gortahile",
                "The Case of the Piggy Banker",
                "2 Aug",
                12.99
            ],
            [
                "Mount Callan",
                "The Case of the Bermuda Triangle",
                "20 May",
                9.99
            ],
            [
                "Oriel",
                "The Case of the Mystery Weekend",
                "19 May",
                15.99
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`cinema.schedule`]-(T2:`cinema.film`)-[]-(T3:`cinema.cinema`)\nRETURN T3.Name,T2.Title,T1.Date,T1.Price",
        "cypher_ans": [
            [
                "Oriel",
                "The Case of the Mystery Weekend",
                "11 July",
                9.99
            ],
            [
                "Codling",
                "The Case of the Mystery Weekend",
                "11 July",
                9.99
            ],
            [
                "Carrowleagh",
                "The Case of the Mystery Weekend",
                "19 May",
                15.99
            ],
            [
                "Codling",
                "The Case of the Mystery Weekend",
                "19 May",
                15.99
            ],
            [
                "Carrowleagh",
                "The Case of the Mystery Weekend",
                "21 May",
                12.99
            ],
            [
                "Oriel",
                "The Case of the Mystery Weekend",
                "21 May",
                12.99
            ]
        ]
    },
    {
        "db_id": "cinema",
        "query": "How many films have the word 'Dummy' in their titles?",
        "sql_query": "SELECT count(*) FROM film WHERE title LIKE \"%Dummy%\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "film",
            "where": {
                "like": [
                    "title",
                    "%Dummy%"
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (film:`cinema.film`)\nWHERE film.Title =~'.*[\"|\"]%Dummy%\".*'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "cinema",
        "query": "Count the number of films whose title contains the word 'Dummy'.",
        "sql_query": "SELECT count(*) FROM film WHERE title LIKE \"%Dummy%\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "film",
            "where": {
                "like": [
                    "title",
                    "%Dummy%"
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (film:`cinema.film`)\nWHERE film.Title =~'.*[\"|\"]%Dummy%\".*'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "products_for_hire",
        "query": "What is the average amount due for all the payments?",
        "sql_query": "SELECT avg(amount_due) FROM payments",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "amount_due"
                }
            },
            "from": "payments"
        },
        "sql_ans": [
            [
                564.3860000000001
            ]
        ],
        "cypher_query": "MATCH (payments:`products_for_hire.Payments`)\nRETURN avg(payments.amount_due)",
        "cypher_ans": [
            [
                564.3859999999999
            ]
        ]
    },
    {
        "db_id": "products_for_hire",
        "query": "What are the maximum, minimum, and average booked count for the products booked?",
        "sql_query": "SELECT max(booked_count) ,  min(booked_count) ,  avg(booked_count) FROM products_booked",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "booked_count"
                    }
                },
                {
                    "value": {
                        "min": "booked_count"
                    }
                },
                {
                    "value": {
                        "avg": "booked_count"
                    }
                }
            ],
            "from": "products_booked"
        },
        "sql_ans": [
            [
                9,
                1,
                4.0
            ]
        ],
        "cypher_query": "MATCH ()-[products_booked:`products_for_hire.Products_Booked`]-()\nRETURN max(products_booked.booked_count),min(products_booked.booked_count),avg(products_booked.booked_count)",
        "cypher_ans": [
            [
                9,
                1,
                4.000000000000001
            ]
        ]
    },
    {
        "db_id": "products_for_hire",
        "query": "How many products are never booked with amount higher than 200?",
        "sql_query": "SELECT count(*) FROM Products_for_hire WHERE product_id NOT IN ( SELECT product_id FROM products_booked WHERE booked_amount  >  200 )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Products_for_hire",
            "where": {
                "nin": [
                    "product_id",
                    {
                        "select": {
                            "value": "product_id"
                        },
                        "from": "products_booked",
                        "where": {
                            "gt": [
                                "booked_amount",
                                200
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (products_for_hire:`products_for_hire.Products_for_Hire`)\nWHERE NOT (products_for_hire:`products_for_hire.Products_for_Hire`)-[:`products_for_hire.Products_Booked { booked_amount : 200 }`]-()\nRETURN count(*)",
        "cypher_ans": [
            [
                5
            ]
        ]
    },
    {
        "db_id": "phone_market",
        "query": "List the names of phones that are not on any market.",
        "sql_query": "SELECT Name FROM phone WHERE Phone_id NOT IN (SELECT Phone_ID FROM phone_market)",
        "parsed_sql": {
            "select": {
                "value": "Name"
            },
            "from": "phone",
            "where": {
                "nin": [
                    "Phone_id",
                    {
                        "select": {
                            "value": "Phone_ID"
                        },
                        "from": "phone_market"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "IPhone 6"
            ]
        ],
        "cypher_query": "MATCH (phone:`phone_market.phone`)\nWHERE NOT (phone:`phone_market.phone`)-[:`phone_market.phone_market`]-()\nRETURN phone.Name",
        "cypher_ans": [
            [
                "IPhone 5s"
            ],
            [
                "IPhone 6"
            ],
            [
                "IPhone 6s"
            ],
            [
                "IPhone 7"
            ],
            [
                "IPhone X"
            ]
        ]
    },
    {
        "db_id": "gas_company",
        "query": "Show the company name with the number of gas station.",
        "sql_query": "SELECT T2.company ,  count(*) FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id GROUP BY T1.company_id",
        "parsed_sql": {
            "select": [
                {
                    "value": "T2.company"
                },
                {
                    "value": {
                        "count": "*"
                    }
                }
            ],
            "from": [
                {
                    "value": "station_company",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "company",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.company_id",
                            "T2.company_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.company_id"
            }
        },
        "sql_ans": [
            [
                "ExxonMobil",
                2
            ],
            [
                "Royal Dutch Shell",
                1
            ],
            [
                "PetroChina",
                1
            ],
            [
                "Petrobras",
                1
            ],
            [
                "BP",
                1
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`gas_company.station_company`]-(T2:`gas_company.company`)\nWITH T2.Company AS Company, count(T1.Company_ID) AS count\nRETURN Company,count",
        "cypher_ans": [
            [
                "ExxonMobil",
                0
            ],
            [
                "Royal Dutch Shell",
                0
            ],
            [
                "PetroChina",
                0
            ],
            [
                "Petrobras",
                0
            ],
            [
                "BP",
                0
            ]
        ]
    },
    {
        "db_id": "gas_company",
        "query": "For each company id, what are the companies and how many gas stations does each one operate?",
        "sql_query": "SELECT T2.company ,  count(*) FROM station_company AS T1 JOIN company AS T2 ON T1.company_id  =  T2.company_id GROUP BY T1.company_id",
        "parsed_sql": {
            "select": [
                {
                    "value": "T2.company"
                },
                {
                    "value": {
                        "count": "*"
                    }
                }
            ],
            "from": [
                {
                    "value": "station_company",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "company",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.company_id",
                            "T2.company_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.company_id"
            }
        },
        "sql_ans": [
            [
                "ExxonMobil",
                2
            ],
            [
                "Royal Dutch Shell",
                1
            ],
            [
                "PetroChina",
                1
            ],
            [
                "Petrobras",
                1
            ],
            [
                "BP",
                1
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`gas_company.station_company`]-(T2:`gas_company.company`)\nWITH T2.Company AS Company, count(T1.Company_ID) AS count\nRETURN Company,count",
        "cypher_ans": [
            [
                "ExxonMobil",
                0
            ],
            [
                "Royal Dutch Shell",
                0
            ],
            [
                "PetroChina",
                0
            ],
            [
                "Petrobras",
                0
            ],
            [
                "BP",
                0
            ]
        ]
    },
    {
        "db_id": "party_people",
        "query": "Show names of parties that does not have any members.",
        "sql_query": "SELECT party_name FROM party WHERE party_id NOT IN (SELECT party_id FROM Member)",
        "parsed_sql": {
            "select": {
                "value": "party_name"
            },
            "from": "party",
            "where": {
                "nin": [
                    "party_id",
                    {
                        "select": {
                            "value": "party_id"
                        },
                        "from": "Member"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Convention Union Party"
            ],
            [
                "Sinefine Party"
            ]
        ],
        "cypher_query": "MATCH (party:`party_people.party`)\nWHERE NOT (party:`party_people.party`)-[]-(:`party_people.member`)\nRETURN party.Party_name",
        "cypher_ans": [
            [
                "Convention Peoples Party"
            ],
            [
                "Progress Party"
            ],
            [
                "3"
            ],
            [
                "Convention Union Party"
            ],
            [
                "Sinefine Party"
            ]
        ]
    },
    {
        "db_id": "party_people",
        "query": "What are the names of parties that have no members?",
        "sql_query": "SELECT party_name FROM party WHERE party_id NOT IN (SELECT party_id FROM Member)",
        "parsed_sql": {
            "select": {
                "value": "party_name"
            },
            "from": "party",
            "where": {
                "nin": [
                    "party_id",
                    {
                        "select": {
                            "value": "party_id"
                        },
                        "from": "Member"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Convention Union Party"
            ],
            [
                "Sinefine Party"
            ]
        ],
        "cypher_query": "MATCH (party:`party_people.party`)\nWHERE NOT (party:`party_people.party`)-[]-(:`party_people.member`)\nRETURN party.Party_name",
        "cypher_ans": [
            [
                "Convention Peoples Party"
            ],
            [
                "Progress Party"
            ],
            [
                "3"
            ],
            [
                "Convention Union Party"
            ],
            [
                "Sinefine Party"
            ]
        ]
    },
    {
        "db_id": "cre_Doc_Control_Systems",
        "query": "How many draft copies does the document with id 2 have?",
        "sql_query": "SELECT count(*) FROM Draft_Copies WHERE document_id = 2;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Draft_Copies",
            "where": {
                "eq": [
                    "document_id",
                    2
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH ()-[draft_copies:`cre_Doc_Control_Systems.Draft_Copies`]-()\nWHERE draft_copies.document_id = 2\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "local_govt_in_alabama",
        "query": "What is the id of the event with the most participants?",
        "sql_query": "SELECT Event_ID FROM Participants_in_Events GROUP BY Event_ID ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "Event_ID"
            },
            "from": "Participants_in_Events",
            "groupby": {
                "value": "Event_ID"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                80
            ]
        ],
        "cypher_query": "MATCH ()-[participants_in_events:`local_govt_in_alabama.Participants_in_Events`]-()\nWITH count(participants_in_events.Event_ID) AS count, participants_in_events.Event_ID AS Event_ID\nRETURN Event_ID\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "local_govt_in_alabama",
        "query": "What are all the distinct participant ids who attended any events?",
        "sql_query": "SELECT count(DISTINCT participant_id) FROM participants_in_Events",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "participant_id"
                        }
                    }
                }
            },
            "from": "participants_in_Events"
        },
        "sql_ans": [
            [
                10
            ]
        ],
        "cypher_query": "MATCH ()-[participants_in_events:`local_govt_in_alabama.Participants_in_Events`]-()\nRETURN count(DISTINCT participants_in_events.Participant_ID)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "formula_1",
        "query": "How many drivers participated in the race Australian Grand Prix held in 2009?",
        "sql_query": "SELECT count(*) FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid WHERE T2.name = \"Australian Grand Prix\" AND YEAR = 2009",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "results",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "races",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.raceid",
                            "T2.raceid"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T2.name",
                            "Australian Grand Prix"
                        ]
                    },
                    {
                        "eq": [
                            "YEAR",
                            2009
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                20
            ]
        ],
        "cypher_query": "MATCH (T1:`formula_1.results`)-[]-(T2:`formula_1.races`)\nWHERE T2.name = 'Australian Grand Prix' AND T2.year = 2009\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "formula_1",
        "query": "How many drivers were in the Australian Grand Prix held in 2009?",
        "sql_query": "SELECT count(*) FROM results AS T1 JOIN races AS T2 ON T1.raceid = T2.raceid WHERE T2.name = \"Australian Grand Prix\" AND YEAR = 2009",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "results",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "races",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.raceid",
                            "T2.raceid"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T2.name",
                            "Australian Grand Prix"
                        ]
                    },
                    {
                        "eq": [
                            "YEAR",
                            2009
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                20
            ]
        ],
        "cypher_query": "MATCH (T1:`formula_1.results`)-[]-(T2:`formula_1.races`)\nWHERE T2.name = 'Australian Grand Prix' AND T2.year = 2009\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "formula_1",
        "query": "How many drivers did not participate in the races held in 2009?",
        "sql_query": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "driverId"
                        }
                    }
                }
            },
            "from": "results",
            "where": {
                "nin": [
                    "raceId",
                    {
                        "select": {
                            "value": "raceId"
                        },
                        "from": "races",
                        "where": {
                            "neq": [
                                "YEAR",
                                2009
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                25
            ]
        ],
        "cypher_query": "MATCH (results:`formula_1.results`)\nWHERE NOT (results:`formula_1.results`)-[]-(:`formula_1.races { year :> 2009 }`)\nRETURN count(DISTINCT results.driverId)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "formula_1",
        "query": "How many drivers did not race in 2009?",
        "sql_query": "SELECT count(DISTINCT driverId) FROM results WHERE raceId NOT IN( SELECT raceId FROM races WHERE YEAR != 2009 )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "driverId"
                        }
                    }
                }
            },
            "from": "results",
            "where": {
                "nin": [
                    "raceId",
                    {
                        "select": {
                            "value": "raceId"
                        },
                        "from": "races",
                        "where": {
                            "neq": [
                                "YEAR",
                                2009
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                25
            ]
        ],
        "cypher_query": "MATCH (results:`formula_1.results`)\nWHERE NOT (results:`formula_1.results`)-[]-(:`formula_1.races { year :> 2009 }`)\nRETURN count(DISTINCT results.driverId)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "formula_1",
        "query": "What is the average fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?",
        "sql_query": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T2.fastestlapspeed"
                }
            },
            "from": [
                {
                    "value": "races",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "results",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.raceid",
                            "T2.raceid"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.year",
                            2008
                        ]
                    },
                    {
                        "eq": [
                            "T1.name",
                            "Monaco Grand Prix"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                146.49920000000003
            ]
        ],
        "cypher_query": "MATCH (T1:`formula_1.races`)-[]-(T2:`formula_1.results`)\nWHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'\nRETURN avg(T2.fastestLapSpeed)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "formula_1",
        "query": "What is the average fastest lap speed for the Monaco Grand Prix in 2008?",
        "sql_query": "SELECT avg(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T2.fastestlapspeed"
                }
            },
            "from": [
                {
                    "value": "races",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "results",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.raceid",
                            "T2.raceid"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.year",
                            2008
                        ]
                    },
                    {
                        "eq": [
                            "T1.name",
                            "Monaco Grand Prix"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                146.49920000000003
            ]
        ],
        "cypher_query": "MATCH (T1:`formula_1.races`)-[]-(T2:`formula_1.results`)\nWHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'\nRETURN avg(T2.fastestLapSpeed)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "formula_1",
        "query": "What is the maximum fastest lap speed in race named 'Monaco Grand Prix' in 2008 ?",
        "sql_query": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "max": "T2.fastestlapspeed"
                }
            },
            "from": [
                {
                    "value": "races",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "results",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.raceid",
                            "T2.raceid"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.year",
                            2008
                        ]
                    },
                    {
                        "eq": [
                            "T1.name",
                            "Monaco Grand Prix"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "156.789"
            ]
        ],
        "cypher_query": "MATCH (T1:`formula_1.races`)-[]-(T2:`formula_1.results`)\nWHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'\nRETURN max(T2.fastestLapSpeed)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "formula_1",
        "query": "What is the maximum fastest lap speed in the Monaco Grand Prix in 2008?",
        "sql_query": "SELECT max(T2.fastestlapspeed) FROM races AS T1 JOIN results AS T2 ON T1.raceid = T2.raceid WHERE T1.year = 2008 AND T1.name = \"Monaco Grand Prix\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "max": "T2.fastestlapspeed"
                }
            },
            "from": [
                {
                    "value": "races",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "results",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.raceid",
                            "T2.raceid"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.year",
                            2008
                        ]
                    },
                    {
                        "eq": [
                            "T1.name",
                            "Monaco Grand Prix"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "156.789"
            ]
        ],
        "cypher_query": "MATCH (T1:`formula_1.races`)-[]-(T2:`formula_1.results`)\nWHERE T1.year = 2008 AND T1.name = 'Monaco Grand Prix'\nRETURN max(T2.fastestLapSpeed)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "csu_1",
        "query": "Find the average fee on a CSU campus in 1996",
        "sql_query": "SELECT avg(campusfee) FROM csu_fees WHERE YEAR  =  1996",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "campusfee"
                }
            },
            "from": "csu_fees",
            "where": {
                "eq": [
                    "YEAR",
                    1996
                ]
            }
        },
        "sql_ans": [
            [
                1936.090909090909
            ]
        ],
        "cypher_query": "MATCH (csu_fees:`csu_1.csu_fees`)\nWHERE csu_fees.Year = 1996\nRETURN avg(csu_fees.CampusFee)",
        "cypher_ans": [
            [
                1936.0909090909092
            ]
        ]
    },
    {
        "db_id": "csu_1",
        "query": "What is the average fee for a CSU campus in the year of 1996?",
        "sql_query": "SELECT avg(campusfee) FROM csu_fees WHERE YEAR  =  1996",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "campusfee"
                }
            },
            "from": "csu_fees",
            "where": {
                "eq": [
                    "YEAR",
                    1996
                ]
            }
        },
        "sql_ans": [
            [
                1936.090909090909
            ]
        ],
        "cypher_query": "MATCH (csu_fees:`csu_1.csu_fees`)\nWHERE csu_fees.Year = 1996\nRETURN avg(csu_fees.CampusFee)",
        "cypher_ans": [
            [
                1936.0909090909092
            ]
        ]
    },
    {
        "db_id": "movie_1",
        "query": "What is the total number of ratings that has more than 3 stars?",
        "sql_query": "SELECT count(*) FROM Rating WHERE stars  >  3",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Rating",
            "where": {
                "gt": [
                    "stars",
                    3
                ]
            }
        },
        "sql_ans": [
            [
                6
            ]
        ],
        "cypher_query": "MATCH (rating:`movie_1.Rating`)\nWHERE rating.stars > 3\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "movie_1",
        "query": "How many movie ratings have more than 3 stars?",
        "sql_query": "SELECT count(*) FROM Rating WHERE stars  >  3",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Rating",
            "where": {
                "gt": [
                    "stars",
                    3
                ]
            }
        },
        "sql_ans": [
            [
                6
            ]
        ],
        "cypher_query": "MATCH (rating:`movie_1.Rating`)\nWHERE rating.stars > 3\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "movie_1",
        "query": "What is the lowest and highest rating star?",
        "sql_query": "SELECT max(stars) ,  min(stars) FROM Rating",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "stars"
                    }
                },
                {
                    "value": {
                        "min": "stars"
                    }
                }
            ],
            "from": "Rating"
        },
        "sql_ans": [
            [
                5,
                2
            ]
        ],
        "cypher_query": "MATCH (rating:`movie_1.Rating`)\nRETURN max(rating.stars),min(rating.stars)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "movie_1",
        "query": "What is the maximum and mininum number of stars a rating can receive?",
        "sql_query": "SELECT max(stars) ,  min(stars) FROM Rating",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "stars"
                    }
                },
                {
                    "value": {
                        "min": "stars"
                    }
                }
            ],
            "from": "Rating"
        },
        "sql_ans": [
            [
                5,
                2
            ]
        ],
        "cypher_query": "MATCH (rating:`movie_1.Rating`)\nRETURN max(rating.stars),min(rating.stars)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "movie_1",
        "query": "Find the titles of all movies that have no ratings.",
        "sql_query": "SELECT title FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating)",
        "parsed_sql": {
            "select": {
                "value": "title"
            },
            "from": "Movie",
            "where": {
                "nin": [
                    "mID",
                    {
                        "select": {
                            "value": "mID"
                        },
                        "from": "Rating"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Star Wars"
            ],
            [
                "Titanic"
            ]
        ],
        "cypher_query": "MATCH (movie:`movie_1.Movie`)\nWHERE NOT (movie:`movie_1.Movie`)-[]-(:`movie_1.Rating`)\nRETURN movie.title",
        "cypher_ans": [
            [
                "Gone with the Wind"
            ],
            [
                "Star Wars"
            ],
            [
                "The Sound of Music"
            ],
            [
                "E.T."
            ],
            [
                "Titanic"
            ],
            [
                "Snow White"
            ],
            [
                "Avatar"
            ],
            [
                "Raiders of the Lost Ark"
            ]
        ]
    },
    {
        "db_id": "movie_1",
        "query": "What are the titles of all movies that have not been rated?",
        "sql_query": "SELECT title FROM Movie WHERE mID NOT IN (SELECT mID FROM Rating)",
        "parsed_sql": {
            "select": {
                "value": "title"
            },
            "from": "Movie",
            "where": {
                "nin": [
                    "mID",
                    {
                        "select": {
                            "value": "mID"
                        },
                        "from": "Rating"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Star Wars"
            ],
            [
                "Titanic"
            ]
        ],
        "cypher_query": "MATCH (movie:`movie_1.Movie`)\nWHERE NOT (movie:`movie_1.Movie`)-[]-(:`movie_1.Rating`)\nRETURN movie.title",
        "cypher_ans": [
            [
                "Gone with the Wind"
            ],
            [
                "Star Wars"
            ],
            [
                "The Sound of Music"
            ],
            [
                "E.T."
            ],
            [
                "Titanic"
            ],
            [
                "Snow White"
            ],
            [
                "Avatar"
            ],
            [
                "Raiders of the Lost Ark"
            ]
        ]
    },
    {
        "db_id": "inn_1",
        "query": "What is the average base price of different bed type? List bed type and average base price.",
        "sql_query": "SELECT bedType ,  avg(basePrice) FROM Rooms GROUP BY bedType;",
        "parsed_sql": {
            "select": [
                {
                    "value": "bedType"
                },
                {
                    "value": {
                        "avg": "basePrice"
                    }
                }
            ],
            "from": "Rooms",
            "groupby": {
                "value": "bedType"
            }
        },
        "sql_ans": [
            [
                "Double",
                100.0
            ],
            [
                "King",
                181.25
            ],
            [
                "Queen",
                150.0
            ]
        ],
        "cypher_query": "MATCH (rooms:`inn_1.Rooms`)\nWITH count(rooms.bedType) AS count, rooms.bedType AS bedType\nRETURN bedType,count",
        "cypher_ans": [
            [
                "King",
                4
            ],
            [
                "Queen",
                4
            ],
            [
                "Double",
                2
            ]
        ]
    },
    {
        "db_id": "inn_1",
        "query": "For each bed type, find the average base price of different bed type.",
        "sql_query": "SELECT bedType ,  avg(basePrice) FROM Rooms GROUP BY bedType;",
        "parsed_sql": {
            "select": [
                {
                    "value": "bedType"
                },
                {
                    "value": {
                        "avg": "basePrice"
                    }
                }
            ],
            "from": "Rooms",
            "groupby": {
                "value": "bedType"
            }
        },
        "sql_ans": [
            [
                "Double",
                100.0
            ],
            [
                "King",
                181.25
            ],
            [
                "Queen",
                150.0
            ]
        ],
        "cypher_query": "MATCH (rooms:`inn_1.Rooms`)\nWITH count(rooms.bedType) AS count, rooms.bedType AS bedType\nRETURN bedType,count",
        "cypher_ans": [
            [
                "King",
                4
            ],
            [
                "Queen",
                4
            ],
            [
                "Double",
                2
            ]
        ]
    },
    {
        "db_id": "inn_1",
        "query": "For each bed type, find the average room price.",
        "sql_query": "SELECT bedType ,  avg(basePrice) FROM Rooms GROUP BY bedType;",
        "parsed_sql": {
            "select": [
                {
                    "value": "bedType"
                },
                {
                    "value": {
                        "avg": "basePrice"
                    }
                }
            ],
            "from": "Rooms",
            "groupby": {
                "value": "bedType"
            }
        },
        "sql_ans": [
            [
                "Double",
                100.0
            ],
            [
                "King",
                181.25
            ],
            [
                "Queen",
                150.0
            ]
        ],
        "cypher_query": "MATCH (rooms:`inn_1.Rooms`)\nWITH count(rooms.bedType) AS count, rooms.bedType AS bedType\nRETURN bedType,count",
        "cypher_ans": [
            [
                "King",
                4
            ],
            [
                "Queen",
                4
            ],
            [
                "Double",
                2
            ]
        ]
    },
    {
        "db_id": "inn_1",
        "query": "What is the average base price of rooms, for each bed type?",
        "sql_query": "SELECT bedType ,  avg(basePrice) FROM Rooms GROUP BY bedType;",
        "parsed_sql": {
            "select": [
                {
                    "value": "bedType"
                },
                {
                    "value": {
                        "avg": "basePrice"
                    }
                }
            ],
            "from": "Rooms",
            "groupby": {
                "value": "bedType"
            }
        },
        "sql_ans": [
            [
                "Double",
                100.0
            ],
            [
                "King",
                181.25
            ],
            [
                "Queen",
                150.0
            ]
        ],
        "cypher_query": "MATCH (rooms:`inn_1.Rooms`)\nWITH count(rooms.bedType) AS count, rooms.bedType AS bedType\nRETURN bedType,count",
        "cypher_ans": [
            [
                "King",
                4
            ],
            [
                "Queen",
                4
            ],
            [
                "Double",
                2
            ]
        ]
    },
    {
        "db_id": "storm_record",
        "query": "How many regions are affected?",
        "sql_query": "SELECT count(DISTINCT region_id) FROM affected_region",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "region_id"
                        }
                    }
                }
            },
            "from": "affected_region"
        },
        "sql_ans": [
            [
                4
            ]
        ],
        "cypher_query": "MATCH ()-[affected_region:`storm_record.affected_region`]-()\nRETURN count(DISTINCT affected_region.Region_id)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "storm_record",
        "query": "Count the number of different affected regions.",
        "sql_query": "SELECT count(DISTINCT region_id) FROM affected_region",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "region_id"
                        }
                    }
                }
            },
            "from": "affected_region"
        },
        "sql_ans": [
            [
                4
            ]
        ],
        "cypher_query": "MATCH ()-[affected_region:`storm_record.affected_region`]-()\nRETURN count(DISTINCT affected_region.Region_id)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "storm_record",
        "query": "What is the storm name and max speed which affected the greatest number of regions?",
        "sql_query": "SELECT T1.name ,  T1.max_speed FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "T1.name"
                },
                {
                    "value": "T1.max_speed"
                }
            ],
            "from": [
                {
                    "value": "storm",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "affected_region",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.storm_id",
                            "T2.storm_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.storm_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Five",
                988
            ]
        ],
        "cypher_query": "MATCH (T1:`storm_record.storm`)-[T2:`storm_record.affected_region`]-()\nWITH count(T1.Storm_ID) AS count, T1.Max_speed AS Max_speed, T1.Name AS Name\nRETURN Name,Max_speed\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "One",
                995
            ]
        ]
    },
    {
        "db_id": "storm_record",
        "query": "Return the name and max speed of the storm that affected the most regions.",
        "sql_query": "SELECT T1.name ,  T1.max_speed FROM storm AS T1 JOIN affected_region AS T2 ON T1.storm_id  =  T2.storm_id GROUP BY T1.storm_id ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "T1.name"
                },
                {
                    "value": "T1.max_speed"
                }
            ],
            "from": [
                {
                    "value": "storm",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "affected_region",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.storm_id",
                            "T2.storm_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.storm_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Five",
                988
            ]
        ],
        "cypher_query": "MATCH (T1:`storm_record.storm`)-[T2:`storm_record.affected_region`]-()\nWITH count(T1.Storm_ID) AS count, T1.Max_speed AS Max_speed, T1.Name AS Name\nRETURN Name,Max_speed\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "One",
                995
            ]
        ]
    },
    {
        "db_id": "storm_record",
        "query": "Find the names of the regions which were affected by the storm that killed the greatest number of people.",
        "sql_query": "SELECT T2.region_name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id ORDER BY T3.Number_Deaths DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T2.region_name"
            },
            "from": [
                {
                    "value": "affected_region",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "region",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.region_id",
                            "T2.region_id"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "storm",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.storm_id",
                            "T3.storm_id"
                        ]
                    }
                }
            ],
            "orderby": {
                "value": "T3.Number_Deaths",
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Algeria"
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`storm_record.affected_region`]-(T2:`storm_record.region`)-[]-(T3:`storm_record.storm`)\nRETURN T2.Region_name\nORDER BY T3.Number_Deaths DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Afghanistan"
            ]
        ]
    },
    {
        "db_id": "storm_record",
        "query": "What are the names of regions that were affected by the storm in which the most people died?",
        "sql_query": "SELECT T2.region_name FROM affected_region AS T1 JOIN region AS T2 ON T1.region_id  =  T2.region_id JOIN storm AS T3 ON T1.storm_id  =  T3.storm_id ORDER BY T3.Number_Deaths DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T2.region_name"
            },
            "from": [
                {
                    "value": "affected_region",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "region",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.region_id",
                            "T2.region_id"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "storm",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.storm_id",
                            "T3.storm_id"
                        ]
                    }
                }
            ],
            "orderby": {
                "value": "T3.Number_Deaths",
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Algeria"
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`storm_record.affected_region`]-(T2:`storm_record.region`)-[]-(T3:`storm_record.storm`)\nRETURN T2.Region_name\nORDER BY T3.Number_Deaths DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Afghanistan"
            ]
        ]
    },
    {
        "db_id": "election",
        "query": "What are the names of parties that do not have delegates in election?",
        "sql_query": "SELECT Party FROM party WHERE Party_ID NOT IN (SELECT Party FROM election)",
        "parsed_sql": {
            "select": {
                "value": "Party"
            },
            "from": "party",
            "where": {
                "nin": [
                    "Party_ID",
                    {
                        "select": {
                            "value": "Party"
                        },
                        "from": "election"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Democratic"
            ],
            [
                "Independence"
            ]
        ],
        "cypher_query": "MATCH (party:`election.party`)\nWHERE NOT (party:`election.party`)-[]-(:`election.election`)\nRETURN party.Party",
        "cypher_ans": [
            [
                "Democratic"
            ],
            [
                "Liberal"
            ],
            [
                "Democratic"
            ],
            [
                "Independence"
            ],
            [
                "Democratic"
            ],
            [
                "Independence"
            ],
            [
                "Working Families"
            ]
        ]
    },
    {
        "db_id": "election",
        "query": "Which parties did not have any delegates in elections?",
        "sql_query": "SELECT Party FROM party WHERE Party_ID NOT IN (SELECT Party FROM election)",
        "parsed_sql": {
            "select": {
                "value": "Party"
            },
            "from": "party",
            "where": {
                "nin": [
                    "Party_ID",
                    {
                        "select": {
                            "value": "Party"
                        },
                        "from": "election"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Democratic"
            ],
            [
                "Independence"
            ]
        ],
        "cypher_query": "MATCH (party:`election.party`)\nWHERE NOT (party:`election.party`)-[]-(:`election.election`)\nRETURN party.Party",
        "cypher_ans": [
            [
                "Democratic"
            ],
            [
                "Liberal"
            ],
            [
                "Democratic"
            ],
            [
                "Independence"
            ],
            [
                "Democratic"
            ],
            [
                "Independence"
            ],
            [
                "Working Families"
            ]
        ]
    },
    {
        "db_id": "news_report",
        "query": "What is the average number of years spent working as a journalist?",
        "sql_query": "SELECT avg(Years_working) FROM journalist",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "Years_working"
                }
            },
            "from": "journalist"
        },
        "sql_ans": [
            [
                8.0
            ]
        ],
        "cypher_query": "MATCH (journalist:`news_report.journalist`)\nRETURN avg(journalist.Years_working)",
        "cypher_ans": [
            [
                7.999999999999999
            ]
        ]
    },
    {
        "db_id": "news_report",
        "query": "Show the names of journalists and the number of events they reported.",
        "sql_query": "SELECT T3.Name ,  COUNT(*) FROM news_report AS T1 JOIN event AS T2 ON T1.Event_ID  =  T2.Event_ID JOIN journalist AS T3 ON T1.journalist_ID  =  T3.journalist_ID GROUP BY T3.Name",
        "parsed_sql": {
            "select": [
                {
                    "value": "T3.Name"
                },
                {
                    "value": {
                        "count": "*"
                    }
                }
            ],
            "from": [
                {
                    "value": "news_report",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "event",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Event_ID",
                            "T2.Event_ID"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "journalist",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.journalist_ID",
                            "T3.journalist_ID"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T3.Name"
            }
        },
        "sql_ans": [
            [
                "Herbert Swindells",
                1
            ],
            [
                "Jackie Waring",
                2
            ],
            [
                "John Meaney",
                1
            ],
            [
                "Ray Ferris",
                1
            ],
            [
                "Tom Briggs",
                1
            ],
            [
                "Tony Waddington",
                1
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`news_report.news_report`]-(T2:`news_report.event`)-[]-(T3:`news_report.journalist`)\nWITH T3.Name AS Name, count(T3.Name) AS count\nRETURN Name,count",
        "cypher_ans": [
            [
                "Jackie Waring",
                1
            ],
            [
                "Ray Ferris",
                1
            ],
            [
                "John Meaney",
                1
            ],
            [
                "Tom Briggs",
                1
            ]
        ]
    },
    {
        "db_id": "sakila_1",
        "query": "How many different last names do the actors and actresses have?",
        "sql_query": "SELECT count(DISTINCT last_name) FROM actor",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "last_name"
                        }
                    }
                }
            },
            "from": "actor"
        },
        "sql_ans": [
            [
                121
            ]
        ],
        "cypher_query": "MATCH (actor:`sakila_1.actor`)\nRETURN count(DISTINCT actor.last_name)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "sakila_1",
        "query": "Count the number of different last names actors have.",
        "sql_query": "SELECT count(DISTINCT last_name) FROM actor",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "last_name"
                        }
                    }
                }
            },
            "from": "actor"
        },
        "sql_ans": [
            [
                121
            ]
        ],
        "cypher_query": "MATCH (actor:`sakila_1.actor`)\nRETURN count(DISTINCT actor.last_name)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "sakila_1",
        "query": "How many addresses are in the district of California?",
        "sql_query": "SELECT count(*) FROM address WHERE district  =  'California'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "address",
            "where": {
                "eq": [
                    "district",
                    {
                        "literal": "California"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                9
            ]
        ],
        "cypher_query": "MATCH (address:`sakila_1.address`)\nWHERE address.district = 'California'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "sakila_1",
        "query": "Count the number of addressed in the California district.",
        "sql_query": "SELECT count(*) FROM address WHERE district  =  'California'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "address",
            "where": {
                "eq": [
                    "district",
                    {
                        "literal": "California"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                9
            ]
        ],
        "cypher_query": "MATCH (address:`sakila_1.address`)\nWHERE address.district = 'California'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "sakila_1",
        "query": "How many cities are in Australia?",
        "sql_query": "SELECT count(*) FROM city AS T1 JOIN country AS T2 ON T1.country_id  =  T2.country_id WHERE T2.country  =  'Australia'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "city",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "country",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.country_id",
                            "T2.country_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.country",
                    {
                        "literal": "Australia"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`sakila_1.city`)-[]-(T2:`sakila_1.country`)\nWHERE T2.country = 'Australia'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "sakila_1",
        "query": "Count the number of cities in Australia.",
        "sql_query": "SELECT count(*) FROM city AS T1 JOIN country AS T2 ON T1.country_id  =  T2.country_id WHERE T2.country  =  'Australia'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "city",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "country",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.country_id",
                            "T2.country_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.country",
                    {
                        "literal": "Australia"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`sakila_1.city`)-[]-(T2:`sakila_1.country`)\nWHERE T2.country = 'Australia'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "sakila_1",
        "query": "How many customers have an active value of 1?",
        "sql_query": "SELECT count(*) FROM customer WHERE active = '1'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "customer",
            "where": {
                "eq": [
                    "active",
                    {
                        "literal": "1"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                584
            ]
        ],
        "cypher_query": "MATCH (customer:`sakila_1.customer`)\nWHERE customer.active = '1'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "sakila_1",
        "query": "Count the number of customers who are active.",
        "sql_query": "SELECT count(*) FROM customer WHERE active = '1'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "customer",
            "where": {
                "eq": [
                    "active",
                    {
                        "literal": "1"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                584
            ]
        ],
        "cypher_query": "MATCH (customer:`sakila_1.customer`)\nWHERE customer.active = '1'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "sakila_1",
        "query": "How many languages are in these films?",
        "sql_query": "SELECT count(DISTINCT language_id) FROM film",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "language_id"
                        }
                    }
                }
            },
            "from": "film"
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (film:`sakila_1.film`)\nRETURN count(DISTINCT film.language_id)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "sakila_1",
        "query": "Count the number of different languages in these films.",
        "sql_query": "SELECT count(DISTINCT language_id) FROM film",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "language_id"
                        }
                    }
                }
            },
            "from": "film"
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (film:`sakila_1.film`)\nRETURN count(DISTINCT film.language_id)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "sakila_1",
        "query": "How many kinds of different ratings are listed?",
        "sql_query": "SELECT count(DISTINCT rating) FROM film",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "rating"
                        }
                    }
                }
            },
            "from": "film"
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (film:`sakila_1.film`)\nRETURN count(DISTINCT film.rating)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "sakila_1",
        "query": "Count the number of different film ratings.",
        "sql_query": "SELECT count(DISTINCT rating) FROM film",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "rating"
                        }
                    }
                }
            },
            "from": "film"
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (film:`sakila_1.film`)\nRETURN count(DISTINCT film.rating)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "sakila_1",
        "query": "How many items in inventory does store 1 have?",
        "sql_query": "SELECT count(*) FROM inventory WHERE store_id  =  1",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "inventory",
            "where": {
                "eq": [
                    "store_id",
                    1
                ]
            }
        },
        "sql_ans": [
            [
                2270
            ]
        ],
        "cypher_query": "MATCH (inventory:`sakila_1.inventory`)\nWHERE inventory.store_id = 1\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "sakila_1",
        "query": "Count the number of items store 1 has in stock.",
        "sql_query": "SELECT count(*) FROM inventory WHERE store_id  =  1",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "inventory",
            "where": {
                "eq": [
                    "store_id",
                    1
                ]
            }
        },
        "sql_ans": [
            [
                2270
            ]
        ],
        "cypher_query": "MATCH (inventory:`sakila_1.inventory`)\nWHERE inventory.store_id = 1\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "loan_1",
        "query": "For each account type, find the average account balance of customers with credit score lower than 50.",
        "sql_query": "SELECT avg(acc_bal) ,  acc_type FROM customer WHERE credit_score  <  50 GROUP BY acc_type",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "acc_bal"
                    }
                },
                {
                    "value": "acc_type"
                }
            ],
            "from": "customer",
            "where": {
                "lt": [
                    "credit_score",
                    50
                ]
            },
            "groupby": {
                "value": "acc_type"
            }
        },
        "sql_ans": [
            [
                1000.0,
                "checking"
            ],
            [
                2000.0,
                "saving"
            ]
        ],
        "cypher_query": "MATCH (customer:`loan_1.customer`)\nWHERE customer.credit_score < 50\nWITH customer.acc_type AS acc_type, count(customer.acc_type) AS count\nRETURN count,acc_type",
        "cypher_ans": [
            [
                1,
                "saving"
            ],
            [
                1,
                "checking"
            ]
        ]
    },
    {
        "db_id": "loan_1",
        "query": "What is the average account balance of customers with credit score below 50 for the different account types?",
        "sql_query": "SELECT avg(acc_bal) ,  acc_type FROM customer WHERE credit_score  <  50 GROUP BY acc_type",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "acc_bal"
                    }
                },
                {
                    "value": "acc_type"
                }
            ],
            "from": "customer",
            "where": {
                "lt": [
                    "credit_score",
                    50
                ]
            },
            "groupby": {
                "value": "acc_type"
            }
        },
        "sql_ans": [
            [
                1000.0,
                "checking"
            ],
            [
                2000.0,
                "saving"
            ]
        ],
        "cypher_query": "MATCH (customer:`loan_1.customer`)\nWHERE customer.credit_score < 50\nWITH customer.acc_type AS acc_type, count(customer.acc_type) AS count\nRETURN count,acc_type",
        "cypher_ans": [
            [
                1,
                "saving"
            ],
            [
                1,
                "checking"
            ]
        ]
    },
    {
        "db_id": "loan_1",
        "query": "Find the average credit score of the customers who do not have any loan.",
        "sql_query": "SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "credit_score"
                }
            },
            "from": "customer",
            "where": {
                "nin": [
                    "cust_id",
                    {
                        "select": {
                            "value": "cust_id"
                        },
                        "from": "loan"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                20.0
            ]
        ],
        "cypher_query": "MATCH (customer:`loan_1.customer`)\nWHERE NOT (customer:`loan_1.customer`)-[]-(:`loan_1.loan`)\nRETURN avg(customer.credit_score)",
        "cypher_ans": [
            [
                86.66666666666666
            ]
        ]
    },
    {
        "db_id": "loan_1",
        "query": "What is the average credit score for customers who have never taken a loan?",
        "sql_query": "SELECT avg(credit_score) FROM customer WHERE cust_id NOT IN (SELECT cust_id FROM loan)",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "credit_score"
                }
            },
            "from": "customer",
            "where": {
                "nin": [
                    "cust_id",
                    {
                        "select": {
                            "value": "cust_id"
                        },
                        "from": "loan"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                20.0
            ]
        ],
        "cypher_query": "MATCH (customer:`loan_1.customer`)\nWHERE NOT (customer:`loan_1.customer`)-[]-(:`loan_1.loan`)\nRETURN avg(customer.credit_score)",
        "cypher_ans": [
            [
                86.66666666666666
            ]
        ]
    },
    {
        "db_id": "behavior_monitoring",
        "query": "How many assessment notes are there in total?",
        "sql_query": "SELECT count(*) FROM ASSESSMENT_NOTES",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "ASSESSMENT_NOTES"
        },
        "sql_ans": [
            [
                15
            ]
        ],
        "cypher_query": "MATCH (assessment_notes:`behavior_monitoring.Assessment_Notes`)\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "behavior_monitoring",
        "query": "Find the maximum and minimum monthly rental for all student addresses.",
        "sql_query": "SELECT max(monthly_rental) ,  min(monthly_rental) FROM Student_Addresses",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "monthly_rental"
                    }
                },
                {
                    "value": {
                        "min": "monthly_rental"
                    }
                }
            ],
            "from": "Student_Addresses"
        },
        "sql_ans": [
            [
                1297.807,
                620.2801
            ]
        ],
        "cypher_query": "MATCH (student_addresses:`behavior_monitoring.Student_Addresses`)\nRETURN max(student_addresses.monthly_rental),min(student_addresses.monthly_rental)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "behavior_monitoring",
        "query": "What are the first names and last names of students with address in Wisconsin state?",
        "sql_query": "SELECT T2.first_name ,  T2.last_name FROM Addresses AS T1 JOIN Students AS T2 ON T1.address_id  =  T2.address_id WHERE T1.state_province_county  =  \"Wisconsin\"",
        "parsed_sql": {
            "select": [
                {
                    "value": "T2.first_name"
                },
                {
                    "value": "T2.last_name"
                }
            ],
            "from": [
                {
                    "value": "Addresses",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Students",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.address_id",
                            "T2.address_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.state_province_county",
                    "Wisconsin"
                ]
            }
        },
        "sql_ans": [
            [
                "Emma",
                "Rohan"
            ],
            [
                "Christy",
                "Huels"
            ]
        ],
        "cypher_query": "MATCH (T1:`behavior_monitoring.Addresses`)-[]-(T2:`behavior_monitoring.Students`)\nWHERE T1.state_province_county = 'Wisconsin'\nRETURN T2.first_name,T2.last_name",
        "cypher_ans": [
            [
                "Misael",
                "Will"
            ]
        ]
    },
    {
        "db_id": "behavior_monitoring",
        "query": "How many students are not involved in any behavior incident?",
        "sql_query": "SELECT count(*) FROM STUDENTS WHERE student_id NOT IN ( SELECT student_id FROM Behavior_Incident )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "STUDENTS",
            "where": {
                "nin": [
                    "student_id",
                    {
                        "select": {
                            "value": "student_id"
                        },
                        "from": "Behavior_Incident"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                4
            ]
        ],
        "cypher_query": "MATCH (students:`behavior_monitoring.Students`)\nWHERE NOT (students:`behavior_monitoring.Students`)-[]-(:`behavior_monitoring.Behavior_Incident`)\nRETURN count(*)",
        "cypher_ans": [
            [
                15
            ]
        ]
    },
    {
        "db_id": "assets_maintenance",
        "query": "Which engineer has visited the most times? Show the engineer id, first name and last name.",
        "sql_query": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 GROUP BY T1.engineer_id ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "T1.engineer_id"
                },
                {
                    "value": "T1.first_name"
                },
                {
                    "value": "T1.last_name"
                }
            ],
            "from": [
                {
                    "value": "Maintenance_Engineers",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Engineer_Visits",
                        "is_table": true
                    }
                }
            ],
            "groupby": {
                "value": "T1.engineer_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                1,
                "Etha",
                "Reinger"
            ]
        ],
        "cypher_query": "MATCH (T1:`assets_maintenance.Maintenance_Engineers`)-[]-(T2:`assets_maintenance.Engineer_Visits`)\nWITH T1.first_name AS first_name, T1.engineer_id AS engineer_id, count(T1.engineer_id) AS count, T1.last_name AS last_name\nRETURN engineer_id,first_name,last_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                15,
                "Archibald",
                "Streich"
            ]
        ]
    },
    {
        "db_id": "assets_maintenance",
        "query": "Among those engineers who have visited, which engineer makes the least number of visits? List the engineer id, first name and last name.",
        "sql_query": "SELECT T1.engineer_id ,  T1.first_name ,  T1.last_name FROM Maintenance_Engineers AS T1 JOIN Engineer_Visits AS T2 ON T1.engineer_id  =  T2.engineer_id GROUP BY T1.engineer_id ORDER BY count(*) ASC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "T1.engineer_id"
                },
                {
                    "value": "T1.first_name"
                },
                {
                    "value": "T1.last_name"
                }
            ],
            "from": [
                {
                    "value": "Maintenance_Engineers",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Engineer_Visits",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.engineer_id",
                            "T2.engineer_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.engineer_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "asc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                1,
                "Etha",
                "Reinger"
            ]
        ],
        "cypher_query": "MATCH (T1:`assets_maintenance.Maintenance_Engineers`)-[]-(T2:`assets_maintenance.Engineer_Visits`)\nWITH T1.first_name AS first_name, T1.engineer_id AS engineer_id, count(T1.engineer_id) AS count, T1.last_name AS last_name\nRETURN engineer_id,first_name,last_name\nORDER BY count ASC\nLIMIT 1",
        "cypher_ans": [
            [
                8,
                "Nellie",
                "Hirthe"
            ]
        ]
    },
    {
        "db_id": "assets_maintenance",
        "query": "Which assets did not incur any fault log? List the asset model.",
        "sql_query": "SELECT asset_model FROM Assets WHERE asset_id NOT IN (SELECT asset_id FROM Fault_Log)",
        "parsed_sql": {
            "select": {
                "value": "asset_model"
            },
            "from": "Assets",
            "where": {
                "nin": [
                    "asset_id",
                    {
                        "select": {
                            "value": "asset_id"
                        },
                        "from": "Fault_Log"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "58 ub"
            ],
            [
                "69 uv"
            ],
            [
                "20 tl"
            ],
            [
                "11 wi"
            ],
            [
                "08 yy"
            ],
            [
                "66 xm"
            ]
        ],
        "cypher_query": "MATCH (assets:`assets_maintenance.Assets`)\nWHERE NOT (assets:`assets_maintenance.Assets`)-[]-(:`assets_maintenance.Fault_Log`)\nRETURN assets.asset_model",
        "cypher_ans": [
            [
                "58 ub"
            ],
            [
                "35 xt"
            ],
            [
                "63 ok"
            ],
            [
                "69 uv"
            ],
            [
                "90 oq"
            ],
            [
                "91 ub"
            ],
            [
                "27 du"
            ],
            [
                "94 kg"
            ],
            [
                "07 yt"
            ],
            [
                "20 tl"
            ],
            [
                "11 wi"
            ],
            [
                "95 vn"
            ],
            [
                "08 yy"
            ],
            [
                "66 xm"
            ],
            [
                "24 ak"
            ]
        ]
    },
    {
        "db_id": "station_weather",
        "query": "How many trains have 'Express' in their names?",
        "sql_query": "SELECT count(*) FROM train WHERE name LIKE \"%Express%\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "train",
            "where": {
                "like": [
                    "name",
                    "%Express%"
                ]
            }
        },
        "sql_ans": [
            [
                9
            ]
        ],
        "cypher_query": "MATCH (train:`station_weather.train`)\nWHERE train.name =~'.*[\"|\"]%Express%\".*'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "station_weather",
        "query": "What is the average high temperature for each day of week?",
        "sql_query": "SELECT avg(high_temperature) ,  day_of_week FROM weekly_weather GROUP BY day_of_week",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "high_temperature"
                    }
                },
                {
                    "value": "day_of_week"
                }
            ],
            "from": "weekly_weather",
            "groupby": {
                "value": "day_of_week"
            }
        },
        "sql_ans": [
            [
                55.0,
                "Friday"
            ],
            [
                56.0,
                "Monday"
            ],
            [
                55.0,
                "Saturday"
            ],
            [
                54.0,
                "Sunday"
            ],
            [
                57.0,
                "Thursday"
            ],
            [
                58.0,
                "Tuesday"
            ],
            [
                58.0,
                "Wednesday"
            ]
        ],
        "cypher_query": "MATCH (weekly_weather:`station_weather.weekly_weather`)\nWITH weekly_weather.day_of_week AS day_of_week, count(weekly_weather.day_of_week) AS count\nRETURN count,day_of_week",
        "cypher_ans": [
            [
                4,
                "Monday"
            ],
            [
                4,
                "Tuesday"
            ],
            [
                3,
                "Wednesday"
            ],
            [
                2,
                "Thursday"
            ],
            [
                1,
                "Friday"
            ],
            [
                1,
                "Saturday"
            ],
            [
                1,
                "Sunday"
            ]
        ]
    },
    {
        "db_id": "college_1",
        "query": "Find the number of professors in accounting department.",
        "sql_query": "SELECT count(*) FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE DEPT_NAME  =  \"Accounting\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "professor",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "department",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.dept_code",
                            "T2.dept_code"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "DEPT_NAME",
                    "Accounting"
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (T1:`college_1.PROFESSOR`)-[]-(T2:`college_1.DEPARTMENT`)\nWHERE T2.DEPT_NAME = 'Accounting'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_1",
        "query": "How many professors are in the accounting dept?",
        "sql_query": "SELECT count(*) FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE DEPT_NAME  =  \"Accounting\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "professor",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "department",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.dept_code",
                            "T2.dept_code"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "DEPT_NAME",
                    "Accounting"
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (T1:`college_1.PROFESSOR`)-[]-(T2:`college_1.DEPARTMENT`)\nWHERE T2.DEPT_NAME = 'Accounting'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_1",
        "query": "How many classes are professor whose last name is Graztevski has?",
        "sql_query": "SELECT count(*) FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE T1.EMP_LNAME  =  'Graztevski'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "employee",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "CLASS",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.EMP_NUM",
                            "T2.PROF_NUM"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.EMP_LNAME",
                    {
                        "literal": "Graztevski"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (T1:`college_1.EMPLOYEE`)-[]-(T2:`college_1.CLASS`)\nWHERE T1.EMP_LNAME = 'Graztevski'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_1",
        "query": "How many classes does the professor whose last name is Graztevski teach?",
        "sql_query": "SELECT count(*) FROM employee AS T1 JOIN CLASS AS T2 ON T1.EMP_NUM  =  T2.PROF_NUM WHERE T1.EMP_LNAME  =  'Graztevski'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "employee",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "CLASS",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.EMP_NUM",
                            "T2.PROF_NUM"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.EMP_LNAME",
                    {
                        "literal": "Graztevski"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (T1:`college_1.EMPLOYEE`)-[]-(T2:`college_1.CLASS`)\nWHERE T1.EMP_LNAME = 'Graztevski'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_1",
        "query": "How many students enrolled in class ACCT-211?",
        "sql_query": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  'ACCT-211'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "CLASS",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "enroll",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.class_code",
                            "T2.class_code"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.crs_code",
                    {
                        "literal": "ACCT-211"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (T1:`college_1.CLASS`)-[]-(T2:`college_1.ENROLL`)\nWHERE T1.CRS_CODE = 'ACCT-211'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_1",
        "query": "What are the total number of students enrolled in ACCT-211?",
        "sql_query": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code WHERE T1.crs_code  =  'ACCT-211'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "CLASS",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "enroll",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.class_code",
                            "T2.class_code"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.crs_code",
                    {
                        "literal": "ACCT-211"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (T1:`college_1.CLASS`)-[]-(T2:`college_1.ENROLL`)\nWHERE T1.CRS_CODE = 'ACCT-211'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_1",
        "query": "How many students are enrolled in the class taught by some professor from the accounting department?",
        "sql_query": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code WHERE T4.dept_name  =  'Accounting'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "CLASS",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "enroll",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.class_code",
                            "T2.class_code"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "course",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.crs_code",
                            "T3.crs_code"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T4",
                        "value": "department",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T3.dept_code",
                            "T4.dept_code"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T4.dept_name",
                    {
                        "literal": "Accounting"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (T4:`college_1.DEPARTMENT`)-[]-(T3:`college_1.COURSE`)-[]-(T3:`college_1.COURSE`)-[]-(T1:`college_1.CLASS`)-[]-(T1:`college_1.CLASS`)-[]-(T2:`college_1.ENROLL`)\nWHERE T4.DEPT_NAME = 'Accounting'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_1",
        "query": "How many students are enrolled in some classes that are taught by an accounting professor?",
        "sql_query": "SELECT count(*) FROM CLASS AS T1 JOIN enroll AS T2 ON T1.class_code  =  T2.class_code JOIN course AS T3 ON T1.crs_code  =  T3.crs_code JOIN department AS T4 ON T3.dept_code  =  T4.dept_code WHERE T4.dept_name  =  'Accounting'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "CLASS",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "enroll",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.class_code",
                            "T2.class_code"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "course",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.crs_code",
                            "T3.crs_code"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T4",
                        "value": "department",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T3.dept_code",
                            "T4.dept_code"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T4.dept_name",
                    {
                        "literal": "Accounting"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (T4:`college_1.DEPARTMENT`)-[]-(T3:`college_1.COURSE`)-[]-(T3:`college_1.COURSE`)-[]-(T1:`college_1.CLASS`)-[]-(T1:`college_1.CLASS`)-[]-(T2:`college_1.ENROLL`)\nWHERE T4.DEPT_NAME = 'Accounting'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_1",
        "query": "How many professors who are from either Accounting or Biology department?",
        "sql_query": "SELECT count(*) FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T2.dept_name  =  'Accounting' OR T2.dept_name  =  'Biology'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "professor",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "department",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.dept_code",
                            "T2.dept_code"
                        ]
                    }
                }
            ],
            "where": {
                "or": [
                    {
                        "eq": [
                            "T2.dept_name",
                            {
                                "literal": "Accounting"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "T2.dept_name",
                            {
                                "literal": "Biology"
                            }
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (T1:`college_1.PROFESSOR`)-[]-(T2:`college_1.DEPARTMENT`)\nWHERE T2.DEPT_NAME = 'Accounting' OR T2.DEPT_NAME = 'Biology'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_1",
        "query": "What is the number of professors who are in the Accounting or Biology departments?",
        "sql_query": "SELECT count(*) FROM professor AS T1 JOIN department AS T2 ON T1.dept_code  =  T2.dept_code WHERE T2.dept_name  =  'Accounting' OR T2.dept_name  =  'Biology'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "professor",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "department",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.dept_code",
                            "T2.dept_code"
                        ]
                    }
                }
            ],
            "where": {
                "or": [
                    {
                        "eq": [
                            "T2.dept_name",
                            {
                                "literal": "Accounting"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "T2.dept_name",
                            {
                                "literal": "Biology"
                            }
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (T1:`college_1.PROFESSOR`)-[]-(T2:`college_1.DEPARTMENT`)\nWHERE T2.DEPT_NAME = 'Accounting' OR T2.DEPT_NAME = 'Biology'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "college_1",
        "query": "What is the average gpa of the students enrolled in the course with code ACCT-211?",
        "sql_query": "SELECT avg(T2.stu_gpa) FROM enroll AS T1 JOIN student AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T1.class_code  =  T3.class_code WHERE T3.crs_code  =  'ACCT-211'",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T2.stu_gpa"
                }
            },
            "from": [
                {
                    "value": "enroll",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "student",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.stu_num",
                            "T2.stu_num"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "CLASS",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.class_code",
                            "T3.class_code"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T3.crs_code",
                    {
                        "literal": "ACCT-211"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3.0549999999999997
            ]
        ],
        "cypher_query": "MATCH (T3:`college_1.CLASS`)-[]-(T1:`college_1.ENROLL`)-[]-(T1:`college_1.ENROLL`)-[]-(T2:`college_1.STUDENT`)\nWHERE T3.CRS_CODE = 'ACCT-211'\nRETURN avg(T2.STU_GPA)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "college_1",
        "query": "What is the average GPA of students taking ACCT-211?",
        "sql_query": "SELECT avg(T2.stu_gpa) FROM enroll AS T1 JOIN student AS T2 ON T1.stu_num  =  T2.stu_num JOIN CLASS AS T3 ON T1.class_code  =  T3.class_code WHERE T3.crs_code  =  'ACCT-211'",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T2.stu_gpa"
                }
            },
            "from": [
                {
                    "value": "enroll",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "student",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.stu_num",
                            "T2.stu_num"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "CLASS",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.class_code",
                            "T3.class_code"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T3.crs_code",
                    {
                        "literal": "ACCT-211"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3.0549999999999997
            ]
        ],
        "cypher_query": "MATCH (T3:`college_1.CLASS`)-[]-(T1:`college_1.ENROLL`)-[]-(T1:`college_1.ENROLL`)-[]-(T2:`college_1.STUDENT`)\nWHERE T3.CRS_CODE = 'ACCT-211'\nRETURN avg(T2.STU_GPA)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "sports_competition",
        "query": "List the position of players and the average number of points of players of each position.",
        "sql_query": "SELECT POSITION ,  avg(Points) FROM player GROUP BY POSITION",
        "parsed_sql": {
            "select": [
                {
                    "value": "POSITION"
                },
                {
                    "value": {
                        "avg": "Points"
                    }
                }
            ],
            "from": "player",
            "groupby": {
                "value": "POSITION"
            }
        },
        "sql_ans": [
            [
                "Full Back",
                20.0
            ],
            [
                "Hooker",
                36.0
            ],
            [
                "Left Wing",
                12.0
            ],
            [
                "Loose Forward",
                20.0
            ],
            [
                "Prop",
                9.333333333333334
            ],
            [
                "Right Centre",
                36.0
            ],
            [
                "Right Wing",
                36.0
            ],
            [
                "Scrum Half",
                188.0
            ],
            [
                "Second Row",
                20.0
            ],
            [
                "Stand Off",
                110.0
            ]
        ],
        "cypher_query": "MATCH (player:`sports_competition.player`)\nWITH player.Position AS Position, count(player.Position) AS count\nRETURN Position,count",
        "cypher_ans": [
            [
                "Full Back",
                1
            ],
            [
                "Right Wing",
                1
            ],
            [
                "Right Centre",
                1
            ],
            [
                "Left Wing",
                1
            ],
            [
                "Stand Off",
                1
            ],
            [
                "Scrum Half",
                1
            ],
            [
                "Prop",
                3
            ],
            [
                "Hooker",
                1
            ],
            [
                "Second Row",
                3
            ],
            [
                "Loose Forward",
                2
            ]
        ]
    },
    {
        "db_id": "sports_competition",
        "query": "For each position, what is the average number of points for players in that position?",
        "sql_query": "SELECT POSITION ,  avg(Points) FROM player GROUP BY POSITION",
        "parsed_sql": {
            "select": [
                {
                    "value": "POSITION"
                },
                {
                    "value": {
                        "avg": "Points"
                    }
                }
            ],
            "from": "player",
            "groupby": {
                "value": "POSITION"
            }
        },
        "sql_ans": [
            [
                "Full Back",
                20.0
            ],
            [
                "Hooker",
                36.0
            ],
            [
                "Left Wing",
                12.0
            ],
            [
                "Loose Forward",
                20.0
            ],
            [
                "Prop",
                9.333333333333334
            ],
            [
                "Right Centre",
                36.0
            ],
            [
                "Right Wing",
                36.0
            ],
            [
                "Scrum Half",
                188.0
            ],
            [
                "Second Row",
                20.0
            ],
            [
                "Stand Off",
                110.0
            ]
        ],
        "cypher_query": "MATCH (player:`sports_competition.player`)\nWITH player.Position AS Position, count(player.Position) AS count\nRETURN Position,count",
        "cypher_ans": [
            [
                "Full Back",
                1
            ],
            [
                "Right Wing",
                1
            ],
            [
                "Right Centre",
                1
            ],
            [
                "Left Wing",
                1
            ],
            [
                "Stand Off",
                1
            ],
            [
                "Scrum Half",
                1
            ],
            [
                "Prop",
                3
            ],
            [
                "Hooker",
                1
            ],
            [
                "Second Row",
                3
            ],
            [
                "Loose Forward",
                2
            ]
        ]
    },
    {
        "db_id": "hr_1",
        "query": "Display the first and last name, and salary for those employees whose first name is ending with the letter m.",
        "sql_query": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE '%m'",
        "parsed_sql": {
            "select": [
                {
                    "value": "first_name"
                },
                {
                    "value": "last_name"
                },
                {
                    "value": "salary"
                }
            ],
            "from": "employees",
            "where": {
                "like": [
                    "first_name",
                    {
                        "literal": "%m"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Adam",
                "Fripp",
                8200
            ],
            [
                "Payam",
                "Kaufling",
                7900
            ],
            [
                "William",
                "Smith",
                7400
            ],
            [
                "William",
                "Gietz",
                8300
            ]
        ],
        "cypher_query": "MATCH (employees:`hr_1.employees`)\nWHERE employees.FIRST_NAME =~'.*[M|m].*'\nRETURN employees.FIRST_NAME,employees.LAST_NAME,employees.SALARY",
        "cypher_ans": [
            [
                "Ismael",
                "Sciarra",
                7700
            ],
            [
                "Jose Manuel",
                "Urman",
                7800
            ],
            [
                "Matthew",
                "Weiss",
                8000
            ],
            [
                "Adam",
                "Fripp",
                8200
            ],
            [
                "Payam",
                "Kaufling",
                7900
            ],
            [
                "James",
                "Landry",
                2400
            ],
            [
                "Mozhe",
                "Atkinson",
                2800
            ],
            [
                "James",
                "Marlow",
                2500
            ],
            [
                "Michael",
                "Rogers",
                2900
            ],
            [
                "Mattea",
                "Marvins",
                7200
            ],
            [
                "Amit",
                "Banda",
                6200
            ],
            [
                "William",
                "Smith",
                7400
            ],
            [
                "Kimberely",
                "Grant",
                7000
            ],
            [
                "Martha",
                "Sullivan",
                2500
            ],
            [
                "Timothy",
                "Gates",
                2900
            ],
            [
                "Samuel",
                "McCain",
                3200
            ],
            [
                "Michael",
                "Hartstein",
                13000
            ],
            [
                "Hermann",
                "Baer",
                10000
            ],
            [
                "William",
                "Gietz",
                8300
            ]
        ]
    },
    {
        "db_id": "hr_1",
        "query": "Return the full names and salaries for employees with first names that end with the letter m.",
        "sql_query": "SELECT first_name ,  last_name ,  salary FROM employees WHERE first_name LIKE '%m'",
        "parsed_sql": {
            "select": [
                {
                    "value": "first_name"
                },
                {
                    "value": "last_name"
                },
                {
                    "value": "salary"
                }
            ],
            "from": "employees",
            "where": {
                "like": [
                    "first_name",
                    {
                        "literal": "%m"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Adam",
                "Fripp",
                8200
            ],
            [
                "Payam",
                "Kaufling",
                7900
            ],
            [
                "William",
                "Smith",
                7400
            ],
            [
                "William",
                "Gietz",
                8300
            ]
        ],
        "cypher_query": "MATCH (employees:`hr_1.employees`)\nWHERE employees.FIRST_NAME =~'.*[M|m].*'\nRETURN employees.FIRST_NAME,employees.LAST_NAME,employees.SALARY",
        "cypher_ans": [
            [
                "Ismael",
                "Sciarra",
                7700
            ],
            [
                "Jose Manuel",
                "Urman",
                7800
            ],
            [
                "Matthew",
                "Weiss",
                8000
            ],
            [
                "Adam",
                "Fripp",
                8200
            ],
            [
                "Payam",
                "Kaufling",
                7900
            ],
            [
                "James",
                "Landry",
                2400
            ],
            [
                "Mozhe",
                "Atkinson",
                2800
            ],
            [
                "James",
                "Marlow",
                2500
            ],
            [
                "Michael",
                "Rogers",
                2900
            ],
            [
                "Mattea",
                "Marvins",
                7200
            ],
            [
                "Amit",
                "Banda",
                6200
            ],
            [
                "William",
                "Smith",
                7400
            ],
            [
                "Kimberely",
                "Grant",
                7000
            ],
            [
                "Martha",
                "Sullivan",
                2500
            ],
            [
                "Timothy",
                "Gates",
                2900
            ],
            [
                "Samuel",
                "McCain",
                3200
            ],
            [
                "Michael",
                "Hartstein",
                13000
            ],
            [
                "Hermann",
                "Baer",
                10000
            ],
            [
                "William",
                "Gietz",
                8300
            ]
        ]
    },
    {
        "db_id": "hr_1",
        "query": "display the employee ID for each employee and the date on which he ended his previous job.",
        "sql_query": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id",
        "parsed_sql": {
            "select": [
                {
                    "value": "employee_id"
                },
                {
                    "value": {
                        "max": "end_date"
                    }
                }
            ],
            "from": "job_history",
            "groupby": {
                "value": "employee_id"
            }
        },
        "sql_ans": [
            [
                0,
                "0000-00-00"
            ],
            [
                101,
                "1997-03-15"
            ],
            [
                102,
                "1998-07-24"
            ],
            [
                114,
                "1999-12-31"
            ],
            [
                122,
                "1999-12-31"
            ],
            [
                176,
                "1999-12-31"
            ],
            [
                200,
                "1998-12-31"
            ],
            [
                201,
                "1999-12-19"
            ]
        ],
        "cypher_query": "MATCH (job_history:`hr_1.job_history`)\nWITH count(job_history.EMPLOYEE_ID) AS count, job_history.EMPLOYEE_ID AS EMPLOYEE_ID\nRETURN EMPLOYEE_ID,count",
        "cypher_ans": [
            [
                102,
                1
            ],
            [
                101,
                2
            ],
            [
                201,
                1
            ],
            [
                114,
                1
            ],
            [
                122,
                1
            ],
            [
                200,
                2
            ],
            [
                176,
                2
            ],
            [
                0,
                1
            ]
        ]
    },
    {
        "db_id": "hr_1",
        "query": "What are the employee ids for each employee and final dates of employment at their last job?",
        "sql_query": "SELECT employee_id ,  MAX(end_date) FROM job_history GROUP BY employee_id",
        "parsed_sql": {
            "select": [
                {
                    "value": "employee_id"
                },
                {
                    "value": {
                        "max": "end_date"
                    }
                }
            ],
            "from": "job_history",
            "groupby": {
                "value": "employee_id"
            }
        },
        "sql_ans": [
            [
                0,
                "0000-00-00"
            ],
            [
                101,
                "1997-03-15"
            ],
            [
                102,
                "1998-07-24"
            ],
            [
                114,
                "1999-12-31"
            ],
            [
                122,
                "1999-12-31"
            ],
            [
                176,
                "1999-12-31"
            ],
            [
                200,
                "1998-12-31"
            ],
            [
                201,
                "1999-12-19"
            ]
        ],
        "cypher_query": "MATCH (job_history:`hr_1.job_history`)\nWITH count(job_history.EMPLOYEE_ID) AS count, job_history.EMPLOYEE_ID AS EMPLOYEE_ID\nRETURN EMPLOYEE_ID,count",
        "cypher_ans": [
            [
                102,
                1
            ],
            [
                101,
                2
            ],
            [
                201,
                1
            ],
            [
                114,
                1
            ],
            [
                122,
                1
            ],
            [
                200,
                2
            ],
            [
                176,
                2
            ],
            [
                0,
                1
            ]
        ]
    },
    {
        "db_id": "hr_1",
        "query": "display the average salary of employees for each department who gets a commission percentage.",
        "sql_query": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != \"null\" GROUP BY department_id",
        "parsed_sql": {
            "select": [
                {
                    "value": "department_id"
                },
                {
                    "value": {
                        "avg": "salary"
                    }
                }
            ],
            "from": "employees",
            "where": {
                "exists": "commission_pct"
            },
            "groupby": {
                "value": "department_id"
            }
        },
        "sql_ans": [
            [
                0,
                7000.0
            ],
            [
                10,
                4400.0
            ],
            [
                20,
                9500.0
            ],
            [
                30,
                4150.0
            ],
            [
                40,
                6500.0
            ],
            [
                50,
                3475.5555555555557
            ],
            [
                60,
                5760.0
            ],
            [
                70,
                10000.0
            ],
            [
                80,
                8955.882352941177
            ],
            [
                90,
                19333.333333333332
            ],
            [
                100,
                8600.0
            ],
            [
                110,
                10150.0
            ]
        ],
        "cypher_query": "MATCH (employees:`hr_1.employees`)\nWHERE exists(employees.COMMISSION_PCT)\nWITH count(employees.DEPARTMENT_ID) AS count, employees.DEPARTMENT_ID AS DEPARTMENT_ID\nRETURN DEPARTMENT_ID,count",
        "cypher_ans": [
            [
                90,
                3
            ],
            [
                60,
                5
            ],
            [
                100,
                6
            ],
            [
                30,
                6
            ],
            [
                50,
                45
            ],
            [
                80,
                34
            ],
            [
                0,
                1
            ],
            [
                10,
                1
            ],
            [
                20,
                2
            ],
            [
                40,
                1
            ],
            [
                70,
                1
            ],
            [
                110,
                2
            ]
        ]
    },
    {
        "db_id": "hr_1",
        "query": "What is the average salary of employees who have a commission percentage that is not null?",
        "sql_query": "SELECT department_id ,  AVG(salary) FROM employees WHERE commission_pct != \"null\" GROUP BY department_id",
        "parsed_sql": {
            "select": [
                {
                    "value": "department_id"
                },
                {
                    "value": {
                        "avg": "salary"
                    }
                }
            ],
            "from": "employees",
            "where": {
                "exists": "commission_pct"
            },
            "groupby": {
                "value": "department_id"
            }
        },
        "sql_ans": [
            [
                0,
                7000.0
            ],
            [
                10,
                4400.0
            ],
            [
                20,
                9500.0
            ],
            [
                30,
                4150.0
            ],
            [
                40,
                6500.0
            ],
            [
                50,
                3475.5555555555557
            ],
            [
                60,
                5760.0
            ],
            [
                70,
                10000.0
            ],
            [
                80,
                8955.882352941177
            ],
            [
                90,
                19333.333333333332
            ],
            [
                100,
                8600.0
            ],
            [
                110,
                10150.0
            ]
        ],
        "cypher_query": "MATCH (employees:`hr_1.employees`)\nWHERE exists(employees.COMMISSION_PCT)\nWITH count(employees.DEPARTMENT_ID) AS count, employees.DEPARTMENT_ID AS DEPARTMENT_ID\nRETURN DEPARTMENT_ID,count",
        "cypher_ans": [
            [
                90,
                3
            ],
            [
                60,
                5
            ],
            [
                100,
                6
            ],
            [
                30,
                6
            ],
            [
                50,
                45
            ],
            [
                80,
                34
            ],
            [
                0,
                1
            ],
            [
                10,
                1
            ],
            [
                20,
                2
            ],
            [
                40,
                1
            ],
            [
                70,
                1
            ],
            [
                110,
                2
            ]
        ]
    },
    {
        "db_id": "hr_1",
        "query": "return the smallest salary for every departments.",
        "sql_query": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "min": "salary"
                    }
                },
                {
                    "value": "department_id"
                }
            ],
            "from": "employees",
            "groupby": {
                "value": "department_id"
            }
        },
        "sql_ans": [
            [
                7000,
                0
            ],
            [
                4400,
                10
            ],
            [
                6000,
                20
            ],
            [
                2500,
                30
            ],
            [
                6500,
                40
            ],
            [
                2100,
                50
            ],
            [
                4200,
                60
            ],
            [
                10000,
                70
            ],
            [
                6100,
                80
            ],
            [
                17000,
                90
            ],
            [
                6900,
                100
            ],
            [
                8300,
                110
            ]
        ],
        "cypher_query": "MATCH (employees:`hr_1.employees`)\nWITH count(employees.DEPARTMENT_ID) AS count, employees.DEPARTMENT_ID AS DEPARTMENT_ID\nRETURN count,DEPARTMENT_ID",
        "cypher_ans": [
            [
                3,
                90
            ],
            [
                5,
                60
            ],
            [
                6,
                100
            ],
            [
                6,
                30
            ],
            [
                45,
                50
            ],
            [
                34,
                80
            ],
            [
                1,
                0
            ],
            [
                1,
                10
            ],
            [
                2,
                20
            ],
            [
                1,
                40
            ],
            [
                1,
                70
            ],
            [
                2,
                110
            ]
        ]
    },
    {
        "db_id": "hr_1",
        "query": "What is the minimum salary in each department?",
        "sql_query": "SELECT MIN(salary) ,  department_id FROM employees GROUP BY department_id",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "min": "salary"
                    }
                },
                {
                    "value": "department_id"
                }
            ],
            "from": "employees",
            "groupby": {
                "value": "department_id"
            }
        },
        "sql_ans": [
            [
                7000,
                0
            ],
            [
                4400,
                10
            ],
            [
                6000,
                20
            ],
            [
                2500,
                30
            ],
            [
                6500,
                40
            ],
            [
                2100,
                50
            ],
            [
                4200,
                60
            ],
            [
                10000,
                70
            ],
            [
                6100,
                80
            ],
            [
                17000,
                90
            ],
            [
                6900,
                100
            ],
            [
                8300,
                110
            ]
        ],
        "cypher_query": "MATCH (employees:`hr_1.employees`)\nWITH count(employees.DEPARTMENT_ID) AS count, employees.DEPARTMENT_ID AS DEPARTMENT_ID\nRETURN count,DEPARTMENT_ID",
        "cypher_ans": [
            [
                3,
                90
            ],
            [
                5,
                60
            ],
            [
                6,
                100
            ],
            [
                6,
                30
            ],
            [
                45,
                50
            ],
            [
                34,
                80
            ],
            [
                1,
                0
            ],
            [
                1,
                10
            ],
            [
                2,
                20
            ],
            [
                1,
                40
            ],
            [
                1,
                70
            ],
            [
                2,
                110
            ]
        ]
    },
    {
        "db_id": "hr_1",
        "query": "display the department ID, full name (first and last name), salary for those employees who is highest salary in every department.",
        "sql_query": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id",
        "parsed_sql": {
            "select": [
                {
                    "value": "first_name"
                },
                {
                    "value": "last_name"
                },
                {
                    "value": "salary"
                },
                {
                    "value": "department_id"
                },
                {
                    "value": {
                        "max": "salary"
                    }
                }
            ],
            "from": "employees",
            "groupby": {
                "value": "department_id"
            }
        },
        "sql_ans": [
            [
                "Kimberely",
                "Grant",
                7000,
                0,
                7000
            ],
            [
                "Jennifer",
                "Whalen",
                4400,
                10,
                4400
            ],
            [
                "Michael",
                "Hartstein",
                13000,
                20,
                13000
            ],
            [
                "Den",
                "Raphaely",
                11000,
                30,
                11000
            ],
            [
                "Susan",
                "Mavris",
                6500,
                40,
                6500
            ],
            [
                "Adam",
                "Fripp",
                8200,
                50,
                8200
            ],
            [
                "Alexander",
                "Hunold",
                9000,
                60,
                9000
            ],
            [
                "Hermann",
                "Baer",
                10000,
                70,
                10000
            ],
            [
                "John",
                "Russell",
                14000,
                80,
                14000
            ],
            [
                "Steven",
                "King",
                24000,
                90,
                24000
            ],
            [
                "Nancy",
                "Greenberg",
                12000,
                100,
                12000
            ],
            [
                "Shelley",
                "Higgins",
                12000,
                110,
                12000
            ]
        ],
        "cypher_query": "MATCH (employees:`hr_1.employees`)\nWITH count(employees.DEPARTMENT_ID) AS count, employees.SALARY AS SALARY, employees.LAST_NAME AS LAST_NAME, employees.DEPARTMENT_ID AS DEPARTMENT_ID, employees.FIRST_NAME AS FIRST_NAME\nRETURN FIRST_NAME,LAST_NAME,SALARY,DEPARTMENT_ID,count",
        "cypher_ans": [
            [
                "Steven",
                "King",
                24000,
                90,
                1
            ],
            [
                "Neena",
                "Kochhar",
                17000,
                90,
                1
            ],
            [
                "Lex",
                "De Haan",
                17000,
                90,
                1
            ],
            [
                "Alexander",
                "Hunold",
                9000,
                60,
                1
            ],
            [
                "Bruce",
                "Ernst",
                6000,
                60,
                1
            ],
            [
                "David",
                "Austin",
                4800,
                60,
                1
            ],
            [
                "Valli",
                "Pataballa",
                4800,
                60,
                1
            ],
            [
                "Diana",
                "Lorentz",
                4200,
                60,
                1
            ],
            [
                "Nancy",
                "Greenberg",
                12000,
                100,
                1
            ],
            [
                "Daniel",
                "Faviet",
                9000,
                100,
                1
            ],
            [
                "John",
                "Chen",
                8200,
                100,
                1
            ],
            [
                "Ismael",
                "Sciarra",
                7700,
                100,
                1
            ],
            [
                "Jose Manuel",
                "Urman",
                7800,
                100,
                1
            ],
            [
                "Luis",
                "Popp",
                6900,
                100,
                1
            ],
            [
                "Den",
                "Raphaely",
                11000,
                30,
                1
            ],
            [
                "Alexander",
                "Khoo",
                3100,
                30,
                1
            ],
            [
                "Shelli",
                "Baida",
                2900,
                30,
                1
            ],
            [
                "Sigal",
                "Tobias",
                2800,
                30,
                1
            ],
            [
                "Guy",
                "Himuro",
                2600,
                30,
                1
            ],
            [
                "Karen",
                "Colmenares",
                2500,
                30,
                1
            ],
            [
                "Matthew",
                "Weiss",
                8000,
                50,
                1
            ],
            [
                "Adam",
                "Fripp",
                8200,
                50,
                1
            ],
            [
                "Payam",
                "Kaufling",
                7900,
                50,
                1
            ],
            [
                "Shanta",
                "Vollman",
                6500,
                50,
                1
            ],
            [
                "Kevin",
                "Mourgos",
                5800,
                50,
                1
            ],
            [
                "Julia",
                "Nayer",
                3200,
                50,
                1
            ],
            [
                "Irene",
                "Mikkilineni",
                2700,
                50,
                1
            ],
            [
                "James",
                "Landry",
                2400,
                50,
                1
            ],
            [
                "Steven",
                "Markle",
                2200,
                50,
                1
            ],
            [
                "Laura",
                "Bissot",
                3300,
                50,
                1
            ],
            [
                "Mozhe",
                "Atkinson",
                2800,
                50,
                1
            ],
            [
                "James",
                "Marlow",
                2500,
                50,
                1
            ],
            [
                "TJ",
                "Olson",
                2100,
                50,
                1
            ],
            [
                "Jason",
                "Mallin",
                3300,
                50,
                1
            ],
            [
                "Michael",
                "Rogers",
                2900,
                50,
                1
            ],
            [
                "Ki",
                "Gee",
                2400,
                50,
                1
            ],
            [
                "Hazel",
                "Philtanker",
                2200,
                50,
                1
            ],
            [
                "Renske",
                "Ladwig",
                3600,
                50,
                1
            ],
            [
                "Stephen",
                "Stiles",
                3200,
                50,
                1
            ],
            [
                "John",
                "Seo",
                2700,
                50,
                1
            ],
            [
                "Joshua",
                "Patel",
                2500,
                50,
                1
            ],
            [
                "Trenna",
                "Rajs",
                3500,
                50,
                1
            ],
            [
                "Curtis",
                "Davies",
                3100,
                50,
                1
            ],
            [
                "Randall",
                "Matos",
                2600,
                50,
                1
            ],
            [
                "Peter",
                "Vargas",
                2500,
                50,
                1
            ],
            [
                "John",
                "Russell",
                14000,
                80,
                1
            ],
            [
                "Karen",
                "Partners",
                13500,
                80,
                1
            ],
            [
                "Alberto",
                "Errazuriz",
                12000,
                80,
                1
            ],
            [
                "Gerald",
                "Cambrault",
                11000,
                80,
                1
            ],
            [
                "Eleni",
                "Zlotkey",
                10500,
                80,
                1
            ],
            [
                "Peter",
                "Tucker",
                10000,
                80,
                1
            ],
            [
                "David",
                "Bernstein",
                9500,
                80,
                1
            ],
            [
                "Peter",
                "Hall",
                9000,
                80,
                1
            ],
            [
                "Christopher",
                "Olsen",
                8000,
                80,
                1
            ],
            [
                "Nanette",
                "Cambrault",
                7500,
                80,
                1
            ],
            [
                "Oliver",
                "Tuvault",
                7000,
                80,
                1
            ],
            [
                "Janette",
                "King",
                10000,
                80,
                1
            ],
            [
                "Patrick",
                "Sully",
                9500,
                80,
                1
            ],
            [
                "Allan",
                "McEwen",
                9000,
                80,
                1
            ],
            [
                "Lindsey",
                "Smith",
                8000,
                80,
                1
            ],
            [
                "Louise",
                "Doran",
                7500,
                80,
                1
            ],
            [
                "Sarath",
                "Sewall",
                7000,
                80,
                1
            ],
            [
                "Clara",
                "Vishney",
                10500,
                80,
                1
            ],
            [
                "Danielle",
                "Greene",
                9500,
                80,
                1
            ],
            [
                "Mattea",
                "Marvins",
                7200,
                80,
                1
            ],
            [
                "David",
                "Lee",
                6800,
                80,
                1
            ],
            [
                "Sundar",
                "Ande",
                6400,
                80,
                1
            ],
            [
                "Amit",
                "Banda",
                6200,
                80,
                1
            ],
            [
                "Lisa",
                "Ozer",
                11500,
                80,
                1
            ],
            [
                "Harrison",
                "Bloom",
                10000,
                80,
                1
            ],
            [
                "Tayler",
                "Fox",
                9600,
                80,
                1
            ],
            [
                "William",
                "Smith",
                7400,
                80,
                1
            ],
            [
                "Elizabeth",
                "Bates",
                7300,
                80,
                1
            ],
            [
                "Sundita",
                "Kumar",
                6100,
                80,
                1
            ],
            [
                "Ellen",
                "Abel",
                11000,
                80,
                1
            ],
            [
                "Alyssa",
                "Hutton",
                8800,
                80,
                1
            ],
            [
                "Jonathon",
                "Taylor",
                8600,
                80,
                1
            ],
            [
                "Jack",
                "Livingston",
                8400,
                80,
                1
            ],
            [
                "Kimberely",
                "Grant",
                7000,
                0,
                1
            ],
            [
                "Charles",
                "Johnson",
                6200,
                80,
                1
            ],
            [
                "Winston",
                "Taylor",
                3200,
                50,
                1
            ],
            [
                "Jean",
                "Fleaur",
                3100,
                50,
                1
            ],
            [
                "Martha",
                "Sullivan",
                2500,
                50,
                1
            ],
            [
                "Girard",
                "Geoni",
                2800,
                50,
                1
            ],
            [
                "Nandita",
                "Sarchand",
                4200,
                50,
                1
            ],
            [
                "Alexis",
                "Bull",
                4100,
                50,
                1
            ],
            [
                "Julia",
                "Dellinger",
                3400,
                50,
                1
            ],
            [
                "Anthony",
                "Cabrio",
                3000,
                50,
                1
            ],
            [
                "Kelly",
                "Chung",
                3800,
                50,
                1
            ],
            [
                "Jennifer",
                "Dilly",
                3600,
                50,
                1
            ],
            [
                "Timothy",
                "Gates",
                2900,
                50,
                1
            ],
            [
                "Randall",
                "Perkins",
                2500,
                50,
                1
            ],
            [
                "Sarah",
                "Bell",
                4000,
                50,
                1
            ],
            [
                "Britney",
                "Everett",
                3900,
                50,
                1
            ],
            [
                "Samuel",
                "McCain",
                3200,
                50,
                1
            ],
            [
                "Vance",
                "Jones",
                2800,
                50,
                1
            ],
            [
                "Alana",
                "Walsh",
                3100,
                50,
                1
            ],
            [
                "Kevin",
                "Feeney",
                3000,
                50,
                1
            ],
            [
                "Donald",
                "OConnell",
                2600,
                50,
                1
            ],
            [
                "Douglas",
                "Grant",
                2600,
                50,
                1
            ],
            [
                "Jennifer",
                "Whalen",
                4400,
                10,
                1
            ],
            [
                "Michael",
                "Hartstein",
                13000,
                20,
                1
            ],
            [
                "Pat",
                "Fay",
                6000,
                20,
                1
            ],
            [
                "Susan",
                "Mavris",
                6500,
                40,
                1
            ],
            [
                "Hermann",
                "Baer",
                10000,
                70,
                1
            ],
            [
                "Shelley",
                "Higgins",
                12000,
                110,
                1
            ],
            [
                "William",
                "Gietz",
                8300,
                110,
                1
            ]
        ]
    },
    {
        "db_id": "hr_1",
        "query": "What are the department ids, full names, and salaries for employees who make the most in their departments?",
        "sql_query": "SELECT first_name ,   last_name ,   salary ,  department_id ,  MAX(salary) FROM employees GROUP BY department_id",
        "parsed_sql": {
            "select": [
                {
                    "value": "first_name"
                },
                {
                    "value": "last_name"
                },
                {
                    "value": "salary"
                },
                {
                    "value": "department_id"
                },
                {
                    "value": {
                        "max": "salary"
                    }
                }
            ],
            "from": "employees",
            "groupby": {
                "value": "department_id"
            }
        },
        "sql_ans": [
            [
                "Kimberely",
                "Grant",
                7000,
                0,
                7000
            ],
            [
                "Jennifer",
                "Whalen",
                4400,
                10,
                4400
            ],
            [
                "Michael",
                "Hartstein",
                13000,
                20,
                13000
            ],
            [
                "Den",
                "Raphaely",
                11000,
                30,
                11000
            ],
            [
                "Susan",
                "Mavris",
                6500,
                40,
                6500
            ],
            [
                "Adam",
                "Fripp",
                8200,
                50,
                8200
            ],
            [
                "Alexander",
                "Hunold",
                9000,
                60,
                9000
            ],
            [
                "Hermann",
                "Baer",
                10000,
                70,
                10000
            ],
            [
                "John",
                "Russell",
                14000,
                80,
                14000
            ],
            [
                "Steven",
                "King",
                24000,
                90,
                24000
            ],
            [
                "Nancy",
                "Greenberg",
                12000,
                100,
                12000
            ],
            [
                "Shelley",
                "Higgins",
                12000,
                110,
                12000
            ]
        ],
        "cypher_query": "MATCH (employees:`hr_1.employees`)\nWITH count(employees.DEPARTMENT_ID) AS count, employees.SALARY AS SALARY, employees.LAST_NAME AS LAST_NAME, employees.DEPARTMENT_ID AS DEPARTMENT_ID, employees.FIRST_NAME AS FIRST_NAME\nRETURN FIRST_NAME,LAST_NAME,SALARY,DEPARTMENT_ID,count",
        "cypher_ans": [
            [
                "Steven",
                "King",
                24000,
                90,
                1
            ],
            [
                "Neena",
                "Kochhar",
                17000,
                90,
                1
            ],
            [
                "Lex",
                "De Haan",
                17000,
                90,
                1
            ],
            [
                "Alexander",
                "Hunold",
                9000,
                60,
                1
            ],
            [
                "Bruce",
                "Ernst",
                6000,
                60,
                1
            ],
            [
                "David",
                "Austin",
                4800,
                60,
                1
            ],
            [
                "Valli",
                "Pataballa",
                4800,
                60,
                1
            ],
            [
                "Diana",
                "Lorentz",
                4200,
                60,
                1
            ],
            [
                "Nancy",
                "Greenberg",
                12000,
                100,
                1
            ],
            [
                "Daniel",
                "Faviet",
                9000,
                100,
                1
            ],
            [
                "John",
                "Chen",
                8200,
                100,
                1
            ],
            [
                "Ismael",
                "Sciarra",
                7700,
                100,
                1
            ],
            [
                "Jose Manuel",
                "Urman",
                7800,
                100,
                1
            ],
            [
                "Luis",
                "Popp",
                6900,
                100,
                1
            ],
            [
                "Den",
                "Raphaely",
                11000,
                30,
                1
            ],
            [
                "Alexander",
                "Khoo",
                3100,
                30,
                1
            ],
            [
                "Shelli",
                "Baida",
                2900,
                30,
                1
            ],
            [
                "Sigal",
                "Tobias",
                2800,
                30,
                1
            ],
            [
                "Guy",
                "Himuro",
                2600,
                30,
                1
            ],
            [
                "Karen",
                "Colmenares",
                2500,
                30,
                1
            ],
            [
                "Matthew",
                "Weiss",
                8000,
                50,
                1
            ],
            [
                "Adam",
                "Fripp",
                8200,
                50,
                1
            ],
            [
                "Payam",
                "Kaufling",
                7900,
                50,
                1
            ],
            [
                "Shanta",
                "Vollman",
                6500,
                50,
                1
            ],
            [
                "Kevin",
                "Mourgos",
                5800,
                50,
                1
            ],
            [
                "Julia",
                "Nayer",
                3200,
                50,
                1
            ],
            [
                "Irene",
                "Mikkilineni",
                2700,
                50,
                1
            ],
            [
                "James",
                "Landry",
                2400,
                50,
                1
            ],
            [
                "Steven",
                "Markle",
                2200,
                50,
                1
            ],
            [
                "Laura",
                "Bissot",
                3300,
                50,
                1
            ],
            [
                "Mozhe",
                "Atkinson",
                2800,
                50,
                1
            ],
            [
                "James",
                "Marlow",
                2500,
                50,
                1
            ],
            [
                "TJ",
                "Olson",
                2100,
                50,
                1
            ],
            [
                "Jason",
                "Mallin",
                3300,
                50,
                1
            ],
            [
                "Michael",
                "Rogers",
                2900,
                50,
                1
            ],
            [
                "Ki",
                "Gee",
                2400,
                50,
                1
            ],
            [
                "Hazel",
                "Philtanker",
                2200,
                50,
                1
            ],
            [
                "Renske",
                "Ladwig",
                3600,
                50,
                1
            ],
            [
                "Stephen",
                "Stiles",
                3200,
                50,
                1
            ],
            [
                "John",
                "Seo",
                2700,
                50,
                1
            ],
            [
                "Joshua",
                "Patel",
                2500,
                50,
                1
            ],
            [
                "Trenna",
                "Rajs",
                3500,
                50,
                1
            ],
            [
                "Curtis",
                "Davies",
                3100,
                50,
                1
            ],
            [
                "Randall",
                "Matos",
                2600,
                50,
                1
            ],
            [
                "Peter",
                "Vargas",
                2500,
                50,
                1
            ],
            [
                "John",
                "Russell",
                14000,
                80,
                1
            ],
            [
                "Karen",
                "Partners",
                13500,
                80,
                1
            ],
            [
                "Alberto",
                "Errazuriz",
                12000,
                80,
                1
            ],
            [
                "Gerald",
                "Cambrault",
                11000,
                80,
                1
            ],
            [
                "Eleni",
                "Zlotkey",
                10500,
                80,
                1
            ],
            [
                "Peter",
                "Tucker",
                10000,
                80,
                1
            ],
            [
                "David",
                "Bernstein",
                9500,
                80,
                1
            ],
            [
                "Peter",
                "Hall",
                9000,
                80,
                1
            ],
            [
                "Christopher",
                "Olsen",
                8000,
                80,
                1
            ],
            [
                "Nanette",
                "Cambrault",
                7500,
                80,
                1
            ],
            [
                "Oliver",
                "Tuvault",
                7000,
                80,
                1
            ],
            [
                "Janette",
                "King",
                10000,
                80,
                1
            ],
            [
                "Patrick",
                "Sully",
                9500,
                80,
                1
            ],
            [
                "Allan",
                "McEwen",
                9000,
                80,
                1
            ],
            [
                "Lindsey",
                "Smith",
                8000,
                80,
                1
            ],
            [
                "Louise",
                "Doran",
                7500,
                80,
                1
            ],
            [
                "Sarath",
                "Sewall",
                7000,
                80,
                1
            ],
            [
                "Clara",
                "Vishney",
                10500,
                80,
                1
            ],
            [
                "Danielle",
                "Greene",
                9500,
                80,
                1
            ],
            [
                "Mattea",
                "Marvins",
                7200,
                80,
                1
            ],
            [
                "David",
                "Lee",
                6800,
                80,
                1
            ],
            [
                "Sundar",
                "Ande",
                6400,
                80,
                1
            ],
            [
                "Amit",
                "Banda",
                6200,
                80,
                1
            ],
            [
                "Lisa",
                "Ozer",
                11500,
                80,
                1
            ],
            [
                "Harrison",
                "Bloom",
                10000,
                80,
                1
            ],
            [
                "Tayler",
                "Fox",
                9600,
                80,
                1
            ],
            [
                "William",
                "Smith",
                7400,
                80,
                1
            ],
            [
                "Elizabeth",
                "Bates",
                7300,
                80,
                1
            ],
            [
                "Sundita",
                "Kumar",
                6100,
                80,
                1
            ],
            [
                "Ellen",
                "Abel",
                11000,
                80,
                1
            ],
            [
                "Alyssa",
                "Hutton",
                8800,
                80,
                1
            ],
            [
                "Jonathon",
                "Taylor",
                8600,
                80,
                1
            ],
            [
                "Jack",
                "Livingston",
                8400,
                80,
                1
            ],
            [
                "Kimberely",
                "Grant",
                7000,
                0,
                1
            ],
            [
                "Charles",
                "Johnson",
                6200,
                80,
                1
            ],
            [
                "Winston",
                "Taylor",
                3200,
                50,
                1
            ],
            [
                "Jean",
                "Fleaur",
                3100,
                50,
                1
            ],
            [
                "Martha",
                "Sullivan",
                2500,
                50,
                1
            ],
            [
                "Girard",
                "Geoni",
                2800,
                50,
                1
            ],
            [
                "Nandita",
                "Sarchand",
                4200,
                50,
                1
            ],
            [
                "Alexis",
                "Bull",
                4100,
                50,
                1
            ],
            [
                "Julia",
                "Dellinger",
                3400,
                50,
                1
            ],
            [
                "Anthony",
                "Cabrio",
                3000,
                50,
                1
            ],
            [
                "Kelly",
                "Chung",
                3800,
                50,
                1
            ],
            [
                "Jennifer",
                "Dilly",
                3600,
                50,
                1
            ],
            [
                "Timothy",
                "Gates",
                2900,
                50,
                1
            ],
            [
                "Randall",
                "Perkins",
                2500,
                50,
                1
            ],
            [
                "Sarah",
                "Bell",
                4000,
                50,
                1
            ],
            [
                "Britney",
                "Everett",
                3900,
                50,
                1
            ],
            [
                "Samuel",
                "McCain",
                3200,
                50,
                1
            ],
            [
                "Vance",
                "Jones",
                2800,
                50,
                1
            ],
            [
                "Alana",
                "Walsh",
                3100,
                50,
                1
            ],
            [
                "Kevin",
                "Feeney",
                3000,
                50,
                1
            ],
            [
                "Donald",
                "OConnell",
                2600,
                50,
                1
            ],
            [
                "Douglas",
                "Grant",
                2600,
                50,
                1
            ],
            [
                "Jennifer",
                "Whalen",
                4400,
                10,
                1
            ],
            [
                "Michael",
                "Hartstein",
                13000,
                20,
                1
            ],
            [
                "Pat",
                "Fay",
                6000,
                20,
                1
            ],
            [
                "Susan",
                "Mavris",
                6500,
                40,
                1
            ],
            [
                "Hermann",
                "Baer",
                10000,
                70,
                1
            ],
            [
                "Shelley",
                "Higgins",
                12000,
                110,
                1
            ],
            [
                "William",
                "Gietz",
                8300,
                110,
                1
            ]
        ]
    },
    {
        "db_id": "music_1",
        "query": "How many songs have 4 minute duration?",
        "sql_query": "SELECT count(*) FROM files WHERE duration LIKE \"4:%\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "files",
            "where": {
                "like": [
                    "duration",
                    "4:%"
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (files:`music_1.files`)\nWHERE files.duration =~'.*[\"|\"]4:%\".*'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "music_1",
        "query": "What is the count of the songs that last approximately 4 minutes?",
        "sql_query": "SELECT count(*) FROM files WHERE duration LIKE \"4:%\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "files",
            "where": {
                "like": [
                    "duration",
                    "4:%"
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (files:`music_1.files`)\nWHERE files.duration =~'.*[\"|\"]4:%\".*'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "music_1",
        "query": "What is the average rating of songs for each language?",
        "sql_query": "SELECT avg(rating) ,  languages FROM song GROUP BY languages",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "rating"
                    }
                },
                {
                    "value": "languages"
                }
            ],
            "from": "song",
            "groupby": {
                "value": "languages"
            }
        },
        "sql_ans": [
            [
                7.5,
                "bangla"
            ],
            [
                7.0,
                "english"
            ]
        ],
        "cypher_query": "MATCH (song:`music_1.song`)\nWITH song.languages AS languages, count(song.languages) AS count\nRETURN count,languages",
        "cypher_ans": [
            [
                4,
                "bangla"
            ],
            [
                2,
                "english"
            ]
        ]
    },
    {
        "db_id": "music_1",
        "query": "What is the average song rating for each language?",
        "sql_query": "SELECT avg(rating) ,  languages FROM song GROUP BY languages",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "rating"
                    }
                },
                {
                    "value": "languages"
                }
            ],
            "from": "song",
            "groupby": {
                "value": "languages"
            }
        },
        "sql_ans": [
            [
                7.5,
                "bangla"
            ],
            [
                7.0,
                "english"
            ]
        ],
        "cypher_query": "MATCH (song:`music_1.song`)\nWITH song.languages AS languages, count(song.languages) AS count\nRETURN count,languages",
        "cypher_ans": [
            [
                4,
                "bangla"
            ],
            [
                2,
                "english"
            ]
        ]
    },
    {
        "db_id": "music_1",
        "query": "What is the language that was used most often in songs with resolution above 500?",
        "sql_query": "SELECT artist_name FROM song WHERE resolution  >  500 GROUP BY languages ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "artist_name"
            },
            "from": "song",
            "where": {
                "gt": [
                    "resolution",
                    500
                ]
            },
            "groupby": {
                "value": "languages"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Enrique"
            ]
        ],
        "cypher_query": "MATCH (song:`music_1.song`)\nWHERE song.resolution > 500\nWITH song.artist_name AS artist_name, count(song.languages) AS count\nRETURN artist_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Shrikanta"
            ]
        ]
    },
    {
        "db_id": "music_1",
        "query": "What is the name of the artist, for each language, that has the most songs with a higher resolution than 500?",
        "sql_query": "SELECT artist_name FROM song WHERE resolution  >  500 GROUP BY languages ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "artist_name"
            },
            "from": "song",
            "where": {
                "gt": [
                    "resolution",
                    500
                ]
            },
            "groupby": {
                "value": "languages"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Enrique"
            ]
        ],
        "cypher_query": "MATCH (song:`music_1.song`)\nWHERE song.resolution > 500\nWITH song.artist_name AS artist_name, count(song.languages) AS count\nRETURN artist_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Shrikanta"
            ]
        ]
    },
    {
        "db_id": "music_1",
        "query": "Find the names and number of works of the three artists who have produced the most songs.",
        "sql_query": "SELECT T1.artist_name ,  count(*) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3",
        "parsed_sql": {
            "select": [
                {
                    "value": "T1.artist_name"
                },
                {
                    "value": {
                        "count": "*"
                    }
                }
            ],
            "from": [
                {
                    "value": "artist",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "song",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.artist_name",
                            "T2.artist_name"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T2.artist_name"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 3
        },
        "sql_ans": [
            [
                "Topu",
                1
            ],
            [
                "Shrikanta",
                1
            ],
            [
                "Prity",
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`music_1.artist`)-[]-(T2:`music_1.song`)\nWITH T1.artist_name AS artist_name, count(T2.artist_name) AS count\nRETURN artist_name,count\nORDER BY count DESC\nLIMIT 3",
        "cypher_ans": [
            [
                "Prity",
                1
            ],
            [
                "Farida",
                1
            ],
            [
                "Shrikanta",
                1
            ]
        ]
    },
    {
        "db_id": "music_1",
        "query": "What are the names of the three artists who have produced the most songs, and how many works did they produce?",
        "sql_query": "SELECT T1.artist_name ,  count(*) FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3",
        "parsed_sql": {
            "select": [
                {
                    "value": "T1.artist_name"
                },
                {
                    "value": {
                        "count": "*"
                    }
                }
            ],
            "from": [
                {
                    "value": "artist",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "song",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.artist_name",
                            "T2.artist_name"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T2.artist_name"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 3
        },
        "sql_ans": [
            [
                "Topu",
                1
            ],
            [
                "Shrikanta",
                1
            ],
            [
                "Prity",
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`music_1.artist`)-[]-(T2:`music_1.song`)\nWITH T1.artist_name AS artist_name, count(T2.artist_name) AS count\nRETURN artist_name,count\nORDER BY count DESC\nLIMIT 3",
        "cypher_ans": [
            [
                "Prity",
                1
            ],
            [
                "Farida",
                1
            ],
            [
                "Shrikanta",
                1
            ]
        ]
    },
    {
        "db_id": "music_1",
        "query": "Find the top 3 artists who have the largest number of songs works whose language is Bangla.",
        "sql_query": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  \"bangla\" GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3",
        "parsed_sql": {
            "select": {
                "value": "T1.artist_name"
            },
            "from": [
                {
                    "value": "artist",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "song",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.artist_name",
                            "T2.artist_name"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.languages",
                    "bangla"
                ]
            },
            "groupby": {
                "value": "T2.artist_name"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 3
        },
        "sql_ans": [
            [
                "Topu"
            ],
            [
                "Shrikanta"
            ],
            [
                "Prity"
            ]
        ],
        "cypher_query": "MATCH (T1:`music_1.artist`)-[]-(T2:`music_1.song`)\nWHERE T2.languages = 'bangla'\nWITH T1.artist_name AS artist_name, count(T2.artist_name) AS count\nRETURN artist_name\nORDER BY count DESC\nLIMIT 3",
        "cypher_ans": [
            [
                "Prity"
            ],
            [
                "Farida"
            ],
            [
                "Shrikanta"
            ]
        ]
    },
    {
        "db_id": "music_1",
        "query": "What are the top 3 artists with the largest number of songs in the language Bangla?",
        "sql_query": "SELECT T1.artist_name FROM artist AS T1 JOIN song AS T2 ON T1.artist_name  =  T2.artist_name WHERE T2.languages  =  \"bangla\" GROUP BY T2.artist_name ORDER BY count(*) DESC LIMIT 3",
        "parsed_sql": {
            "select": {
                "value": "T1.artist_name"
            },
            "from": [
                {
                    "value": "artist",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "song",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.artist_name",
                            "T2.artist_name"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.languages",
                    "bangla"
                ]
            },
            "groupby": {
                "value": "T2.artist_name"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 3
        },
        "sql_ans": [
            [
                "Topu"
            ],
            [
                "Shrikanta"
            ],
            [
                "Prity"
            ]
        ],
        "cypher_query": "MATCH (T1:`music_1.artist`)-[]-(T2:`music_1.song`)\nWHERE T2.languages = 'bangla'\nWITH T1.artist_name AS artist_name, count(T2.artist_name) AS count\nRETURN artist_name\nORDER BY count DESC\nLIMIT 3",
        "cypher_ans": [
            [
                "Prity"
            ],
            [
                "Farida"
            ],
            [
                "Shrikanta"
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "What is average salary of the players in the team named 'Boston Red Stockings' ?",
        "sql_query": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T1.salary"
                }
            },
            "from": [
                {
                    "value": "salary",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "team",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.team_id",
                            "T2.team_id_br"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.name",
                    {
                        "literal": "Boston Red Stockings"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2856616.7595628416
            ]
        ],
        "cypher_query": "MATCH (T1:`baseball_1.salary`)-[]-(T2:`baseball_1.team`)\nWHERE T2.name = 'Boston Red Stockings'\nRETURN avg(T1.salary)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "Compute the average salary of the players in the team called 'Boston Red Stockings'.",
        "sql_query": "SELECT avg(T1.salary) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings'",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T1.salary"
                }
            },
            "from": [
                {
                    "value": "salary",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "team",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.team_id",
                            "T2.team_id_br"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.name",
                    {
                        "literal": "Boston Red Stockings"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2856616.7595628416
            ]
        ],
        "cypher_query": "MATCH (T1:`baseball_1.salary`)-[]-(T2:`baseball_1.team`)\nWHERE T2.name = 'Boston Red Stockings'\nRETURN avg(T1.salary)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "How many parks are there in the state of NY?",
        "sql_query": "SELECT count(*) FROM park WHERE state  =  'NY';",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "park",
            "where": {
                "eq": [
                    "state",
                    {
                        "literal": "NY"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                40
            ]
        ],
        "cypher_query": "MATCH (park:`baseball_1.park`)\nWHERE park.state = 'NY'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "Show me the number of parks the state of NY has.",
        "sql_query": "SELECT count(*) FROM park WHERE state  =  'NY';",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "park",
            "where": {
                "eq": [
                    "state",
                    {
                        "literal": "NY"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                40
            ]
        ],
        "cypher_query": "MATCH (park:`baseball_1.park`)\nWHERE park.state = 'NY'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "How many players born in USA are right-handed batters? That is, have the batter value 'R'.",
        "sql_query": "SELECT count(*) FROM player WHERE birth_country = 'USA' AND bats  =  'R';",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "player",
            "where": {
                "and": [
                    {
                        "eq": [
                            "birth_country",
                            {
                                "literal": "USA"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "bats",
                            {
                                "literal": "R"
                            }
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                10104
            ]
        ],
        "cypher_query": "MATCH (player:`baseball_1.player`)\nWHERE player.birth_country = 'USA' AND player.bats = 'R'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "Count the number of players who were born in USA and have bats information 'R'.",
        "sql_query": "SELECT count(*) FROM player WHERE birth_country = 'USA' AND bats  =  'R';",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "player",
            "where": {
                "and": [
                    {
                        "eq": [
                            "birth_country",
                            {
                                "literal": "USA"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "bats",
                            {
                                "literal": "R"
                            }
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                10104
            ]
        ],
        "cypher_query": "MATCH (player:`baseball_1.player`)\nWHERE player.birth_country = 'USA' AND player.bats = 'R'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "What is the average height of the players from the college named 'Yale University'?",
        "sql_query": "SELECT avg(T1.height) FROM player AS T1 JOIN player_college AS T2 ON T1.player_id  =  T2.player_id JOIN college AS T3 ON T3.college_id  =  T2.college_id WHERE T3.name_full  =  'Yale University';",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T1.height"
                }
            },
            "from": [
                {
                    "value": "player",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "player_college",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.player_id",
                            "T2.player_id"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "college",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T3.college_id",
                            "T2.college_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T3.name_full",
                    {
                        "literal": "Yale University"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                59.13559322033898
            ]
        ],
        "cypher_query": "MATCH (T2:`baseball_1.player_college`)-[]-(T3:`baseball_1.college`)-[]-(T1:`baseball_1.player`)-[]-(T2:`baseball_1.player_college`)\nWHERE T3.name_full = 'Yale University'\nRETURN avg(T1.height)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "Find the average height of the players who belong to the college called 'Yale University'.",
        "sql_query": "SELECT avg(T1.height) FROM player AS T1 JOIN player_college AS T2 ON T1.player_id  =  T2.player_id JOIN college AS T3 ON T3.college_id  =  T2.college_id WHERE T3.name_full  =  'Yale University';",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T1.height"
                }
            },
            "from": [
                {
                    "value": "player",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "player_college",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.player_id",
                            "T2.player_id"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "college",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T3.college_id",
                            "T2.college_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T3.name_full",
                    {
                        "literal": "Yale University"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                59.13559322033898
            ]
        ],
        "cypher_query": "MATCH (T2:`baseball_1.player_college`)-[]-(T3:`baseball_1.college`)-[]-(T1:`baseball_1.player`)-[]-(T2:`baseball_1.player_college`)\nWHERE T3.name_full = 'Yale University'\nRETURN avg(T1.height)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "List the maximum scores of the team Boston Red Stockings when the team won in postseason?",
        "sql_query": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';",
        "parsed_sql": {
            "select": {
                "value": {
                    "max": "T1.wins"
                }
            },
            "from": [
                {
                    "value": "postseason",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "team",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.team_id_winner",
                            "T2.team_id_br"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.name",
                    {
                        "literal": "Boston Red Stockings"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (T1:`baseball_1.postseason`)-[]-(T2:`baseball_1.team`)\nWHERE T2.name = 'Boston Red Stockings'\nRETURN max(T1.wins)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "What are the maximum scores the team Boston Red Stockings got when the team won in postseason?",
        "sql_query": "SELECT max(T1.wins) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_winner  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings';",
        "parsed_sql": {
            "select": {
                "value": {
                    "max": "T1.wins"
                }
            },
            "from": [
                {
                    "value": "postseason",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "team",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.team_id_winner",
                            "T2.team_id_br"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.name",
                    {
                        "literal": "Boston Red Stockings"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (T1:`baseball_1.postseason`)-[]-(T2:`baseball_1.team`)\nWHERE T2.name = 'Boston Red Stockings'\nRETURN max(T1.wins)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "How many times did Boston Red Stockings lose in 2009 postseason?",
        "sql_query": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year = 2009;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "postseason",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "team",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.team_id_loser",
                            "T2.team_id_br"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T2.name",
                            {
                                "literal": "Boston Red Stockings"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "T1.year",
                            2009
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (T1:`baseball_1.postseason`)-[]-(T2:`baseball_1.team`)\nWHERE T2.name = 'Boston Red Stockings' AND T1.year = 2009\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "Count the number of times the team \"Boston Red Stockings\" lost in 2009 postseason.",
        "sql_query": "SELECT count(*) FROM postseason AS T1 JOIN team AS T2 ON T1.team_id_loser  =  T2.team_id_br WHERE T2.name  =  'Boston Red Stockings' AND T1.year = 2009;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "postseason",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "team",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.team_id_loser",
                            "T2.team_id_br"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T2.name",
                            {
                                "literal": "Boston Red Stockings"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "T1.year",
                            2009
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (T1:`baseball_1.postseason`)-[]-(T2:`baseball_1.team`)\nWHERE T2.name = 'Boston Red Stockings' AND T1.year = 2009\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "How many games in 1885 postseason resulted in ties (that is, the value of \"ties\" is '1')?",
        "sql_query": "SELECT count(*) FROM postseason WHERE YEAR  =  1885 AND ties  =  1;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "postseason",
            "where": {
                "and": [
                    {
                        "eq": [
                            "YEAR",
                            1885
                        ]
                    },
                    {
                        "eq": [
                            "ties",
                            1
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (postseason:`baseball_1.postseason`)\nWHERE postseason.year = 1885 AND postseason.ties = 1\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "Find the number of tied games (the value of \"ties\" is '1') in 1885 postseason.",
        "sql_query": "SELECT count(*) FROM postseason WHERE YEAR  =  1885 AND ties  =  1;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "postseason",
            "where": {
                "and": [
                    {
                        "eq": [
                            "YEAR",
                            1885
                        ]
                    },
                    {
                        "eq": [
                            "ties",
                            1
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (postseason:`baseball_1.postseason`)\nWHERE postseason.year = 1885 AND postseason.ties = 1\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "How many players were in the team Boston Red Stockings in 2000?",
        "sql_query": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "salary",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "team",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.team_id",
                            "T2.team_id_br"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T2.name",
                            {
                                "literal": "Boston Red Stockings"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "T1.year",
                            2000
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                150
            ]
        ],
        "cypher_query": "MATCH (T1:`baseball_1.salary`)-[]-(T2:`baseball_1.team`)\nWHERE T2.name = 'Boston Red Stockings' AND T1.year = 2000\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "How many players did Boston Red Stockings have in 2000?",
        "sql_query": "SELECT count(*) FROM salary AS T1 JOIN team AS T2 ON T1.team_id  =  T2.team_id_br WHERE T2.name  = 'Boston Red Stockings' AND T1.year  =  2000",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "salary",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "team",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.team_id",
                            "T2.team_id_br"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T2.name",
                            {
                                "literal": "Boston Red Stockings"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "T1.year",
                            2000
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                150
            ]
        ],
        "cypher_query": "MATCH (T1:`baseball_1.salary`)-[]-(T2:`baseball_1.team`)\nWHERE T2.name = 'Boston Red Stockings' AND T1.year = 2000\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "How many parks are there in Atlanta city?",
        "sql_query": "SELECT count(*) FROM park WHERE city = 'Atlanta';",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "park",
            "where": {
                "eq": [
                    "city",
                    {
                        "literal": "Atlanta"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (park:`baseball_1.park`)\nWHERE park.city = 'Atlanta'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "How many parks does Atlanta city have?",
        "sql_query": "SELECT count(*) FROM park WHERE city = 'Atlanta';",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "park",
            "where": {
                "eq": [
                    "city",
                    {
                        "literal": "Atlanta"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (park:`baseball_1.park`)\nWHERE park.city = 'Atlanta'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "How many games were played in park \"Columbia Park\" in 1907?",
        "sql_query": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "home_game",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "park",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.park_id",
                            "T2.park_id"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.year",
                            1907
                        ]
                    },
                    {
                        "eq": [
                            "T2.park_name",
                            {
                                "literal": "Columbia Park"
                            }
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`baseball_1.home_game`)-[]-(T2:`baseball_1.park`)\nWHERE T1.year = 1907 AND T2.park_name = 'Columbia Park'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "Count the number of games taken place in park \"Columbia Park\" in 1907.",
        "sql_query": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year = 1907 AND T2.park_name = 'Columbia Park';",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "home_game",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "park",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.park_id",
                            "T2.park_id"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.year",
                            1907
                        ]
                    },
                    {
                        "eq": [
                            "T2.park_name",
                            {
                                "literal": "Columbia Park"
                            }
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`baseball_1.home_game`)-[]-(T2:`baseball_1.park`)\nWHERE T1.year = 1907 AND T2.park_name = 'Columbia Park'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "How many games were played in city Atlanta in 2000?",
        "sql_query": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "home_game",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "park",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.park_id",
                            "T2.park_id"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.year",
                            2000
                        ]
                    },
                    {
                        "eq": [
                            "T2.city",
                            {
                                "literal": "Atlanta"
                            }
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`baseball_1.home_game`)-[]-(T2:`baseball_1.park`)\nWHERE T1.year = 2000 AND T2.city = 'Atlanta'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "Find the number of games taken place in city Atlanta in 2000.",
        "sql_query": "SELECT count(*) FROM home_game AS T1 JOIN park AS T2 ON T1.park_id  =  T2.park_id WHERE T1.year  =  2000 AND T2.city  =  'Atlanta';",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "home_game",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "park",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.park_id",
                            "T2.park_id"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.year",
                            2000
                        ]
                    },
                    {
                        "eq": [
                            "T2.city",
                            {
                                "literal": "Atlanta"
                            }
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T1:`baseball_1.home_game`)-[]-(T2:`baseball_1.park`)\nWHERE T1.year = 2000 AND T2.city = 'Atlanta'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "How many team franchises are active, with active value 'Y'?",
        "sql_query": "SELECT count(*) FROM team_franchise WHERE active = 'Y';",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "team_franchise",
            "where": {
                "eq": [
                    "active",
                    {
                        "literal": "Y"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                30
            ]
        ],
        "cypher_query": "MATCH (team_franchise:`baseball_1.team_franchise`)\nWHERE team_franchise.active = 'Y'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "baseball_1",
        "query": "Find the number of team franchises that are active (have 'Y' as \"active\" information).",
        "sql_query": "SELECT count(*) FROM team_franchise WHERE active = 'Y';",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "team_franchise",
            "where": {
                "eq": [
                    "active",
                    {
                        "literal": "Y"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                30
            ]
        ],
        "cypher_query": "MATCH (team_franchise:`baseball_1.team_franchise`)\nWHERE team_franchise.active = 'Y'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "mountain_photos",
        "query": "What are the maximum and average height of the mountains?",
        "sql_query": "SELECT max(height) ,  avg(height) FROM mountain",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "height"
                    }
                },
                {
                    "value": {
                        "avg": "height"
                    }
                }
            ],
            "from": "mountain"
        },
        "sql_ans": [
            [
                4260.0,
                4061.2608695652175
            ]
        ],
        "cypher_query": "MATCH (mountain:`mountain_photos.mountain`)\nRETURN max(mountain.Height),avg(mountain.Height)",
        "cypher_ans": [
            [
                4260.0,
                4061.2608695652166
            ]
        ]
    },
    {
        "db_id": "mountain_photos",
        "query": "How many camera lenses are not used in taking any photos?",
        "sql_query": "SELECT count(*) FROM camera_lens WHERE id NOT IN ( SELECT camera_lens_id FROM photos )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "camera_lens",
            "where": {
                "nin": [
                    "id",
                    {
                        "select": {
                            "value": "camera_lens_id"
                        },
                        "from": "photos"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                6
            ]
        ],
        "cypher_query": "MATCH (camera_lens:`mountain_photos.camera_lens`)\nWHERE NOT (camera_lens:`mountain_photos.camera_lens`)-[]-(:`mountain_photos.photos`)\nRETURN count(*)",
        "cypher_ans": [
            [
                11
            ]
        ]
    },
    {
        "db_id": "program_share",
        "query": "how many programs are broadcast in each time section of the day?",
        "sql_query": "SELECT count(*) ,  time_of_day FROM broadcast GROUP BY time_of_day",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "count": "*"
                    }
                },
                {
                    "value": "time_of_day"
                }
            ],
            "from": "broadcast",
            "groupby": {
                "value": "time_of_day"
            }
        },
        "sql_ans": [
            [
                4,
                "Morning"
            ],
            [
                5,
                "Night"
            ],
            [
                2,
                "Noon"
            ]
        ],
        "cypher_query": "MATCH ()-[broadcast:`program_share.broadcast`]-()\nWITH broadcast.Time_of_day AS Time_of_day, count(broadcast.Time_of_day) AS count\nRETURN count,Time_of_day",
        "cypher_ans": [
            [
                8,
                "Morning"
            ],
            [
                10,
                "Night"
            ],
            [
                4,
                "Noon"
            ]
        ]
    },
    {
        "db_id": "program_share",
        "query": "Count the number of programs broadcast for each time section of a day.",
        "sql_query": "SELECT count(*) ,  time_of_day FROM broadcast GROUP BY time_of_day",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "count": "*"
                    }
                },
                {
                    "value": "time_of_day"
                }
            ],
            "from": "broadcast",
            "groupby": {
                "value": "time_of_day"
            }
        },
        "sql_ans": [
            [
                4,
                "Morning"
            ],
            [
                5,
                "Night"
            ],
            [
                2,
                "Noon"
            ]
        ],
        "cypher_query": "MATCH ()-[broadcast:`program_share.broadcast`]-()\nWITH broadcast.Time_of_day AS Time_of_day, count(broadcast.Time_of_day) AS count\nRETURN count,Time_of_day",
        "cypher_ans": [
            [
                8,
                "Morning"
            ],
            [
                10,
                "Night"
            ],
            [
                4,
                "Noon"
            ]
        ]
    },
    {
        "db_id": "program_share",
        "query": "find the number of different programs that are broadcast during night time.",
        "sql_query": "SELECT count(DISTINCT program_id) FROM broadcast WHERE time_of_day  =  'Night'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "program_id"
                        }
                    }
                }
            },
            "from": "broadcast",
            "where": {
                "eq": [
                    "time_of_day",
                    {
                        "literal": "Night"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH ()-[broadcast:`program_share.broadcast`]-()\nWHERE broadcast.Time_of_day = 'Night'\nRETURN count(DISTINCT broadcast.Program_ID)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "program_share",
        "query": "How many distinct programs are broadcast at \"Night\" time?",
        "sql_query": "SELECT count(DISTINCT program_id) FROM broadcast WHERE time_of_day  =  'Night'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "program_id"
                        }
                    }
                }
            },
            "from": "broadcast",
            "where": {
                "eq": [
                    "time_of_day",
                    {
                        "literal": "Night"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH ()-[broadcast:`program_share.broadcast`]-()\nWHERE broadcast.Time_of_day = 'Night'\nRETURN count(DISTINCT broadcast.Program_ID)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "e_learning",
        "query": "How many students have personal names that contain the word \"son\"?",
        "sql_query": "SELECT COUNT(*) FROM Students WHERE personal_name LIKE \"%son%\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Students",
            "where": {
                "like": [
                    "personal_name",
                    "%son%"
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (students:`e_learning.Students`)\nWHERE students.personal_name =~'.*[\"|\"]%son%\".*'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "e_learning",
        "query": "Find the number of students who have the word \"son\" in their personal names.",
        "sql_query": "SELECT COUNT(*) FROM Students WHERE personal_name LIKE \"%son%\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Students",
            "where": {
                "like": [
                    "personal_name",
                    "%son%"
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (students:`e_learning.Students`)\nWHERE students.personal_name =~'.*[\"|\"]%son%\".*'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "e_learning",
        "query": "How many students did not have any course enrollment?",
        "sql_query": "SELECT count(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Students",
            "where": {
                "nin": [
                    "student_id",
                    {
                        "select": {
                            "value": "student_id"
                        },
                        "from": "Student_Course_Enrolment"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (students:`e_learning.Students`)\nWHERE NOT (students:`e_learning.Students`)-[]-(:`e_learning.Student_Course_Enrolment`)\nRETURN count(*)",
        "cypher_ans": [
            [
                15
            ]
        ]
    },
    {
        "db_id": "e_learning",
        "query": "Count the number of students who did not enroll in any course.",
        "sql_query": "SELECT count(*) FROM Students WHERE student_id NOT IN (SELECT student_id FROM Student_Course_Enrolment)",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Students",
            "where": {
                "nin": [
                    "student_id",
                    {
                        "select": {
                            "value": "student_id"
                        },
                        "from": "Student_Course_Enrolment"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (students:`e_learning.Students`)\nWHERE NOT (students:`e_learning.Students`)-[]-(:`e_learning.Student_Course_Enrolment`)\nRETURN count(*)",
        "cypher_ans": [
            [
                15
            ]
        ]
    },
    {
        "db_id": "hospital_1",
        "query": "How many patients' prescriptions are made by physician John Dorian?",
        "sql_query": "SELECT count(T1.SSN) FROM patient AS T1 JOIN prescribes AS T2 ON T1.SSN  =  T2.patient JOIN physician AS T3 ON T2.physician  =  T3.employeeid WHERE T3.name = \"John Dorian\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "T1.SSN"
                }
            },
            "from": [
                {
                    "value": "patient",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "prescribes",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.SSN",
                            "T2.patient"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "physician",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T2.physician",
                            "T3.employeeid"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T3.name",
                    "John Dorian"
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T3:`hospital_1.Physician`)-[]-(T2:`hospital_1.Prescribes`)-[]-(T1:`hospital_1.Patient`)-[]-(T2:`hospital_1.Prescribes`)\nWHERE T3.Name = 'John Dorian'\nRETURN count(T1.SSN)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "hospital_1",
        "query": "Find the number of patients' prescriptions physician John Dorian made.",
        "sql_query": "SELECT count(T1.SSN) FROM patient AS T1 JOIN prescribes AS T2 ON T1.SSN  =  T2.patient JOIN physician AS T3 ON T2.physician  =  T3.employeeid WHERE T3.name = \"John Dorian\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "T1.SSN"
                }
            },
            "from": [
                {
                    "value": "patient",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "prescribes",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.SSN",
                            "T2.patient"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "physician",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T2.physician",
                            "T3.employeeid"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T3.name",
                    "John Dorian"
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T3:`hospital_1.Physician`)-[]-(T2:`hospital_1.Prescribes`)-[]-(T1:`hospital_1.Patient`)-[]-(T2:`hospital_1.Prescribes`)\nWHERE T3.Name = 'John Dorian'\nRETURN count(T1.SSN)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "hospital_1",
        "query": "Find the number of patients who are not using the medication of Procrastin-X.",
        "sql_query": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "patient",
            "where": {
                "nin": [
                    "SSN",
                    {
                        "select": {
                            "value": "T1.patient"
                        },
                        "from": [
                            {
                                "value": "Prescribes",
                                "name": "T1",
                                "is_table": true
                            },
                            {
                                "join": {
                                    "name": "T2",
                                    "value": "Medication",
                                    "is_table": true
                                },
                                "on": {
                                    "eq": [
                                        "T1.Medication",
                                        "T2.Code"
                                    ]
                                }
                            }
                        ],
                        "where": {
                            "eq": [
                                "T2.name",
                                {
                                    "literal": "Procrastin-X"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (patient:`hospital_1.Patient`)\nWHERE NOT (patient:`hospital_1.Patient`)-[]-(:`hospital_1.Prescribes`)-[]-(:`hospital_1.Medication { Name : 'Procrastin-X' }`)\nRETURN count(*)",
        "cypher_ans": [
            [
                4
            ]
        ]
    },
    {
        "db_id": "hospital_1",
        "query": "How many patients are not using Procrastin-X as medication?",
        "sql_query": "SELECT count(*) FROM patient WHERE SSN NOT IN ( SELECT T1.patient FROM Prescribes AS T1 JOIN Medication AS T2 ON T1.Medication  =  T2.Code WHERE T2.name  =  'Procrastin-X' )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "patient",
            "where": {
                "nin": [
                    "SSN",
                    {
                        "select": {
                            "value": "T1.patient"
                        },
                        "from": [
                            {
                                "value": "Prescribes",
                                "name": "T1",
                                "is_table": true
                            },
                            {
                                "join": {
                                    "name": "T2",
                                    "value": "Medication",
                                    "is_table": true
                                },
                                "on": {
                                    "eq": [
                                        "T1.Medication",
                                        "T2.Code"
                                    ]
                                }
                            }
                        ],
                        "where": {
                            "eq": [
                                "T2.name",
                                {
                                    "literal": "Procrastin-X"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (patient:`hospital_1.Patient`)\nWHERE NOT (patient:`hospital_1.Patient`)-[]-(:`hospital_1.Prescribes`)-[]-(:`hospital_1.Medication { Name : 'Procrastin-X' }`)\nRETURN count(*)",
        "cypher_ans": [
            [
                4
            ]
        ]
    },
    {
        "db_id": "ship_mission",
        "query": "Show different types of ships and the average tonnage of ships of each type.",
        "sql_query": "SELECT TYPE ,  avg(Tonnage) FROM ship GROUP BY TYPE",
        "parsed_sql": {
            "select": [
                {
                    "value": "TYPE"
                },
                {
                    "value": {
                        "avg": "Tonnage"
                    }
                }
            ],
            "from": "ship",
            "groupby": {
                "value": "TYPE"
            }
        },
        "sql_ans": [
            [
                "Battle ship",
                4845.0
            ],
            [
                "Cargo ship",
                3932.2
            ]
        ],
        "cypher_query": "MATCH (ship:`ship_mission.ship`)\nWITH ship.Type AS Type, count(ship.Type) AS count\nRETURN Type,count",
        "cypher_ans": [
            [
                "Cargo ship",
                5
            ],
            [
                "Battle ship",
                3
            ]
        ]
    },
    {
        "db_id": "ship_mission",
        "query": "For each type, what is the average tonnage?",
        "sql_query": "SELECT TYPE ,  avg(Tonnage) FROM ship GROUP BY TYPE",
        "parsed_sql": {
            "select": [
                {
                    "value": "TYPE"
                },
                {
                    "value": {
                        "avg": "Tonnage"
                    }
                }
            ],
            "from": "ship",
            "groupby": {
                "value": "TYPE"
            }
        },
        "sql_ans": [
            [
                "Battle ship",
                4845.0
            ],
            [
                "Cargo ship",
                3932.2
            ]
        ],
        "cypher_query": "MATCH (ship:`ship_mission.ship`)\nWITH ship.Type AS Type, count(ship.Type) AS count\nRETURN Type,count",
        "cypher_ans": [
            [
                "Cargo ship",
                5
            ],
            [
                "Battle ship",
                3
            ]
        ]
    },
    {
        "db_id": "film_rank",
        "query": "What is the average number of cities of markets with low film market estimate bigger than 10000?",
        "sql_query": "SELECT avg(T2.Number_cities) FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID WHERE T1.Low_Estimate  >  10000",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T2.Number_cities"
                }
            },
            "from": [
                {
                    "value": "film_market_estimation",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "market",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Market_ID",
                            "T2.Market_ID"
                        ]
                    }
                }
            ],
            "where": {
                "gt": [
                    "T1.Low_Estimate",
                    10000
                ]
            }
        },
        "sql_ans": [
            [
                209.0
            ]
        ],
        "cypher_query": "MATCH (T1:`film_rank.film_market_estimation`)-[]-(T2:`film_rank.market`)\nWHERE T1.Low_Estimate > 10000\nRETURN avg(T2.Number_cities)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "film_rank",
        "query": "Give the average number of cities within markets that had a low market estimation larger than 10000?",
        "sql_query": "SELECT avg(T2.Number_cities) FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.Market_ID  =  T2.Market_ID WHERE T1.Low_Estimate  >  10000",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T2.Number_cities"
                }
            },
            "from": [
                {
                    "value": "film_market_estimation",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "market",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Market_ID",
                            "T2.Market_ID"
                        ]
                    }
                }
            ],
            "where": {
                "gt": [
                    "T1.Low_Estimate",
                    10000
                ]
            }
        },
        "sql_ans": [
            [
                209.0
            ]
        ],
        "cypher_query": "MATCH (T1:`film_rank.film_market_estimation`)-[]-(T2:`film_rank.market`)\nWHERE T1.Low_Estimate > 10000\nRETURN avg(T2.Number_cities)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "film_rank",
        "query": "List the name of film studio that have the most number of films.",
        "sql_query": "SELECT Studio FROM film GROUP BY Studio ORDER BY COUNT(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "Studio"
            },
            "from": "film",
            "groupby": {
                "value": "Studio"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Paramount"
            ]
        ],
        "cypher_query": "MATCH (film:`film_rank.film`)\nWITH count(film.Studio) AS count, film.Studio AS Studio\nRETURN Studio\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Columbia"
            ]
        ]
    },
    {
        "db_id": "film_rank",
        "query": "What is the name of teh studio that created the most films?",
        "sql_query": "SELECT Studio FROM film GROUP BY Studio ORDER BY COUNT(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "Studio"
            },
            "from": "film",
            "groupby": {
                "value": "Studio"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Paramount"
            ]
        ],
        "cypher_query": "MATCH (film:`film_rank.film`)\nWITH count(film.Studio) AS count, film.Studio AS Studio\nRETURN Studio\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Columbia"
            ]
        ]
    },
    {
        "db_id": "film_rank",
        "query": "List the title of films that do not have any market estimation.",
        "sql_query": "SELECT Title FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation)",
        "parsed_sql": {
            "select": {
                "value": "Title"
            },
            "from": "film",
            "where": {
                "nin": [
                    "Film_ID",
                    {
                        "select": {
                            "value": "Film_ID"
                        },
                        "from": "film_market_estimation"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Porky's"
            ],
            [
                "Star Trek II: The Wrath of Khan"
            ],
            [
                "48 Hrs"
            ],
            [
                "Poltergeist"
            ],
            [
                "The Best Little Whorehouse in Texas"
            ],
            [
                "Annie"
            ],
            [
                "The Verdict"
            ],
            [
                "Gandhi"
            ],
            [
                "First Blood"
            ]
        ],
        "cypher_query": "MATCH (film:`film_rank.film`)\nWHERE NOT (film:`film_rank.film`)-[]-(:`film_rank.film_market_estimation`)\nRETURN film.Title",
        "cypher_ans": [
            [
                "ET the Extra-Terrestrial"
            ],
            [
                "Tootsie"
            ],
            [
                "An Officer and a Gentleman"
            ],
            [
                "Rocky III"
            ],
            [
                "Porky's"
            ],
            [
                "Star Trek II: The Wrath of Khan"
            ],
            [
                "48 Hrs"
            ],
            [
                "Poltergeist"
            ],
            [
                "The Best Little Whorehouse in Texas"
            ],
            [
                "Annie"
            ],
            [
                "The Verdict"
            ],
            [
                "Gandhi"
            ],
            [
                "First Blood"
            ]
        ]
    },
    {
        "db_id": "film_rank",
        "query": "What are the titles of films that do not have a film market estimation?",
        "sql_query": "SELECT Title FROM film WHERE Film_ID NOT IN (SELECT Film_ID FROM film_market_estimation)",
        "parsed_sql": {
            "select": {
                "value": "Title"
            },
            "from": "film",
            "where": {
                "nin": [
                    "Film_ID",
                    {
                        "select": {
                            "value": "Film_ID"
                        },
                        "from": "film_market_estimation"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Porky's"
            ],
            [
                "Star Trek II: The Wrath of Khan"
            ],
            [
                "48 Hrs"
            ],
            [
                "Poltergeist"
            ],
            [
                "The Best Little Whorehouse in Texas"
            ],
            [
                "Annie"
            ],
            [
                "The Verdict"
            ],
            [
                "Gandhi"
            ],
            [
                "First Blood"
            ]
        ],
        "cypher_query": "MATCH (film:`film_rank.film`)\nWHERE NOT (film:`film_rank.film`)-[]-(:`film_rank.film_market_estimation`)\nRETURN film.Title",
        "cypher_ans": [
            [
                "ET the Extra-Terrestrial"
            ],
            [
                "Tootsie"
            ],
            [
                "An Officer and a Gentleman"
            ],
            [
                "Rocky III"
            ],
            [
                "Porky's"
            ],
            [
                "Star Trek II: The Wrath of Khan"
            ],
            [
                "48 Hrs"
            ],
            [
                "Poltergeist"
            ],
            [
                "The Best Little Whorehouse in Texas"
            ],
            [
                "Annie"
            ],
            [
                "The Verdict"
            ],
            [
                "Gandhi"
            ],
            [
                "First Blood"
            ]
        ]
    },
    {
        "db_id": "film_rank",
        "query": "What are the titles and directors of the films were never presented in China?",
        "sql_query": "SELECT title ,  director FROM film WHERE film_id NOT IN (SELECT film_id FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.market_id  =  T2.Market_ID WHERE country  =  'China')",
        "parsed_sql": {
            "select": [
                {
                    "value": "title"
                },
                {
                    "value": "director"
                }
            ],
            "from": "film",
            "where": {
                "nin": [
                    "film_id",
                    {
                        "select": {
                            "value": "film_id"
                        },
                        "from": [
                            {
                                "value": "film_market_estimation",
                                "name": "T1",
                                "is_table": true
                            },
                            {
                                "join": {
                                    "name": "T2",
                                    "value": "market",
                                    "is_table": true
                                },
                                "on": {
                                    "eq": [
                                        "T1.market_id",
                                        "T2.Market_ID"
                                    ]
                                }
                            }
                        ],
                        "where": {
                            "eq": [
                                "country",
                                {
                                    "literal": "China"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "An Officer and a Gentleman",
                "Taylor Hackford"
            ],
            [
                "Porky's",
                "Bob Clark"
            ],
            [
                "Star Trek II: The Wrath of Khan",
                "Nicholas Meyer"
            ],
            [
                "48 Hrs",
                "Walter Hill"
            ],
            [
                "Poltergeist",
                "Tobe Hooper"
            ],
            [
                "The Best Little Whorehouse in Texas",
                "Colin Higgins"
            ],
            [
                "Annie",
                "John Huston"
            ],
            [
                "The Verdict",
                "Sidney Lumet"
            ],
            [
                "Gandhi",
                "Richard Attenborough"
            ],
            [
                "First Blood",
                "Ted Kotcheff"
            ]
        ],
        "cypher_query": "MATCH (film:`film_rank.film`)\nWHERE NOT (film:`film_rank.film`)-[]-(:`film_rank.film_market_estimation`)-[]-(:`film_rank.market { Country : 'China' }`)\nRETURN film.Title,film.Director",
        "cypher_ans": [
            [
                "ET the Extra-Terrestrial",
                "Steven Spielberg"
            ],
            [
                "Tootsie",
                "Sydney Pollack"
            ],
            [
                "An Officer and a Gentleman",
                "Taylor Hackford"
            ],
            [
                "Rocky III",
                "Sylvester Stallone"
            ],
            [
                "Porky's",
                "Bob Clark"
            ],
            [
                "Star Trek II: The Wrath of Khan",
                "Nicholas Meyer"
            ],
            [
                "48 Hrs",
                "Walter Hill"
            ],
            [
                "Poltergeist",
                "Tobe Hooper"
            ],
            [
                "The Best Little Whorehouse in Texas",
                "Colin Higgins"
            ],
            [
                "Annie",
                "John Huston"
            ],
            [
                "The Verdict",
                "Sidney Lumet"
            ],
            [
                "Gandhi",
                "Richard Attenborough"
            ],
            [
                "First Blood",
                "Ted Kotcheff"
            ]
        ]
    },
    {
        "db_id": "film_rank",
        "query": "Return the titles and directors of films that were never in the market of China.",
        "sql_query": "SELECT title ,  director FROM film WHERE film_id NOT IN (SELECT film_id FROM film_market_estimation AS T1 JOIN market AS T2 ON T1.market_id  =  T2.Market_ID WHERE country  =  'China')",
        "parsed_sql": {
            "select": [
                {
                    "value": "title"
                },
                {
                    "value": "director"
                }
            ],
            "from": "film",
            "where": {
                "nin": [
                    "film_id",
                    {
                        "select": {
                            "value": "film_id"
                        },
                        "from": [
                            {
                                "value": "film_market_estimation",
                                "name": "T1",
                                "is_table": true
                            },
                            {
                                "join": {
                                    "name": "T2",
                                    "value": "market",
                                    "is_table": true
                                },
                                "on": {
                                    "eq": [
                                        "T1.market_id",
                                        "T2.Market_ID"
                                    ]
                                }
                            }
                        ],
                        "where": {
                            "eq": [
                                "country",
                                {
                                    "literal": "China"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "An Officer and a Gentleman",
                "Taylor Hackford"
            ],
            [
                "Porky's",
                "Bob Clark"
            ],
            [
                "Star Trek II: The Wrath of Khan",
                "Nicholas Meyer"
            ],
            [
                "48 Hrs",
                "Walter Hill"
            ],
            [
                "Poltergeist",
                "Tobe Hooper"
            ],
            [
                "The Best Little Whorehouse in Texas",
                "Colin Higgins"
            ],
            [
                "Annie",
                "John Huston"
            ],
            [
                "The Verdict",
                "Sidney Lumet"
            ],
            [
                "Gandhi",
                "Richard Attenborough"
            ],
            [
                "First Blood",
                "Ted Kotcheff"
            ]
        ],
        "cypher_query": "MATCH (film:`film_rank.film`)\nWHERE NOT (film:`film_rank.film`)-[]-(:`film_rank.film_market_estimation`)-[]-(:`film_rank.market { Country : 'China' }`)\nRETURN film.Title,film.Director",
        "cypher_ans": [
            [
                "ET the Extra-Terrestrial",
                "Steven Spielberg"
            ],
            [
                "Tootsie",
                "Sydney Pollack"
            ],
            [
                "An Officer and a Gentleman",
                "Taylor Hackford"
            ],
            [
                "Rocky III",
                "Sylvester Stallone"
            ],
            [
                "Porky's",
                "Bob Clark"
            ],
            [
                "Star Trek II: The Wrath of Khan",
                "Nicholas Meyer"
            ],
            [
                "48 Hrs",
                "Walter Hill"
            ],
            [
                "Poltergeist",
                "Tobe Hooper"
            ],
            [
                "The Best Little Whorehouse in Texas",
                "Colin Higgins"
            ],
            [
                "Annie",
                "John Huston"
            ],
            [
                "The Verdict",
                "Sidney Lumet"
            ],
            [
                "Gandhi",
                "Richard Attenborough"
            ],
            [
                "First Blood",
                "Ted Kotcheff"
            ]
        ]
    },
    {
        "db_id": "tracking_grants_for_research",
        "query": "List the project details of the projects which did not hire any staff for a researcher role.",
        "sql_query": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )",
        "parsed_sql": {
            "select": {
                "value": "project_details"
            },
            "from": "Projects",
            "where": {
                "nin": [
                    "project_id",
                    {
                        "select": {
                            "value": "project_id"
                        },
                        "from": "Project_Staff",
                        "where": {
                            "eq": [
                                "role_code",
                                {
                                    "literal": "researcher"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "porro"
            ],
            [
                "sint"
            ],
            [
                "deserunt"
            ],
            [
                "consectetur"
            ],
            [
                "omnis"
            ],
            [
                "non"
            ],
            [
                "beatae"
            ],
            [
                "dolorem"
            ]
        ],
        "cypher_query": "MATCH (projects:`tracking_grants_for_research.Projects`)\nWHERE NOT (projects:`tracking_grants_for_research.Projects`)-[]-(:`tracking_grants_for_research.Project_Staff { role_code : 'researcher' }`)\nRETURN projects.project_details",
        "cypher_ans": [
            [
                "porro"
            ],
            [
                "et"
            ],
            [
                "sint"
            ],
            [
                "doloremque"
            ],
            [
                "vel"
            ],
            [
                "deserunt"
            ],
            [
                "deleniti"
            ],
            [
                "ad"
            ],
            [
                "sed"
            ],
            [
                "consectetur"
            ],
            [
                "impedit"
            ],
            [
                "omnis"
            ],
            [
                "non"
            ],
            [
                "beatae"
            ],
            [
                "dolorem"
            ]
        ]
    },
    {
        "db_id": "tracking_grants_for_research",
        "query": "What are the details for all projects that did not hire any staff in a research role?",
        "sql_query": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_Staff WHERE role_code  =  'researcher' )",
        "parsed_sql": {
            "select": {
                "value": "project_details"
            },
            "from": "Projects",
            "where": {
                "nin": [
                    "project_id",
                    {
                        "select": {
                            "value": "project_id"
                        },
                        "from": "Project_Staff",
                        "where": {
                            "eq": [
                                "role_code",
                                {
                                    "literal": "researcher"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "porro"
            ],
            [
                "sint"
            ],
            [
                "deserunt"
            ],
            [
                "consectetur"
            ],
            [
                "omnis"
            ],
            [
                "non"
            ],
            [
                "beatae"
            ],
            [
                "dolorem"
            ]
        ],
        "cypher_query": "MATCH (projects:`tracking_grants_for_research.Projects`)\nWHERE NOT (projects:`tracking_grants_for_research.Projects`)-[]-(:`tracking_grants_for_research.Project_Staff { role_code : 'researcher' }`)\nRETURN projects.project_details",
        "cypher_ans": [
            [
                "porro"
            ],
            [
                "et"
            ],
            [
                "sint"
            ],
            [
                "doloremque"
            ],
            [
                "vel"
            ],
            [
                "deserunt"
            ],
            [
                "deleniti"
            ],
            [
                "ad"
            ],
            [
                "sed"
            ],
            [
                "consectetur"
            ],
            [
                "impedit"
            ],
            [
                "omnis"
            ],
            [
                "non"
            ],
            [
                "beatae"
            ],
            [
                "dolorem"
            ]
        ]
    },
    {
        "db_id": "tracking_grants_for_research",
        "query": "Which projects have no outcome? List the project details.",
        "sql_query": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )",
        "parsed_sql": {
            "select": {
                "value": "project_details"
            },
            "from": "Projects",
            "where": {
                "nin": [
                    "project_id",
                    {
                        "select": {
                            "value": "project_id"
                        },
                        "from": "Project_outcomes"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "porro"
            ],
            [
                "et"
            ],
            [
                "ad"
            ],
            [
                "consectetur"
            ],
            [
                "dolorem"
            ]
        ],
        "cypher_query": "MATCH (projects:`tracking_grants_for_research.Projects`)\nWHERE NOT (projects:`tracking_grants_for_research.Projects`)-[]-(:`tracking_grants_for_research.Project_Outcomes`)\nRETURN projects.project_details",
        "cypher_ans": [
            [
                "porro"
            ],
            [
                "et"
            ],
            [
                "sint"
            ],
            [
                "doloremque"
            ],
            [
                "vel"
            ],
            [
                "deserunt"
            ],
            [
                "deleniti"
            ],
            [
                "ad"
            ],
            [
                "sed"
            ],
            [
                "consectetur"
            ],
            [
                "impedit"
            ],
            [
                "omnis"
            ],
            [
                "non"
            ],
            [
                "beatae"
            ],
            [
                "dolorem"
            ]
        ]
    },
    {
        "db_id": "tracking_grants_for_research",
        "query": "What are the details of the project with no outcomes?",
        "sql_query": "SELECT project_details FROM Projects WHERE project_id NOT IN ( SELECT project_id FROM Project_outcomes )",
        "parsed_sql": {
            "select": {
                "value": "project_details"
            },
            "from": "Projects",
            "where": {
                "nin": [
                    "project_id",
                    {
                        "select": {
                            "value": "project_id"
                        },
                        "from": "Project_outcomes"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "porro"
            ],
            [
                "et"
            ],
            [
                "ad"
            ],
            [
                "consectetur"
            ],
            [
                "dolorem"
            ]
        ],
        "cypher_query": "MATCH (projects:`tracking_grants_for_research.Projects`)\nWHERE NOT (projects:`tracking_grants_for_research.Projects`)-[]-(:`tracking_grants_for_research.Project_Outcomes`)\nRETURN projects.project_details",
        "cypher_ans": [
            [
                "porro"
            ],
            [
                "et"
            ],
            [
                "sint"
            ],
            [
                "doloremque"
            ],
            [
                "vel"
            ],
            [
                "deserunt"
            ],
            [
                "deleniti"
            ],
            [
                "ad"
            ],
            [
                "sed"
            ],
            [
                "consectetur"
            ],
            [
                "impedit"
            ],
            [
                "omnis"
            ],
            [
                "non"
            ],
            [
                "beatae"
            ],
            [
                "dolorem"
            ]
        ]
    },
    {
        "db_id": "tracking_grants_for_research",
        "query": "How many Patent outcomes are generated from all the projects?",
        "sql_query": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  'Patent'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Project_outcomes",
            "where": {
                "eq": [
                    "outcome_code",
                    {
                        "literal": "Patent"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (project_outcomes:`tracking_grants_for_research.Project_Outcomes`)\nWHERE project_outcomes.outcome_code = 'Patent'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "tracking_grants_for_research",
        "query": "How many patents outcomes were listed for all the projects?",
        "sql_query": "SELECT count(*) FROM Project_outcomes WHERE outcome_code  =  'Patent'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Project_outcomes",
            "where": {
                "eq": [
                    "outcome_code",
                    {
                        "literal": "Patent"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (project_outcomes:`tracking_grants_for_research.Project_Outcomes`)\nWHERE project_outcomes.outcome_code = 'Patent'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "network_2",
        "query": "What is the average age for each gender?",
        "sql_query": "SELECT avg(age) ,  gender FROM Person GROUP BY gender",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "age"
                    }
                },
                {
                    "value": "gender"
                }
            ],
            "from": "Person",
            "groupby": {
                "value": "gender"
            }
        },
        "sql_ans": [
            [
                25.5,
                "female"
            ],
            [
                40.0,
                "male"
            ]
        ],
        "cypher_query": "MATCH (person:`network_2.Person`)\nWITH person.gender AS gender, count(person.gender) AS count\nRETURN count,gender",
        "cypher_ans": [
            [
                2,
                "female"
            ],
            [
                2,
                "male"
            ]
        ]
    },
    {
        "db_id": "network_2",
        "query": "How old is each gender, on average?",
        "sql_query": "SELECT avg(age) ,  gender FROM Person GROUP BY gender",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "age"
                    }
                },
                {
                    "value": "gender"
                }
            ],
            "from": "Person",
            "groupby": {
                "value": "gender"
            }
        },
        "sql_ans": [
            [
                25.5,
                "female"
            ],
            [
                40.0,
                "male"
            ]
        ],
        "cypher_query": "MATCH (person:`network_2.Person`)\nWITH person.gender AS gender, count(person.gender) AS count\nRETURN count,gender",
        "cypher_ans": [
            [
                2,
                "female"
            ],
            [
                2,
                "male"
            ]
        ]
    },
    {
        "db_id": "network_2",
        "query": "What is average age for different job title?",
        "sql_query": "SELECT avg(age) ,  job FROM Person GROUP BY job",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "age"
                    }
                },
                {
                    "value": "job"
                }
            ],
            "from": "Person",
            "groupby": {
                "value": "job"
            }
        },
        "sql_ans": [
            [
                45.0,
                "doctor"
            ],
            [
                35.0,
                "engineer"
            ],
            [
                25.5,
                "student"
            ]
        ],
        "cypher_query": "MATCH (person:`network_2.Person`)\nWITH person.job AS job, count(person.job) AS count\nRETURN count,job",
        "cypher_ans": [
            [
                2,
                "student"
            ],
            [
                1,
                "engineer"
            ],
            [
                1,
                "doctor"
            ]
        ]
    },
    {
        "db_id": "network_2",
        "query": "How old is the average person for each job?",
        "sql_query": "SELECT avg(age) ,  job FROM Person GROUP BY job",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "age"
                    }
                },
                {
                    "value": "job"
                }
            ],
            "from": "Person",
            "groupby": {
                "value": "job"
            }
        },
        "sql_ans": [
            [
                45.0,
                "doctor"
            ],
            [
                35.0,
                "engineer"
            ],
            [
                25.5,
                "student"
            ]
        ],
        "cypher_query": "MATCH (person:`network_2.Person`)\nWITH person.job AS job, count(person.job) AS count\nRETURN count,job",
        "cypher_ans": [
            [
                2,
                "student"
            ],
            [
                1,
                "engineer"
            ],
            [
                1,
                "doctor"
            ]
        ]
    },
    {
        "db_id": "network_2",
        "query": "What is average age of male for different job title?",
        "sql_query": "SELECT avg(age) ,  job FROM Person WHERE gender  =  'male' GROUP BY job",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "age"
                    }
                },
                {
                    "value": "job"
                }
            ],
            "from": "Person",
            "where": {
                "eq": [
                    "gender",
                    {
                        "literal": "male"
                    }
                ]
            },
            "groupby": {
                "value": "job"
            }
        },
        "sql_ans": [
            [
                45.0,
                "doctor"
            ],
            [
                35.0,
                "engineer"
            ]
        ],
        "cypher_query": "MATCH (person:`network_2.Person`)\nWHERE person.gender = 'male'\nWITH person.job AS job, count(person.job) AS count\nRETURN count,job",
        "cypher_ans": [
            [
                1,
                "engineer"
            ],
            [
                1,
                "doctor"
            ]
        ]
    },
    {
        "db_id": "network_2",
        "query": "What is the average age for a male in each job?",
        "sql_query": "SELECT avg(age) ,  job FROM Person WHERE gender  =  'male' GROUP BY job",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "age"
                    }
                },
                {
                    "value": "job"
                }
            ],
            "from": "Person",
            "where": {
                "eq": [
                    "gender",
                    {
                        "literal": "male"
                    }
                ]
            },
            "groupby": {
                "value": "job"
            }
        },
        "sql_ans": [
            [
                45.0,
                "doctor"
            ],
            [
                35.0,
                "engineer"
            ]
        ],
        "cypher_query": "MATCH (person:`network_2.Person`)\nWHERE person.gender = 'male'\nWITH person.job AS job, count(person.job) AS count\nRETURN count,job",
        "cypher_ans": [
            [
                1,
                "engineer"
            ],
            [
                1,
                "doctor"
            ]
        ]
    },
    {
        "db_id": "network_2",
        "query": "What is minimum age for different job title?",
        "sql_query": "SELECT min(age) ,  job FROM Person GROUP BY job",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "min": "age"
                    }
                },
                {
                    "value": "job"
                }
            ],
            "from": "Person",
            "groupby": {
                "value": "job"
            }
        },
        "sql_ans": [
            [
                45,
                "doctor"
            ],
            [
                35,
                "engineer"
            ],
            [
                25,
                "student"
            ]
        ],
        "cypher_query": "MATCH (person:`network_2.Person`)\nWITH person.job AS job, count(person.job) AS count\nRETURN count,job",
        "cypher_ans": [
            [
                2,
                "student"
            ],
            [
                1,
                "engineer"
            ],
            [
                1,
                "doctor"
            ]
        ]
    },
    {
        "db_id": "network_2",
        "query": "How old is the youngest person for each job?",
        "sql_query": "SELECT min(age) ,  job FROM Person GROUP BY job",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "min": "age"
                    }
                },
                {
                    "value": "job"
                }
            ],
            "from": "Person",
            "groupby": {
                "value": "job"
            }
        },
        "sql_ans": [
            [
                45,
                "doctor"
            ],
            [
                35,
                "engineer"
            ],
            [
                25,
                "student"
            ]
        ],
        "cypher_query": "MATCH (person:`network_2.Person`)\nWITH person.job AS job, count(person.job) AS count\nRETURN count,job",
        "cypher_ans": [
            [
                2,
                "student"
            ],
            [
                1,
                "engineer"
            ],
            [
                1,
                "doctor"
            ]
        ]
    },
    {
        "db_id": "document_management",
        "query": "List all the username and passwords of users with the most popular role.",
        "sql_query": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "user_name"
                },
                {
                    "value": "password"
                }
            ],
            "from": "users",
            "groupby": {
                "value": "role_code"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "tremblay.raheem",
                "9bc25a040d5647ced5ec32e1a455e90fafc10bcb"
            ]
        ],
        "cypher_query": "MATCH (users:`document_management.Users`)\nWITH users.password AS password, count(users.role_code) AS count, users.user_name AS user_name\nRETURN user_name,password\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "dickens.elta",
                "e72b5a2d50b39a8760764a5f7a9d68ca2f076877"
            ]
        ]
    },
    {
        "db_id": "document_management",
        "query": "What are the usernames and passwords of users that have the most common role?",
        "sql_query": "SELECT user_name ,  password FROM users GROUP BY role_code ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "user_name"
                },
                {
                    "value": "password"
                }
            ],
            "from": "users",
            "groupby": {
                "value": "role_code"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "tremblay.raheem",
                "9bc25a040d5647ced5ec32e1a455e90fafc10bcb"
            ]
        ],
        "cypher_query": "MATCH (users:`document_management.Users`)\nWITH users.password AS password, count(users.role_code) AS count, users.user_name AS user_name\nRETURN user_name,password\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "dickens.elta",
                "e72b5a2d50b39a8760764a5f7a9d68ca2f076877"
            ]
        ]
    },
    {
        "db_id": "document_management",
        "query": "How many users are logged in?",
        "sql_query": "SELECT count(*) FROM users WHERE user_login  =  1",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "users",
            "where": {
                "eq": [
                    "user_login",
                    1
                ]
            }
        },
        "sql_ans": [
            [
                7
            ]
        ],
        "cypher_query": "MATCH (users:`document_management.Users`)\nWHERE users.user_login = 1\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "document_management",
        "query": "Count the number of users that are logged in.",
        "sql_query": "SELECT count(*) FROM users WHERE user_login  =  1",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "users",
            "where": {
                "eq": [
                    "user_login",
                    1
                ]
            }
        },
        "sql_ans": [
            [
                7
            ]
        ],
        "cypher_query": "MATCH (users:`document_management.Users`)\nWHERE users.user_login = 1\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "company_office",
        "query": "What are the average profits of companies?",
        "sql_query": "SELECT avg(Profits_billion) FROM Companies",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "Profits_billion"
                }
            },
            "from": "Companies"
        },
        "sql_ans": [
            [
                17.063157894736843
            ]
        ],
        "cypher_query": "MATCH (companies:`company_office.Companies`)\nRETURN avg(companies.Profits_billion)",
        "cypher_ans": [
            [
                17.06315789473684
            ]
        ]
    },
    {
        "db_id": "company_office",
        "query": "Compute the average profits companies make.",
        "sql_query": "SELECT avg(Profits_billion) FROM Companies",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "Profits_billion"
                }
            },
            "from": "Companies"
        },
        "sql_ans": [
            [
                17.063157894736843
            ]
        ],
        "cypher_query": "MATCH (companies:`company_office.Companies`)\nRETURN avg(companies.Profits_billion)",
        "cypher_ans": [
            [
                17.06315789473684
            ]
        ]
    },
    {
        "db_id": "company_office",
        "query": "Show the name of the building that has the most company offices.",
        "sql_query": "SELECT T2.name FROM Office_locations AS T1 JOIN buildings AS T2 ON T1.building_id  =  T2.id JOIN Companies AS T3 ON T1.company_id  =  T3.id GROUP BY T1.building_id ORDER BY COUNT(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T2.name"
            },
            "from": [
                {
                    "value": "Office_locations",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "buildings",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.building_id",
                            "T2.id"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "Companies",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.company_id",
                            "T3.id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.building_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Punto Chapultepec"
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`company_office.Office_locations`]-(T2:`company_office.buildings`)-[]-(T3:`company_office.Companies`)\nWITH T2.name AS name, count(T1.building_id) AS count\nRETURN name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Torre Mitikah"
            ]
        ]
    },
    {
        "db_id": "company_office",
        "query": "Which building has the largest number of company offices? Give me the building name.",
        "sql_query": "SELECT T2.name FROM Office_locations AS T1 JOIN buildings AS T2 ON T1.building_id  =  T2.id JOIN Companies AS T3 ON T1.company_id  =  T3.id GROUP BY T1.building_id ORDER BY COUNT(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T2.name"
            },
            "from": [
                {
                    "value": "Office_locations",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "buildings",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.building_id",
                            "T2.id"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "Companies",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.company_id",
                            "T3.id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.building_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Punto Chapultepec"
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`company_office.Office_locations`]-(T2:`company_office.buildings`)-[]-(T3:`company_office.Companies`)\nWITH T2.name AS name, count(T1.building_id) AS count\nRETURN name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Torre Mitikah"
            ]
        ]
    },
    {
        "db_id": "solvency_ii",
        "query": "What is the average price for products?",
        "sql_query": "SELECT avg(Product_Price) FROM Products",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "Product_Price"
                }
            },
            "from": "Products"
        },
        "sql_ans": [
            [
                2852.7806666666665
            ]
        ],
        "cypher_query": "MATCH (products:`solvency_ii.Products`)\nRETURN avg(products.Product_Price)",
        "cypher_ans": [
            [
                2852.780666666667
            ]
        ]
    },
    {
        "db_id": "solvency_ii",
        "query": "List the names of products that are not in any event.",
        "sql_query": "SELECT Product_Name FROM Products WHERE Product_ID NOT IN (SELECT Product_ID FROM Products_in_Events)",
        "parsed_sql": {
            "select": {
                "value": "Product_Name"
            },
            "from": "Products",
            "where": {
                "nin": [
                    "Product_ID",
                    {
                        "select": {
                            "value": "Product_ID"
                        },
                        "from": "Products_in_Events"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Business Policy"
            ],
            [
                "Men suits"
            ],
            [
                "Business Policy B"
            ],
            [
                "Dinning"
            ],
            [
                "Dinning"
            ]
        ],
        "cypher_query": "MATCH (products:`solvency_ii.Products`)\nWHERE NOT (products:`solvency_ii.Products`)-[]-(:`solvency_ii.Products_in_Events`)\nRETURN products.Product_Name",
        "cypher_ans": [
            [
                "Business Policy"
            ],
            [
                "Special Dinning"
            ],
            [
                "Men suits"
            ],
            [
                "TV Equipments"
            ],
            [
                "Business Policy B"
            ],
            [
                "TV Equipments"
            ],
            [
                "Conference Equipments"
            ],
            [
                "Trading Policy"
            ],
            [
                "Trading Policy B"
            ],
            [
                "Dinning"
            ],
            [
                "Dinning"
            ],
            [
                "Dinning"
            ],
            [
                "Special Dinning"
            ],
            [
                "TV Equipments"
            ],
            [
                "Men suits"
            ]
        ]
    },
    {
        "db_id": "entertainment_awards",
        "query": "Show the names of the three most recent festivals.",
        "sql_query": "SELECT Festival_Name FROM festival_detail ORDER BY YEAR DESC LIMIT 3",
        "parsed_sql": {
            "select": {
                "value": "Festival_Name"
            },
            "from": "festival_detail",
            "orderby": {
                "value": "YEAR",
                "sort": "desc"
            },
            "limit": 3
        },
        "sql_ans": [
            [
                "LA Awards"
            ],
            [
                "Gobel Awards"
            ],
            [
                "Flower Awards"
            ]
        ],
        "cypher_query": "MATCH (festival_detail:`entertainment_awards.festival_detail`)\nRETURN festival_detail.Festival_Name\nORDER BY festival_detail.Year DESC\nLIMIT 3",
        "cypher_ans": [
            [
                "LA Awards"
            ],
            [
                "Gobel Awards"
            ],
            [
                "Cherry Awards"
            ]
        ]
    },
    {
        "db_id": "customers_campaigns_ecommerce",
        "query": "Show the name and phone of the customer without any mailshot.",
        "sql_query": "SELECT customer_name ,  customer_phone FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM mailshot_customers)",
        "parsed_sql": {
            "select": [
                {
                    "value": "customer_name"
                },
                {
                    "value": "customer_phone"
                }
            ],
            "from": "customers",
            "where": {
                "nin": [
                    "customer_id",
                    {
                        "select": {
                            "value": "customer_id"
                        },
                        "from": "mailshot_customers"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Magdalena",
                "1-352-291-1721x265"
            ],
            [
                "Leanna",
                "203-036-0511x96487"
            ],
            [
                "Ruthie",
                "(840)754-4148x20545"
            ],
            [
                "Shanel",
                "1-957-676-9414"
            ],
            [
                "Kyle",
                "291-425-7193"
            ],
            [
                "Mitchell",
                "698-327-5792"
            ]
        ],
        "cypher_query": "MATCH (customers:`customers_campaigns_ecommerce.Customers`)\nWHERE NOT (customers:`customers_campaigns_ecommerce.Customers`)-[]-(:`customers_campaigns_ecommerce.Mailshot_Customers`)\nRETURN customers.customer_name,customers.customer_phone",
        "cypher_ans": [
            [
                "Wendell",
                "(773)971-9411x759"
            ],
            [
                "Gage",
                "(402)890-2603x6005"
            ],
            [
                "Elvera",
                "1-878-600-7193x8180"
            ],
            [
                "Stella",
                "+43(3)1861877192"
            ],
            [
                "Magdalena",
                "1-352-291-1721x265"
            ],
            [
                "Carlotta",
                "+66(7)1491041398"
            ],
            [
                "Leanna",
                "203-036-0511x96487"
            ],
            [
                "Ruthie",
                "(840)754-4148x20545"
            ],
            [
                "Donnie",
                "(030)521-0681x0191"
            ],
            [
                "Shanel",
                "1-957-676-9414"
            ],
            [
                "Osborne",
                "232.171.7032"
            ],
            [
                "Kyle",
                "291-425-7193"
            ],
            [
                "Annabel",
                "100.220.3484"
            ],
            [
                "Geovanny",
                "205.496.0690x53058"
            ],
            [
                "Mitchell",
                "698-327-5792"
            ]
        ]
    },
    {
        "db_id": "college_3",
        "query": "Find the rank of the faculty that the fewest faculties belong to.",
        "sql_query": "SELECT Rank FROM FACULTY GROUP BY Rank ORDER BY count(*) ASC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "Rank"
            },
            "from": "FACULTY",
            "groupby": {
                "value": "Rank"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "asc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "AssocProf"
            ]
        ],
        "cypher_query": "MATCH (faculty:`college_3.Faculty`)\nWITH count(faculty.Rank) AS count, faculty.Rank AS Rank\nRETURN Rank\nORDER BY count ASC\nLIMIT 1",
        "cypher_ans": [
            [
                "Instructor"
            ]
        ]
    },
    {
        "db_id": "college_3",
        "query": "What is the least common faculty rank?",
        "sql_query": "SELECT Rank FROM FACULTY GROUP BY Rank ORDER BY count(*) ASC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "Rank"
            },
            "from": "FACULTY",
            "groupby": {
                "value": "Rank"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "asc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "AssocProf"
            ]
        ],
        "cypher_query": "MATCH (faculty:`college_3.Faculty`)\nWITH count(faculty.Rank) AS count, faculty.Rank AS Rank\nRETURN Rank\nORDER BY count ASC\nLIMIT 1",
        "cypher_ans": [
            [
                "Instructor"
            ]
        ]
    },
    {
        "db_id": "department_store",
        "query": "What is the average price for each type of product?",
        "sql_query": "SELECT product_type_code ,  avg(product_price) FROM products GROUP BY product_type_code",
        "parsed_sql": {
            "select": [
                {
                    "value": "product_type_code"
                },
                {
                    "value": {
                        "avg": "product_price"
                    }
                }
            ],
            "from": "products",
            "groupby": {
                "value": "product_type_code"
            }
        },
        "sql_ans": [
            [
                "Clothes",
                715.5366666666666
            ],
            [
                "Hardware",
                796.0416666666666
            ]
        ],
        "cypher_query": "MATCH (products:`department_store.Products`)\nWITH products.product_type_code AS product_type_code, count(products.product_type_code) AS count\nRETURN product_type_code,count",
        "cypher_ans": [
            [
                "Clothes",
                9
            ],
            [
                "Hardware",
                6
            ]
        ]
    },
    {
        "db_id": "department_store",
        "query": "Return the average price for each product type.",
        "sql_query": "SELECT product_type_code ,  avg(product_price) FROM products GROUP BY product_type_code",
        "parsed_sql": {
            "select": [
                {
                    "value": "product_type_code"
                },
                {
                    "value": {
                        "avg": "product_price"
                    }
                }
            ],
            "from": "products",
            "groupby": {
                "value": "product_type_code"
            }
        },
        "sql_ans": [
            [
                "Clothes",
                715.5366666666666
            ],
            [
                "Hardware",
                796.0416666666666
            ]
        ],
        "cypher_query": "MATCH (products:`department_store.Products`)\nWITH products.product_type_code AS product_type_code, count(products.product_type_code) AS count\nRETURN product_type_code,count",
        "cypher_ans": [
            [
                "Clothes",
                9
            ],
            [
                "Hardware",
                6
            ]
        ]
    },
    {
        "db_id": "department_store",
        "query": "What is the id of the department with the least number of staff?",
        "sql_query": "SELECT department_id FROM staff_department_assignments GROUP BY department_id ORDER BY count(*) LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "department_id"
            },
            "from": "staff_department_assignments",
            "groupby": {
                "value": "department_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                }
            },
            "limit": 1
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH ()-[staff_department_assignments:`department_store.Staff_Department_Assignments`]-()\nWITH count(staff_department_assignments.department_id) AS count, staff_department_assignments.department_id AS department_id\nRETURN department_id\nORDER BY count\nLIMIT 1",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "department_store",
        "query": "Return the id of the department with the fewest staff assignments.",
        "sql_query": "SELECT department_id FROM staff_department_assignments GROUP BY department_id ORDER BY count(*) LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "department_id"
            },
            "from": "staff_department_assignments",
            "groupby": {
                "value": "department_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                }
            },
            "limit": 1
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH ()-[staff_department_assignments:`department_store.Staff_Department_Assignments`]-()\nWITH count(staff_department_assignments.department_id) AS count, staff_department_assignments.department_id AS department_id\nRETURN department_id\nORDER BY count\nLIMIT 1",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "aircraft",
        "query": "List the names of aircrafts and that did not win any match.",
        "sql_query": "SELECT Aircraft FROM aircraft WHERE Aircraft_ID NOT IN (SELECT Winning_Aircraft FROM MATCH)",
        "parsed_sql": {
            "select": {
                "value": "Aircraft"
            },
            "from": "aircraft",
            "where": {
                "nin": [
                    "Aircraft_ID",
                    {
                        "select": {
                            "value": "Winning_Aircraft"
                        },
                        "from": "MATCH"
                    }
                ]
            }
        },
        "sql_ans": [],
        "cypher_query": "MATCH (aircraft:`aircraft.aircraft`)\nWHERE NOT (aircraft:`aircraft.aircraft`)-[]-(:`aircraft.match`)\nRETURN aircraft.Aircraft",
        "cypher_ans": [
            [
                "Robinson R-22"
            ],
            [
                "Bell 206B3 JetRanger"
            ],
            [
                "CH-47D Chinook"
            ],
            [
                "Mil Mi-26"
            ],
            [
                "CH-53E Super Stallion"
            ]
        ]
    },
    {
        "db_id": "aircraft",
        "query": "What are the names of all aicrafts that have never won any match?",
        "sql_query": "SELECT Aircraft FROM aircraft WHERE Aircraft_ID NOT IN (SELECT Winning_Aircraft FROM MATCH)",
        "parsed_sql": {
            "select": {
                "value": "Aircraft"
            },
            "from": "aircraft",
            "where": {
                "nin": [
                    "Aircraft_ID",
                    {
                        "select": {
                            "value": "Winning_Aircraft"
                        },
                        "from": "MATCH"
                    }
                ]
            }
        },
        "sql_ans": [],
        "cypher_query": "MATCH (aircraft:`aircraft.aircraft`)\nWHERE NOT (aircraft:`aircraft.aircraft`)-[]-(:`aircraft.match`)\nRETURN aircraft.Aircraft",
        "cypher_ans": [
            [
                "Robinson R-22"
            ],
            [
                "Bell 206B3 JetRanger"
            ],
            [
                "CH-47D Chinook"
            ],
            [
                "Mil Mi-26"
            ],
            [
                "CH-53E Super Stallion"
            ]
        ]
    },
    {
        "db_id": "aircraft",
        "query": "find the name of pilots who did not win the matches held in the country of Australia.",
        "sql_query": "SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "parsed_sql": {
            "select": {
                "value": "name"
            },
            "from": "pilot",
            "where": {
                "nin": [
                    "pilot_id",
                    {
                        "select": {
                            "value": "Winning_Pilot"
                        },
                        "from": "MATCH",
                        "where": {
                            "eq": [
                                "country",
                                {
                                    "literal": "Australia"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Prof. Zackery Collins"
            ],
            [
                "Katheryn Gorczany IV"
            ],
            [
                "Mr. Cristian Halvorson II"
            ],
            [
                "Ellen Ledner III"
            ],
            [
                "Elisha Hickle V"
            ],
            [
                "Dr. Jade Bradtke V"
            ],
            [
                "Winnifred Boyle"
            ],
            [
                "Della Lindgren"
            ],
            [
                "Maxwell Graham"
            ],
            [
                "Blaise Muller"
            ],
            [
                "Baylee Steuber"
            ]
        ],
        "cypher_query": "MATCH (pilot:`aircraft.pilot`)\nWHERE NOT (pilot:`aircraft.pilot`)-[]-(:`aircraft.match { Country : 'Australia' }`)\nRETURN pilot.Name",
        "cypher_ans": [
            [
                "Prof. Zackery Collins"
            ],
            [
                "Katheryn Gorczany IV"
            ],
            [
                "Mr. Cristian Halvorson II"
            ],
            [
                "Ayana Spencer"
            ],
            [
                "Ellen Ledner III"
            ],
            [
                "Elisha Hickle V"
            ],
            [
                "Dr. Jade Bradtke V"
            ],
            [
                "Winnifred Boyle"
            ],
            [
                "Della Lindgren"
            ],
            [
                "Maxwell Graham"
            ],
            [
                "Blaise Muller"
            ],
            [
                "Baylee Steuber"
            ]
        ]
    },
    {
        "db_id": "aircraft",
        "query": "What are the names of the pilots that have not won any matches in Australia?",
        "sql_query": "SELECT name FROM pilot WHERE pilot_id NOT IN (SELECT Winning_Pilot  FROM MATCH WHERE country  =  'Australia')",
        "parsed_sql": {
            "select": {
                "value": "name"
            },
            "from": "pilot",
            "where": {
                "nin": [
                    "pilot_id",
                    {
                        "select": {
                            "value": "Winning_Pilot"
                        },
                        "from": "MATCH",
                        "where": {
                            "eq": [
                                "country",
                                {
                                    "literal": "Australia"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Prof. Zackery Collins"
            ],
            [
                "Katheryn Gorczany IV"
            ],
            [
                "Mr. Cristian Halvorson II"
            ],
            [
                "Ellen Ledner III"
            ],
            [
                "Elisha Hickle V"
            ],
            [
                "Dr. Jade Bradtke V"
            ],
            [
                "Winnifred Boyle"
            ],
            [
                "Della Lindgren"
            ],
            [
                "Maxwell Graham"
            ],
            [
                "Blaise Muller"
            ],
            [
                "Baylee Steuber"
            ]
        ],
        "cypher_query": "MATCH (pilot:`aircraft.pilot`)\nWHERE NOT (pilot:`aircraft.pilot`)-[]-(:`aircraft.match { Country : 'Australia' }`)\nRETURN pilot.Name",
        "cypher_ans": [
            [
                "Prof. Zackery Collins"
            ],
            [
                "Katheryn Gorczany IV"
            ],
            [
                "Mr. Cristian Halvorson II"
            ],
            [
                "Ayana Spencer"
            ],
            [
                "Ellen Ledner III"
            ],
            [
                "Elisha Hickle V"
            ],
            [
                "Dr. Jade Bradtke V"
            ],
            [
                "Winnifred Boyle"
            ],
            [
                "Della Lindgren"
            ],
            [
                "Maxwell Graham"
            ],
            [
                "Blaise Muller"
            ],
            [
                "Baylee Steuber"
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "How many different colleges do attend the tryout test?",
        "sql_query": "SELECT count(DISTINCT cName) FROM tryout",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "cName"
                        }
                    }
                }
            },
            "from": "tryout"
        },
        "sql_ans": [
            [
                4
            ]
        ],
        "cypher_query": "MATCH ()-[tryout:`soccer_2.Tryout`]-()\nRETURN count(DISTINCT tryout.cName)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "How many different colleges were represented at tryouts?",
        "sql_query": "SELECT count(DISTINCT cName) FROM tryout",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "cName"
                        }
                    }
                }
            },
            "from": "tryout"
        },
        "sql_ans": [
            [
                4
            ]
        ],
        "cypher_query": "MATCH ()-[tryout:`soccer_2.Tryout`]-()\nRETURN count(DISTINCT tryout.cName)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "How many students got accepted after the tryout?",
        "sql_query": "SELECT count(*) FROM tryout WHERE decision  =  'yes'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "tryout",
            "where": {
                "eq": [
                    "decision",
                    {
                        "literal": "yes"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH ()-[tryout:`soccer_2.Tryout`]-()\nWHERE tryout.decision = 'yes'\nRETURN count(*)",
        "cypher_ans": [
            [
                4
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "How many students received a yes from tryouts?",
        "sql_query": "SELECT count(*) FROM tryout WHERE decision  =  'yes'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "tryout",
            "where": {
                "eq": [
                    "decision",
                    {
                        "literal": "yes"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH ()-[tryout:`soccer_2.Tryout`]-()\nWHERE tryout.decision = 'yes'\nRETURN count(*)",
        "cypher_ans": [
            [
                4
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "How many students whose are playing the role of goalie?",
        "sql_query": "SELECT count(*) FROM tryout WHERE pPos  =  'goalie'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "tryout",
            "where": {
                "eq": [
                    "pPos",
                    {
                        "literal": "goalie"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH ()-[tryout:`soccer_2.Tryout`]-()\nWHERE tryout.pPos = 'goalie'\nRETURN count(*)",
        "cypher_ans": [
            [
                6
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "What is the number of students playing as a goalie?",
        "sql_query": "SELECT count(*) FROM tryout WHERE pPos  =  'goalie'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "tryout",
            "where": {
                "eq": [
                    "pPos",
                    {
                        "literal": "goalie"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH ()-[tryout:`soccer_2.Tryout`]-()\nWHERE tryout.pPos = 'goalie'\nRETURN count(*)",
        "cypher_ans": [
            [
                6
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "Find the name of different colleges involved in the tryout in alphabetical order.",
        "sql_query": "SELECT DISTINCT cName FROM tryout ORDER BY cName",
        "parsed_sql": {
            "select": {
                "value": {
                    "distinct": {
                        "value": "cName"
                    }
                }
            },
            "from": "tryout",
            "orderby": {
                "value": "cName"
            }
        },
        "sql_ans": [
            [
                "ASU"
            ],
            [
                "FSU"
            ],
            [
                "LSU"
            ],
            [
                "OU"
            ]
        ],
        "cypher_query": "MATCH ()-[tryout:`soccer_2.Tryout`]-()\nRETURN DISTINCT tryout.cName\nORDER BY tryout.cName",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "What are the different names of the colleges involved in the tryout in alphabetical order?",
        "sql_query": "SELECT DISTINCT cName FROM tryout ORDER BY cName",
        "parsed_sql": {
            "select": {
                "value": {
                    "distinct": {
                        "value": "cName"
                    }
                }
            },
            "from": "tryout",
            "orderby": {
                "value": "cName"
            }
        },
        "sql_ans": [
            [
                "ASU"
            ],
            [
                "FSU"
            ],
            [
                "LSU"
            ],
            [
                "OU"
            ]
        ],
        "cypher_query": "MATCH ()-[tryout:`soccer_2.Tryout`]-()\nRETURN DISTINCT tryout.cName\nORDER BY tryout.cName",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "Find the number of students who participate in the tryout for each college ordered by descending count.",
        "sql_query": "SELECT count(*) ,  cName FROM tryout GROUP BY cName ORDER BY count(*) DESC",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "count": "*"
                    }
                },
                {
                    "value": "cName"
                }
            ],
            "from": "tryout",
            "groupby": {
                "value": "cName"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            }
        },
        "sql_ans": [
            [
                2,
                "LSU"
            ],
            [
                2,
                "ASU"
            ],
            [
                1,
                "OU"
            ],
            [
                1,
                "FSU"
            ]
        ],
        "cypher_query": "MATCH ()-[tryout:`soccer_2.Tryout`]-()\nWITH count(tryout.cName) AS count, tryout.cName AS cName\nRETURN count,cName\nORDER BY count DESC",
        "cypher_ans": [
            [
                0,
                null
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "How many students participated in tryouts for each college by descennding count?",
        "sql_query": "SELECT count(*) ,  cName FROM tryout GROUP BY cName ORDER BY count(*) DESC",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "count": "*"
                    }
                },
                {
                    "value": "cName"
                }
            ],
            "from": "tryout",
            "groupby": {
                "value": "cName"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            }
        },
        "sql_ans": [
            [
                2,
                "LSU"
            ],
            [
                2,
                "ASU"
            ],
            [
                1,
                "OU"
            ],
            [
                1,
                "FSU"
            ]
        ],
        "cypher_query": "MATCH ()-[tryout:`soccer_2.Tryout`]-()\nWITH count(tryout.cName) AS count, tryout.cName AS cName\nRETURN count,cName\nORDER BY count DESC",
        "cypher_ans": [
            [
                0,
                null
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "What is minimum hours of the students playing in different position?",
        "sql_query": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "min": "T2.HS"
                    }
                },
                {
                    "value": "T1.pPos"
                }
            ],
            "from": [
                {
                    "value": "tryout",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "player",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.pID",
                            "T2.pID"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.pPos"
            }
        },
        "sql_ans": [
            [
                1200,
                "goalie"
            ],
            [
                300,
                "mid"
            ],
            [
                1600,
                "striker"
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`soccer_2.Tryout`]-(T2:`soccer_2.Player`)\nWITH T1.pPos AS pPos, count(T1.pPos) AS count\nRETURN count,pPos",
        "cypher_ans": [
            [
                3,
                "goalie"
            ],
            [
                1,
                "striker"
            ],
            [
                2,
                "mid"
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "For each position, what is the minimum time students spent practicing?",
        "sql_query": "SELECT min(T2.HS) ,   T1.pPos FROM tryout AS T1 JOIN player AS T2 ON T1.pID  =  T2.pID GROUP BY T1.pPos",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "min": "T2.HS"
                    }
                },
                {
                    "value": "T1.pPos"
                }
            ],
            "from": [
                {
                    "value": "tryout",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "player",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.pID",
                            "T2.pID"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.pPos"
            }
        },
        "sql_ans": [
            [
                1200,
                "goalie"
            ],
            [
                300,
                "mid"
            ],
            [
                1600,
                "striker"
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`soccer_2.Tryout`]-(T2:`soccer_2.Player`)\nWITH T1.pPos AS pPos, count(T1.pPos) AS count\nRETURN count,pPos",
        "cypher_ans": [
            [
                3,
                "goalie"
            ],
            [
                1,
                "striker"
            ],
            [
                2,
                "mid"
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "What is the name of school that has the smallest enrollment in each state?",
        "sql_query": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state",
        "parsed_sql": {
            "select": [
                {
                    "value": "cName"
                },
                {
                    "value": "state"
                },
                {
                    "value": {
                        "min": "enr"
                    }
                }
            ],
            "from": "college",
            "groupby": {
                "value": "state"
            }
        },
        "sql_ans": [
            [
                "ASU",
                "AZ",
                12000
            ],
            [
                "FSU",
                "FL",
                19000
            ],
            [
                "LSU",
                "LA",
                18000
            ],
            [
                "OU",
                "OK",
                22000
            ]
        ],
        "cypher_query": "MATCH (college:`soccer_2.College`)\nWITH college.cName AS cName, college.state AS state, count(college.state) AS count\nRETURN cName,state,count",
        "cypher_ans": [
            [
                "LSU",
                "LA",
                1
            ],
            [
                "ASU",
                "AZ",
                1
            ],
            [
                "OU",
                "OK",
                1
            ],
            [
                "FSU",
                "FL",
                1
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "What is the name of the school with smallest enrollment size per state?",
        "sql_query": "SELECT cName ,  state ,  min(enr) FROM college GROUP BY state",
        "parsed_sql": {
            "select": [
                {
                    "value": "cName"
                },
                {
                    "value": "state"
                },
                {
                    "value": {
                        "min": "enr"
                    }
                }
            ],
            "from": "college",
            "groupby": {
                "value": "state"
            }
        },
        "sql_ans": [
            [
                "ASU",
                "AZ",
                12000
            ],
            [
                "FSU",
                "FL",
                19000
            ],
            [
                "LSU",
                "LA",
                18000
            ],
            [
                "OU",
                "OK",
                22000
            ]
        ],
        "cypher_query": "MATCH (college:`soccer_2.College`)\nWITH college.cName AS cName, college.state AS state, count(college.state) AS count\nRETURN cName,state,count",
        "cypher_ans": [
            [
                "LSU",
                "LA",
                1
            ],
            [
                "ASU",
                "AZ",
                1
            ],
            [
                "OU",
                "OK",
                1
            ],
            [
                "FSU",
                "FL",
                1
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "Find the name and college of students whose decisions are yes in the tryout.",
        "sql_query": "SELECT T1.pName ,  T2.cName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'",
        "parsed_sql": {
            "select": [
                {
                    "value": "T1.pName"
                },
                {
                    "value": "T2.cName"
                }
            ],
            "from": [
                {
                    "value": "player",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "tryout",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.pID",
                            "T2.pID"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.decision",
                    {
                        "literal": "yes"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Andrew",
                "ASU"
            ],
            [
                "Blake",
                "FSU"
            ]
        ],
        "cypher_query": "MATCH (T1:`soccer_2.Player`)-[T2:`soccer_2.Tryout`]-()\nWHERE T2.decision = 'yes'\nRETURN T1.pName,T2.cName",
        "cypher_ans": [
            [
                "Andrew",
                null
            ],
            [
                "Blake",
                null
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "What are the names of all the players who received a yes during tryouts, and also what are the names of their colleges?",
        "sql_query": "SELECT T1.pName ,  T2.cName FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T2.decision  =  'yes'",
        "parsed_sql": {
            "select": [
                {
                    "value": "T1.pName"
                },
                {
                    "value": "T2.cName"
                }
            ],
            "from": [
                {
                    "value": "player",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "tryout",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.pID",
                            "T2.pID"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.decision",
                    {
                        "literal": "yes"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Andrew",
                "ASU"
            ],
            [
                "Blake",
                "FSU"
            ]
        ],
        "cypher_query": "MATCH (T1:`soccer_2.Player`)-[T2:`soccer_2.Tryout`]-()\nWHERE T2.decision = 'yes'\nRETURN T1.pName,T2.cName",
        "cypher_ans": [
            [
                "Andrew",
                null
            ],
            [
                "Blake",
                null
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "What is the maximum training hours for the students whose training hours is greater than 1000 in different positions?",
        "sql_query": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  1000 GROUP BY T2.pPos",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "T1.HS"
                    }
                },
                {
                    "value": "pPos"
                }
            ],
            "from": [
                {
                    "value": "player",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "tryout",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.pID",
                            "T2.pID"
                        ]
                    }
                }
            ],
            "where": {
                "gt": [
                    "T1.HS",
                    1000
                ]
            },
            "groupby": {
                "value": "T2.pPos"
            }
        },
        "sql_ans": [
            [
                1600,
                "goalie"
            ],
            [
                1600,
                "striker"
            ]
        ],
        "cypher_query": "MATCH (T1:`soccer_2.Player`)-[T2:`soccer_2.Tryout`]-()\nWHERE T1.HS > 1000\nWITH T2.pPos AS pPos, count(T2.pPos) AS count\nRETURN count,pPos",
        "cypher_ans": [
            [
                3,
                "goalie"
            ],
            [
                1,
                "striker"
            ]
        ]
    },
    {
        "db_id": "soccer_2",
        "query": "For each position, what is the maximum number of  hours for students who spent more than 1000 hours training?",
        "sql_query": "SELECT max(T1.HS) ,  pPos FROM player AS T1 JOIN tryout AS T2 ON T1.pID  =  T2.pID WHERE T1.HS  >  1000 GROUP BY T2.pPos",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "T1.HS"
                    }
                },
                {
                    "value": "pPos"
                }
            ],
            "from": [
                {
                    "value": "player",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "tryout",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.pID",
                            "T2.pID"
                        ]
                    }
                }
            ],
            "where": {
                "gt": [
                    "T1.HS",
                    1000
                ]
            },
            "groupby": {
                "value": "T2.pPos"
            }
        },
        "sql_ans": [
            [
                1600,
                "goalie"
            ],
            [
                1600,
                "striker"
            ]
        ],
        "cypher_query": "MATCH (T1:`soccer_2.Player`)-[T2:`soccer_2.Tryout`]-()\nWHERE T1.HS > 1000\nWITH T2.pPos AS pPos, count(T2.pPos) AS count\nRETURN count,pPos",
        "cypher_ans": [
            [
                3,
                "goalie"
            ],
            [
                1,
                "striker"
            ]
        ]
    },
    {
        "db_id": "cre_Drama_Workshop_Groups",
        "query": "What are the different product names? What is the average product price for each of them?",
        "sql_query": "SELECT Product_Name ,  avg(Product_Price) FROM PRODUCTS GROUP BY Product_Name",
        "parsed_sql": {
            "select": [
                {
                    "value": "Product_Name"
                },
                {
                    "value": {
                        "avg": "Product_Price"
                    }
                }
            ],
            "from": "PRODUCTS",
            "groupby": {
                "value": "Product_Name"
            }
        },
        "sql_ans": [
            [
                "dinning",
                238704.33333333334
            ],
            [
                "film",
                11385515.333333334
            ],
            [
                "photo",
                5102691.666666667
            ]
        ],
        "cypher_query": "MATCH (products:`cre_Drama_Workshop_Groups.Products`)\nWITH count(products.Product_Name) AS count, products.Product_Name AS Product_Name\nRETURN Product_Name,count",
        "cypher_ans": [
            [
                "photo",
                6
            ],
            [
                "film",
                6
            ],
            [
                "dinning",
                3
            ]
        ]
    },
    {
        "db_id": "cre_Drama_Workshop_Groups",
        "query": "For each distinct product name, show its average product price.",
        "sql_query": "SELECT Product_Name ,  avg(Product_Price) FROM PRODUCTS GROUP BY Product_Name",
        "parsed_sql": {
            "select": [
                {
                    "value": "Product_Name"
                },
                {
                    "value": {
                        "avg": "Product_Price"
                    }
                }
            ],
            "from": "PRODUCTS",
            "groupby": {
                "value": "Product_Name"
            }
        },
        "sql_ans": [
            [
                "dinning",
                238704.33333333334
            ],
            [
                "film",
                11385515.333333334
            ],
            [
                "photo",
                5102691.666666667
            ]
        ],
        "cypher_query": "MATCH (products:`cre_Drama_Workshop_Groups.Products`)\nWITH count(products.Product_Name) AS count, products.Product_Name AS Product_Name\nRETURN Product_Name,count",
        "cypher_ans": [
            [
                "photo",
                6
            ],
            [
                "film",
                6
            ],
            [
                "dinning",
                3
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "How many bands are there?",
        "sql_query": "SELECT count(*) FROM Band",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Band"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (band:`music_2.Band`)\nRETURN count(*)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "Find the number of bands.",
        "sql_query": "SELECT count(*) FROM Band",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Band"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (band:`music_2.Band`)\nRETURN count(*)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What are all the labels?",
        "sql_query": "SELECT DISTINCT label FROM Albums",
        "parsed_sql": {
            "select": {
                "value": {
                    "distinct": {
                        "value": "label"
                    }
                }
            },
            "from": "Albums"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (albums:`music_2.Albums`)\nRETURN DISTINCT albums.Label",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What are the different album labels listed?",
        "sql_query": "SELECT DISTINCT label FROM Albums",
        "parsed_sql": {
            "select": {
                "value": {
                    "distinct": {
                        "value": "label"
                    }
                }
            },
            "from": "Albums"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (albums:`music_2.Albums`)\nRETURN DISTINCT albums.Label",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "How many songs are there?",
        "sql_query": "SELECT count(*) FROM Songs",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Songs"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (songs:`music_2.Songs`)\nRETURN count(*)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "Count the number of songs.",
        "sql_query": "SELECT count(*) FROM Songs",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Songs"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (songs:`music_2.Songs`)\nRETURN count(*)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "How many unique labels are there for albums?",
        "sql_query": "SELECT count(DISTINCT label) FROM albums",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "label"
                        }
                    }
                }
            },
            "from": "albums"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (albums:`music_2.Albums`)\nRETURN count(DISTINCT albums.Label)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What are the unique labels for the albums?",
        "sql_query": "SELECT count(DISTINCT label) FROM albums",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "label"
                        }
                    }
                }
            },
            "from": "albums"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (albums:`music_2.Albums`)\nRETURN count(DISTINCT albums.Label)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What is the label that has the most albums?",
        "sql_query": "SELECT label FROM albums GROUP BY label ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "label"
            },
            "from": "albums",
            "groupby": {
                "value": "label"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH (albums:`music_2.Albums`)\nWITH count(albums.Label) AS count, albums.Label AS Label\nRETURN Label\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What is the label with the most albums?",
        "sql_query": "SELECT label FROM albums GROUP BY label ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "label"
            },
            "from": "albums",
            "groupby": {
                "value": "label"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH (albums:`music_2.Albums`)\nWITH count(albums.Label) AS count, albums.Label AS Label\nRETURN Label\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What is the last name of the musician that have produced the most number of songs?",
        "sql_query": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T2.lastname"
            },
            "from": [
                {
                    "value": "Performance",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Band",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.bandmate",
                            "T2.id"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "Songs",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T3.SongId",
                            "T1.SongId"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "lastname"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH ()-[T1:`music_2.Performance`]-(T2:`music_2.Band`)-[]-(T3:`music_2.Songs`)\nWITH count(T2.Lastname) AS count, T2.Lastname AS Lastname\nRETURN Lastname\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What is the last name of the musician who was in the most songs?",
        "sql_query": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T2.lastname"
            },
            "from": [
                {
                    "value": "Performance",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Band",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.bandmate",
                            "T2.id"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "Songs",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T3.SongId",
                            "T1.SongId"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "lastname"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH ()-[T1:`music_2.Performance`]-(T2:`music_2.Band`)-[]-(T3:`music_2.Songs`)\nWITH count(T2.Lastname) AS count, T2.Lastname AS Lastname\nRETURN Lastname\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What are all the instruments used?",
        "sql_query": "SELECT DISTINCT instrument FROM Instruments",
        "parsed_sql": {
            "select": {
                "value": {
                    "distinct": {
                        "value": "instrument"
                    }
                }
            },
            "from": "Instruments"
        },
        "sql_ans": [],
        "cypher_query": "MATCH ()-[instruments:`music_2.Instruments`]-()\nRETURN DISTINCT instruments.Instrument",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What are the different instruments listed in the database?",
        "sql_query": "SELECT DISTINCT instrument FROM Instruments",
        "parsed_sql": {
            "select": {
                "value": {
                    "distinct": {
                        "value": "instrument"
                    }
                }
            },
            "from": "Instruments"
        },
        "sql_ans": [],
        "cypher_query": "MATCH ()-[instruments:`music_2.Instruments`]-()\nRETURN DISTINCT instruments.Instrument",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What is the most used instrument?",
        "sql_query": "SELECT instrument FROM instruments GROUP BY instrument ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "instrument"
            },
            "from": "instruments",
            "groupby": {
                "value": "instrument"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH ()-[instruments:`music_2.Instruments`]-()\nWITH instruments.Instrument AS Instrument, count(instruments.Instrument) AS count\nRETURN Instrument\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What instrument is used the most?",
        "sql_query": "SELECT instrument FROM instruments GROUP BY instrument ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "instrument"
            },
            "from": "instruments",
            "groupby": {
                "value": "instrument"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH ()-[instruments:`music_2.Instruments`]-()\nWITH instruments.Instrument AS Instrument, count(instruments.Instrument) AS count\nRETURN Instrument\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "Which song has the most vocals?",
        "sql_query": "SELECT title FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid GROUP BY T1.songid ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "title"
            },
            "from": [
                {
                    "value": "vocals",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "songs",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.songid",
                            "T2.songid"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.songid"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH ()-[T1:`music_2.Vocals`]-(T2:`music_2.Songs`)\nWITH count(T1.SongId) AS count, T2.Title AS Title\nRETURN Title\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What is the song with the most vocals?",
        "sql_query": "SELECT title FROM vocals AS T1 JOIN songs AS T2 ON T1.songid  =  T2.songid GROUP BY T1.songid ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "title"
            },
            "from": [
                {
                    "value": "vocals",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "songs",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.songid",
                            "T2.songid"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.songid"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH ()-[T1:`music_2.Vocals`]-(T2:`music_2.Songs`)\nWITH count(T1.SongId) AS count, T2.Title AS Title\nRETURN Title\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "Which vocal type is the most frequently appearring type?",
        "sql_query": "SELECT TYPE FROM vocals GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "TYPE"
            },
            "from": "vocals",
            "groupby": {
                "value": "TYPE"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH ()-[vocals:`music_2.Vocals`]-()\nWITH count(vocals.Type) AS count, vocals.Type AS Type\nRETURN Type\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What is the type of vocables that appears most frequently?",
        "sql_query": "SELECT TYPE FROM vocals GROUP BY TYPE ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "TYPE"
            },
            "from": "vocals",
            "groupby": {
                "value": "TYPE"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH ()-[vocals:`music_2.Vocals`]-()\nWITH count(vocals.Type) AS count, vocals.Type AS Type\nRETURN Type\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "Find all the vocal types.",
        "sql_query": "SELECT DISTINCT TYPE FROM vocals",
        "parsed_sql": {
            "select": {
                "value": {
                    "distinct": {
                        "value": "TYPE"
                    }
                }
            },
            "from": "vocals"
        },
        "sql_ans": [],
        "cypher_query": "MATCH ()-[vocals:`music_2.Vocals`]-()\nRETURN DISTINCT vocals.Type",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What are the different types of vocals?",
        "sql_query": "SELECT DISTINCT TYPE FROM vocals",
        "parsed_sql": {
            "select": {
                "value": {
                    "distinct": {
                        "value": "TYPE"
                    }
                }
            },
            "from": "vocals"
        },
        "sql_ans": [],
        "cypher_query": "MATCH ()-[vocals:`music_2.Vocals`]-()\nRETURN DISTINCT vocals.Type",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What is the last name of the musician that have produced the most songs?",
        "sql_query": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T2.lastname"
            },
            "from": [
                {
                    "value": "Performance",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Band",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.bandmate",
                            "T2.id"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "Songs",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T3.SongId",
                            "T1.SongId"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "lastname"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH ()-[T1:`music_2.Performance`]-(T2:`music_2.Band`)-[]-(T3:`music_2.Songs`)\nWITH count(T2.Lastname) AS count, T2.Lastname AS Lastname\nRETURN Lastname\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "music_2",
        "query": "What is the last name of the artist who sang the most songs?",
        "sql_query": "SELECT T2.lastname FROM Performance AS T1 JOIN Band AS T2 ON T1.bandmate  =  T2.id JOIN Songs AS T3 ON T3.SongId  =  T1.SongId GROUP BY lastname ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T2.lastname"
            },
            "from": [
                {
                    "value": "Performance",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Band",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.bandmate",
                            "T2.id"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "Songs",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T3.SongId",
                            "T1.SongId"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "lastname"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH ()-[T1:`music_2.Performance`]-(T2:`music_2.Band`)-[]-(T3:`music_2.Songs`)\nWITH count(T2.Lastname) AS count, T2.Lastname AS Lastname\nRETURN Lastname\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "manufactory_1",
        "query": "Find the founder of the company whose name begins with the letter 'S'.",
        "sql_query": "SELECT founder FROM manufacturers WHERE name LIKE 'S%'",
        "parsed_sql": {
            "select": {
                "value": "founder"
            },
            "from": "manufacturers",
            "where": {
                "like": [
                    "name",
                    {
                        "literal": "S%"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Andy"
            ]
        ],
        "cypher_query": "MATCH (manufacturers:`manufactory_1.Manufacturers`)\nWHERE manufacturers.Name =~'.*[S|s].*'\nRETURN manufacturers.Founder",
        "cypher_ans": [
            [
                "Andy"
            ],
            [
                "Owen"
            ],
            [
                "John"
            ],
            [
                "Robert"
            ]
        ]
    },
    {
        "db_id": "manufactory_1",
        "query": "Who is the founders of companies whose first letter is S?",
        "sql_query": "SELECT founder FROM manufacturers WHERE name LIKE 'S%'",
        "parsed_sql": {
            "select": {
                "value": "founder"
            },
            "from": "manufacturers",
            "where": {
                "like": [
                    "name",
                    {
                        "literal": "S%"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Andy"
            ]
        ],
        "cypher_query": "MATCH (manufacturers:`manufactory_1.Manufacturers`)\nWHERE manufacturers.Name =~'.*[S|s].*'\nRETURN manufacturers.Founder",
        "cypher_ans": [
            [
                "Andy"
            ],
            [
                "Owen"
            ],
            [
                "John"
            ],
            [
                "Robert"
            ]
        ]
    },
    {
        "db_id": "manufactory_1",
        "query": "Find the name and revenue of the company that earns the highest revenue in each city.",
        "sql_query": "SELECT name ,  max(revenue) ,  Headquarter FROM manufacturers GROUP BY Headquarter",
        "parsed_sql": {
            "select": [
                {
                    "value": "name"
                },
                {
                    "value": {
                        "max": "revenue"
                    }
                },
                {
                    "value": "Headquarter"
                }
            ],
            "from": "manufacturers",
            "groupby": {
                "value": "Headquarter"
            }
        },
        "sql_ans": [
            [
                "Creative Labs",
                100.0,
                "Austin"
            ],
            [
                "Iomega",
                200.0,
                "Beijing"
            ],
            [
                "Hewlett-Packard",
                50.0,
                "Los Angeles"
            ],
            [
                "Winchester",
                30.0,
                "Paris"
            ],
            [
                "Fujitsu",
                130.0,
                "Taiwan"
            ],
            [
                "Sony",
                120.0,
                "Tokyo"
            ]
        ],
        "cypher_query": "MATCH (manufacturers:`manufactory_1.Manufacturers`)\nWITH manufacturers.Name AS Name, count(manufacturers.Headquarter) AS count, manufacturers.Headquarter AS Headquarter\nRETURN Name,count,Headquarter",
        "cypher_ans": [
            [
                "Sony",
                1,
                "Tokyo"
            ],
            [
                "Creative Labs",
                1,
                "Austin"
            ],
            [
                "Hewlett-Packard",
                1,
                "Los Angeles"
            ],
            [
                "Iomega",
                1,
                "Beijing"
            ],
            [
                "Fujitsu",
                1,
                "Taiwan"
            ],
            [
                "Winchester",
                1,
                "Paris"
            ]
        ]
    },
    {
        "db_id": "manufactory_1",
        "query": "What are the names and revenues of the companies with the highest revenues in each headquarter city?",
        "sql_query": "SELECT name ,  max(revenue) ,  Headquarter FROM manufacturers GROUP BY Headquarter",
        "parsed_sql": {
            "select": [
                {
                    "value": "name"
                },
                {
                    "value": {
                        "max": "revenue"
                    }
                },
                {
                    "value": "Headquarter"
                }
            ],
            "from": "manufacturers",
            "groupby": {
                "value": "Headquarter"
            }
        },
        "sql_ans": [
            [
                "Creative Labs",
                100.0,
                "Austin"
            ],
            [
                "Iomega",
                200.0,
                "Beijing"
            ],
            [
                "Hewlett-Packard",
                50.0,
                "Los Angeles"
            ],
            [
                "Winchester",
                30.0,
                "Paris"
            ],
            [
                "Fujitsu",
                130.0,
                "Taiwan"
            ],
            [
                "Sony",
                120.0,
                "Tokyo"
            ]
        ],
        "cypher_query": "MATCH (manufacturers:`manufactory_1.Manufacturers`)\nWITH manufacturers.Name AS Name, count(manufacturers.Headquarter) AS count, manufacturers.Headquarter AS Headquarter\nRETURN Name,count,Headquarter",
        "cypher_ans": [
            [
                "Sony",
                1,
                "Tokyo"
            ],
            [
                "Creative Labs",
                1,
                "Austin"
            ],
            [
                "Hewlett-Packard",
                1,
                "Los Angeles"
            ],
            [
                "Iomega",
                1,
                "Beijing"
            ],
            [
                "Fujitsu",
                1,
                "Taiwan"
            ],
            [
                "Winchester",
                1,
                "Paris"
            ]
        ]
    },
    {
        "db_id": "manufactory_1",
        "query": "Find the average prices of all products from each manufacture, and list each company's name.",
        "sql_query": "SELECT avg(T1.price) ,  T2.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer  =  T2.code GROUP BY T2.name",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "T1.price"
                    }
                },
                {
                    "value": "T2.name"
                }
            ],
            "from": [
                {
                    "value": "products",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "manufacturers",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Manufacturer",
                            "T2.code"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T2.name"
            }
        },
        "sql_ans": [
            [
                150.0,
                "Creative Labs"
            ],
            [
                240.0,
                "Fujitsu"
            ],
            [
                162.0,
                "Hewlett-Packard"
            ],
            [
                150.0,
                "Iomega"
            ],
            [
                240.0,
                "Sony"
            ],
            [
                62.5,
                "Winchester"
            ]
        ],
        "cypher_query": "MATCH (T1:`manufactory_1.Products`)-[]-(T2:`manufactory_1.Manufacturers`)\nWITH count(T2.Name) AS count, T2.Name AS Name\nRETURN count,Name",
        "cypher_ans": [
            [
                1,
                "Sony"
            ],
            [
                3,
                "Creative Labs"
            ],
            [
                3,
                "Hewlett-Packard"
            ],
            [
                1,
                "Iomega"
            ],
            [
                1,
                "Fujitsu"
            ],
            [
                2,
                "Winchester"
            ]
        ]
    },
    {
        "db_id": "manufactory_1",
        "query": "What are the average prices of products for each manufacturer?",
        "sql_query": "SELECT avg(T1.price) ,  T2.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer  =  T2.code GROUP BY T2.name",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "T1.price"
                    }
                },
                {
                    "value": "T2.name"
                }
            ],
            "from": [
                {
                    "value": "products",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "manufacturers",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Manufacturer",
                            "T2.code"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T2.name"
            }
        },
        "sql_ans": [
            [
                150.0,
                "Creative Labs"
            ],
            [
                240.0,
                "Fujitsu"
            ],
            [
                162.0,
                "Hewlett-Packard"
            ],
            [
                150.0,
                "Iomega"
            ],
            [
                240.0,
                "Sony"
            ],
            [
                62.5,
                "Winchester"
            ]
        ],
        "cypher_query": "MATCH (T1:`manufactory_1.Products`)-[]-(T2:`manufactory_1.Manufacturers`)\nWITH count(T2.Name) AS count, T2.Name AS Name\nRETURN count,Name",
        "cypher_ans": [
            [
                1,
                "Sony"
            ],
            [
                3,
                "Creative Labs"
            ],
            [
                3,
                "Hewlett-Packard"
            ],
            [
                1,
                "Iomega"
            ],
            [
                1,
                "Fujitsu"
            ],
            [
                2,
                "Winchester"
            ]
        ]
    },
    {
        "db_id": "manufactory_1",
        "query": "Find number of products which Sony does not make.",
        "sql_query": "SELECT count(DISTINCT name) FROM products WHERE name NOT IN (SELECT T1.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer  =  T2.code WHERE T2.name  =  'Sony')",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "name"
                        }
                    }
                }
            },
            "from": "products",
            "where": {
                "nin": [
                    "name",
                    {
                        "select": {
                            "value": "T1.name"
                        },
                        "from": [
                            {
                                "value": "products",
                                "name": "T1",
                                "is_table": true
                            },
                            {
                                "join": {
                                    "name": "T2",
                                    "value": "manufacturers",
                                    "is_table": true
                                },
                                "on": {
                                    "eq": [
                                        "T1.Manufacturer",
                                        "T2.code"
                                    ]
                                }
                            }
                        ],
                        "where": {
                            "eq": [
                                "T2.name",
                                {
                                    "literal": "Sony"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                9
            ]
        ],
        "cypher_query": "MATCH (products:`manufactory_1.Products`)\nWHERE NOT (products:`manufactory_1.Products`)-[]-(:`manufactory_1.Products`)-[]-(:`manufactory_1.Manufacturers { Name : 'Sony' }`)\nRETURN count(DISTINCT products.Name)",
        "cypher_ans": [
            [
                10
            ]
        ]
    },
    {
        "db_id": "manufactory_1",
        "query": "How many products are not made by Sony?",
        "sql_query": "SELECT count(DISTINCT name) FROM products WHERE name NOT IN (SELECT T1.name FROM products AS T1 JOIN manufacturers AS T2 ON T1.Manufacturer  =  T2.code WHERE T2.name  =  'Sony')",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "name"
                        }
                    }
                }
            },
            "from": "products",
            "where": {
                "nin": [
                    "name",
                    {
                        "select": {
                            "value": "T1.name"
                        },
                        "from": [
                            {
                                "value": "products",
                                "name": "T1",
                                "is_table": true
                            },
                            {
                                "join": {
                                    "name": "T2",
                                    "value": "manufacturers",
                                    "is_table": true
                                },
                                "on": {
                                    "eq": [
                                        "T1.Manufacturer",
                                        "T2.code"
                                    ]
                                }
                            }
                        ],
                        "where": {
                            "eq": [
                                "T2.name",
                                {
                                    "literal": "Sony"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                9
            ]
        ],
        "cypher_query": "MATCH (products:`manufactory_1.Products`)\nWHERE NOT (products:`manufactory_1.Products`)-[]-(:`manufactory_1.Products`)-[]-(:`manufactory_1.Manufacturers { Name : 'Sony' }`)\nRETURN count(DISTINCT products.Name)",
        "cypher_ans": [
            [
                10
            ]
        ]
    },
    {
        "db_id": "manufactory_1",
        "query": "Select the average price of each manufacturer's products, showing only the manufacturer's code.",
        "sql_query": "SELECT AVG(Price) ,  Manufacturer FROM Products GROUP BY Manufacturer",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "Price"
                    }
                },
                {
                    "value": "Manufacturer"
                }
            ],
            "from": "Products",
            "groupby": {
                "value": "Manufacturer"
            }
        },
        "sql_ans": [
            [
                240.0,
                1
            ],
            [
                150.0,
                2
            ],
            [
                162.0,
                3
            ],
            [
                150.0,
                4
            ],
            [
                240.0,
                5
            ],
            [
                62.5,
                6
            ]
        ],
        "cypher_query": "MATCH (products:`manufactory_1.Products`)\nWITH count(products.Manufacturer) AS count, products.Manufacturer AS Manufacturer\nRETURN count,Manufacturer",
        "cypher_ans": [
            [
                1,
                5
            ],
            [
                2,
                6
            ],
            [
                1,
                4
            ],
            [
                1,
                1
            ],
            [
                3,
                2
            ],
            [
                3,
                3
            ]
        ]
    },
    {
        "db_id": "manufactory_1",
        "query": "What are the average prices of products, grouped by manufacturer code?",
        "sql_query": "SELECT AVG(Price) ,  Manufacturer FROM Products GROUP BY Manufacturer",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "Price"
                    }
                },
                {
                    "value": "Manufacturer"
                }
            ],
            "from": "Products",
            "groupby": {
                "value": "Manufacturer"
            }
        },
        "sql_ans": [
            [
                240.0,
                1
            ],
            [
                150.0,
                2
            ],
            [
                162.0,
                3
            ],
            [
                150.0,
                4
            ],
            [
                240.0,
                5
            ],
            [
                62.5,
                6
            ]
        ],
        "cypher_query": "MATCH (products:`manufactory_1.Products`)\nWITH count(products.Manufacturer) AS count, products.Manufacturer AS Manufacturer\nRETURN count,Manufacturer",
        "cypher_ans": [
            [
                1,
                5
            ],
            [
                2,
                6
            ],
            [
                1,
                4
            ],
            [
                1,
                1
            ],
            [
                3,
                2
            ],
            [
                3,
                3
            ]
        ]
    },
    {
        "db_id": "manufactory_1",
        "query": "Select the average price of each manufacturer's products, showing the manufacturer's name.",
        "sql_query": "SELECT avg(T1.Price) ,  T2.name FROM products AS T1 JOIN Manufacturers AS T2 ON T1.manufacturer  =  T2.code GROUP BY T2.name",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "T1.Price"
                    }
                },
                {
                    "value": "T2.name"
                }
            ],
            "from": [
                {
                    "value": "products",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Manufacturers",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.manufacturer",
                            "T2.code"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T2.name"
            }
        },
        "sql_ans": [
            [
                150.0,
                "Creative Labs"
            ],
            [
                240.0,
                "Fujitsu"
            ],
            [
                162.0,
                "Hewlett-Packard"
            ],
            [
                150.0,
                "Iomega"
            ],
            [
                240.0,
                "Sony"
            ],
            [
                62.5,
                "Winchester"
            ]
        ],
        "cypher_query": "MATCH (T1:`manufactory_1.Products`)-[]-(T2:`manufactory_1.Manufacturers`)\nWITH count(T2.Name) AS count, T2.Name AS Name\nRETURN count,Name",
        "cypher_ans": [
            [
                1,
                "Sony"
            ],
            [
                3,
                "Creative Labs"
            ],
            [
                3,
                "Hewlett-Packard"
            ],
            [
                1,
                "Iomega"
            ],
            [
                1,
                "Fujitsu"
            ],
            [
                2,
                "Winchester"
            ]
        ]
    },
    {
        "db_id": "manufactory_1",
        "query": "What are the average prices of products, grouped by manufacturer name?",
        "sql_query": "SELECT avg(T1.Price) ,  T2.name FROM products AS T1 JOIN Manufacturers AS T2 ON T1.manufacturer  =  T2.code GROUP BY T2.name",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "T1.Price"
                    }
                },
                {
                    "value": "T2.name"
                }
            ],
            "from": [
                {
                    "value": "products",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Manufacturers",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.manufacturer",
                            "T2.code"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T2.name"
            }
        },
        "sql_ans": [
            [
                150.0,
                "Creative Labs"
            ],
            [
                240.0,
                "Fujitsu"
            ],
            [
                162.0,
                "Hewlett-Packard"
            ],
            [
                150.0,
                "Iomega"
            ],
            [
                240.0,
                "Sony"
            ],
            [
                62.5,
                "Winchester"
            ]
        ],
        "cypher_query": "MATCH (T1:`manufactory_1.Products`)-[]-(T2:`manufactory_1.Manufacturers`)\nWITH count(T2.Name) AS count, T2.Name AS Name\nRETURN count,Name",
        "cypher_ans": [
            [
                1,
                "Sony"
            ],
            [
                3,
                "Creative Labs"
            ],
            [
                3,
                "Hewlett-Packard"
            ],
            [
                1,
                "Iomega"
            ],
            [
                1,
                "Fujitsu"
            ],
            [
                2,
                "Winchester"
            ]
        ]
    },
    {
        "db_id": "manufactory_1",
        "query": "Select the code of the product that is cheapest in each product category.",
        "sql_query": "SELECT code ,  name ,  min(price) FROM products GROUP BY name",
        "parsed_sql": {
            "select": [
                {
                    "value": "code"
                },
                {
                    "value": "name"
                },
                {
                    "value": {
                        "min": "price"
                    }
                }
            ],
            "from": "products",
            "groupby": {
                "value": "name"
            }
        },
        "sql_ans": [
            [
                7,
                "CD drive",
                90
            ],
            [
                10,
                "DVD burner",
                180
            ],
            [
                11,
                "DVD drive",
                150
            ],
            [
                4,
                "Floppy disk",
                5
            ],
            [
                1,
                "Hard drive",
                240
            ],
            [
                2,
                "Memory",
                120
            ],
            [
                5,
                "Monitor",
                240
            ],
            [
                8,
                "Printer",
                270
            ],
            [
                9,
                "Toner cartridge",
                66
            ],
            [
                3,
                "ZIP drive",
                150
            ]
        ],
        "cypher_query": "MATCH (products:`manufactory_1.Products`)\nWITH products.Name AS Name, count(products.Name) AS count, products.Code AS Code\nRETURN Code,Name,count",
        "cypher_ans": [
            [
                1,
                "Hard drive",
                1
            ],
            [
                2,
                "Memory",
                1
            ],
            [
                3,
                "ZIP drive",
                1
            ],
            [
                4,
                "Floppy disk",
                1
            ],
            [
                5,
                "Monitor",
                1
            ],
            [
                6,
                "DVD drive",
                1
            ],
            [
                7,
                "CD drive",
                1
            ],
            [
                8,
                "Printer",
                1
            ],
            [
                9,
                "Toner cartridge",
                1
            ],
            [
                10,
                "DVD burner",
                1
            ],
            [
                11,
                "DVD drive",
                1
            ]
        ]
    },
    {
        "db_id": "manufactory_1",
        "query": "What are the codes and names of the cheapest products in each category?",
        "sql_query": "SELECT code ,  name ,  min(price) FROM products GROUP BY name",
        "parsed_sql": {
            "select": [
                {
                    "value": "code"
                },
                {
                    "value": "name"
                },
                {
                    "value": {
                        "min": "price"
                    }
                }
            ],
            "from": "products",
            "groupby": {
                "value": "name"
            }
        },
        "sql_ans": [
            [
                7,
                "CD drive",
                90
            ],
            [
                10,
                "DVD burner",
                180
            ],
            [
                11,
                "DVD drive",
                150
            ],
            [
                4,
                "Floppy disk",
                5
            ],
            [
                1,
                "Hard drive",
                240
            ],
            [
                2,
                "Memory",
                120
            ],
            [
                5,
                "Monitor",
                240
            ],
            [
                8,
                "Printer",
                270
            ],
            [
                9,
                "Toner cartridge",
                66
            ],
            [
                3,
                "ZIP drive",
                150
            ]
        ],
        "cypher_query": "MATCH (products:`manufactory_1.Products`)\nWITH products.Name AS Name, count(products.Name) AS count, products.Code AS Code\nRETURN Code,Name,count",
        "cypher_ans": [
            [
                1,
                "Hard drive",
                1
            ],
            [
                2,
                "Memory",
                1
            ],
            [
                3,
                "ZIP drive",
                1
            ],
            [
                4,
                "Floppy disk",
                1
            ],
            [
                5,
                "Monitor",
                1
            ],
            [
                6,
                "DVD drive",
                1
            ],
            [
                7,
                "CD drive",
                1
            ],
            [
                8,
                "Printer",
                1
            ],
            [
                9,
                "Toner cartridge",
                1
            ],
            [
                10,
                "DVD burner",
                1
            ],
            [
                11,
                "DVD drive",
                1
            ]
        ]
    },
    {
        "db_id": "shop_membership",
        "query": "Show member names without any registered branch.",
        "sql_query": "SELECT name FROM member WHERE member_id NOT IN (SELECT member_id FROM membership_register_branch)",
        "parsed_sql": {
            "select": {
                "value": "name"
            },
            "from": "member",
            "where": {
                "nin": [
                    "member_id",
                    {
                        "select": {
                            "value": "member_id"
                        },
                        "from": "membership_register_branch"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "David Jones"
            ],
            [
                "Matt Lentz"
            ]
        ],
        "cypher_query": "MATCH (member:`shop_membership.member`)\nWHERE NOT (member:`shop_membership.member`)-[]-(:`shop_membership.membership_register_branch`)\nRETURN member.Name",
        "cypher_ans": [
            [
                "Jeremy Jarmon"
            ],
            [
                "Myron Pryor"
            ],
            [
                "Corey Peters"
            ],
            [
                "Ventrell Jenkins"
            ],
            [
                "Braxton Kelley"
            ],
            [
                "Micah Johnson"
            ],
            [
                "Johnny Williams"
            ],
            [
                "Trevard Lindley"
            ],
            [
                "David Jones"
            ],
            [
                "Matt Lentz"
            ]
        ]
    },
    {
        "db_id": "shop_membership",
        "query": "What are the names of the members that have never registered at any branch?",
        "sql_query": "SELECT name FROM member WHERE member_id NOT IN (SELECT member_id FROM membership_register_branch)",
        "parsed_sql": {
            "select": {
                "value": "name"
            },
            "from": "member",
            "where": {
                "nin": [
                    "member_id",
                    {
                        "select": {
                            "value": "member_id"
                        },
                        "from": "membership_register_branch"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "David Jones"
            ],
            [
                "Matt Lentz"
            ]
        ],
        "cypher_query": "MATCH (member:`shop_membership.member`)\nWHERE NOT (member:`shop_membership.member`)-[]-(:`shop_membership.membership_register_branch`)\nRETURN member.Name",
        "cypher_ans": [
            [
                "Jeremy Jarmon"
            ],
            [
                "Myron Pryor"
            ],
            [
                "Corey Peters"
            ],
            [
                "Ventrell Jenkins"
            ],
            [
                "Braxton Kelley"
            ],
            [
                "Micah Johnson"
            ],
            [
                "Johnny Williams"
            ],
            [
                "Trevard Lindley"
            ],
            [
                "David Jones"
            ],
            [
                "Matt Lentz"
            ]
        ]
    },
    {
        "db_id": "shop_membership",
        "query": "List the branch name and city without any registered members.",
        "sql_query": "SELECT name ,  city FROM branch WHERE branch_id NOT IN (SELECT branch_id FROM membership_register_branch)",
        "parsed_sql": {
            "select": [
                {
                    "value": "name"
                },
                {
                    "value": "city"
                }
            ],
            "from": "branch",
            "where": {
                "nin": [
                    "branch_id",
                    {
                        "select": {
                            "value": "branch_id"
                        },
                        "from": "membership_register_branch"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Stanley",
                "London"
            ],
            [
                "Saint Amant",
                "London"
            ]
        ],
        "cypher_query": "MATCH (branch:`shop_membership.branch`)\nWHERE NOT (branch:`shop_membership.branch`)-[]-(:`shop_membership.membership_register_branch`)\nRETURN branch.Name,branch.City",
        "cypher_ans": [
            [
                "Alexandre",
                "London"
            ],
            [
                "Popert",
                "London"
            ],
            [
                "Stanley",
                "London"
            ],
            [
                "Zytogorski",
                "Oxford"
            ],
            [
                "Cochrane",
                "London"
            ],
            [
                "Taverner",
                "Oxford"
            ],
            [
                "Saint Amant",
                "London"
            ],
            [
                "Brooke Greville",
                "Oxford"
            ]
        ]
    },
    {
        "db_id": "shop_membership",
        "query": "What are the names and cities of the branches that do not have any registered members?",
        "sql_query": "SELECT name ,  city FROM branch WHERE branch_id NOT IN (SELECT branch_id FROM membership_register_branch)",
        "parsed_sql": {
            "select": [
                {
                    "value": "name"
                },
                {
                    "value": "city"
                }
            ],
            "from": "branch",
            "where": {
                "nin": [
                    "branch_id",
                    {
                        "select": {
                            "value": "branch_id"
                        },
                        "from": "membership_register_branch"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Stanley",
                "London"
            ],
            [
                "Saint Amant",
                "London"
            ]
        ],
        "cypher_query": "MATCH (branch:`shop_membership.branch`)\nWHERE NOT (branch:`shop_membership.branch`)-[]-(:`shop_membership.membership_register_branch`)\nRETURN branch.Name,branch.City",
        "cypher_ans": [
            [
                "Alexandre",
                "London"
            ],
            [
                "Popert",
                "London"
            ],
            [
                "Stanley",
                "London"
            ],
            [
                "Zytogorski",
                "Oxford"
            ],
            [
                "Cochrane",
                "London"
            ],
            [
                "Taverner",
                "Oxford"
            ],
            [
                "Saint Amant",
                "London"
            ],
            [
                "Brooke Greville",
                "Oxford"
            ]
        ]
    },
    {
        "db_id": "shop_membership",
        "query": "What is the total number of purchases for members with level 6?",
        "sql_query": "SELECT count(*) FROM purchase AS T1 JOIN member AS T2 ON T1.member_id  =  T2.member_id WHERE T2.level  =  6",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "purchase",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "member",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.member_id",
                            "T2.member_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.level",
                    6
                ]
            }
        },
        "sql_ans": [
            [
                7
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`shop_membership.purchase`]-(T2:`shop_membership.member`)\nWHERE T2.Level = 6\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "shop_membership",
        "query": "What are the total purchases for members rated at level 6?",
        "sql_query": "SELECT count(*) FROM purchase AS T1 JOIN member AS T2 ON T1.member_id  =  T2.member_id WHERE T2.level  =  6",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "purchase",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "member",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.member_id",
                            "T2.member_id"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.level",
                    6
                ]
            }
        },
        "sql_ans": [
            [
                7
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`shop_membership.purchase`]-(T2:`shop_membership.member`)\nWHERE T2.Level = 6\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "voter_2",
        "query": "What is the city_code of the city that the most students live in?",
        "sql_query": "SELECT city_code FROM STUDENT GROUP BY city_code ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "city_code"
            },
            "from": "STUDENT",
            "groupby": {
                "value": "city_code"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "PIT"
            ]
        ],
        "cypher_query": "MATCH (student:`voter_2.Student`)\nWITH student.city_code AS city_code, count(student.city_code) AS count\nRETURN city_code\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "BAL"
            ]
        ]
    },
    {
        "db_id": "voter_2",
        "query": "Return the code of the city that has the most students.",
        "sql_query": "SELECT city_code FROM STUDENT GROUP BY city_code ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "city_code"
            },
            "from": "STUDENT",
            "groupby": {
                "value": "city_code"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "PIT"
            ]
        ],
        "cypher_query": "MATCH (student:`voter_2.Student`)\nWITH student.city_code AS city_code, count(student.city_code) AS count\nRETURN city_code\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "BAL"
            ]
        ]
    },
    {
        "db_id": "products_gen_characteristics",
        "query": "Find the number of products with category \"Spices\" and typically sold above 1000.",
        "sql_query": "SELECT count(*) FROM products WHERE product_category_code  =  \"Spices\" AND typical_buying_price  >  1000",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "products",
            "where": {
                "and": [
                    {
                        "eq": [
                            "product_category_code",
                            "Spices"
                        ]
                    },
                    {
                        "gt": [
                            "typical_buying_price",
                            1000
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (products:`products_gen_characteristics.Products`)\nWHERE products.product_category_code = 'Spices' AND products.typical_buying_price > 1000\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "products_gen_characteristics",
        "query": "How many products are in the 'Spices' category and have a typical price of over 1000?",
        "sql_query": "SELECT count(*) FROM products WHERE product_category_code  =  \"Spices\" AND typical_buying_price  >  1000",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "products",
            "where": {
                "and": [
                    {
                        "eq": [
                            "product_category_code",
                            "Spices"
                        ]
                    },
                    {
                        "gt": [
                            "typical_buying_price",
                            1000
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (products:`products_gen_characteristics.Products`)\nWHERE products.product_category_code = 'Spices' AND products.typical_buying_price > 1000\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "products_gen_characteristics",
        "query": "How many colors are never used by any product?",
        "sql_query": "SELECT count(*) FROM Ref_colors WHERE color_code NOT IN ( SELECT color_code FROM products )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Ref_colors",
            "where": {
                "nin": [
                    "color_code",
                    {
                        "select": {
                            "value": "color_code"
                        },
                        "from": "products"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (ref_colors:`products_gen_characteristics.Ref_Colors`)\nWHERE NOT (ref_colors:`products_gen_characteristics.Ref_Colors`)-[]-(:`products_gen_characteristics.Products`)\nRETURN count(*)",
        "cypher_ans": [
            [
                8
            ]
        ]
    },
    {
        "db_id": "products_gen_characteristics",
        "query": "Count the number of colors that are not used in any products.",
        "sql_query": "SELECT count(*) FROM Ref_colors WHERE color_code NOT IN ( SELECT color_code FROM products )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Ref_colors",
            "where": {
                "nin": [
                    "color_code",
                    {
                        "select": {
                            "value": "color_code"
                        },
                        "from": "products"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (ref_colors:`products_gen_characteristics.Ref_Colors`)\nWHERE NOT (ref_colors:`products_gen_characteristics.Ref_Colors`)-[]-(:`products_gen_characteristics.Products`)\nRETURN count(*)",
        "cypher_ans": [
            [
                8
            ]
        ]
    },
    {
        "db_id": "railway",
        "query": "Show the id and builder of the railway that are associated with the most trains.",
        "sql_query": "SELECT T2.Railway_ID ,  T1.Builder FROM railway AS T1 JOIN train AS T2 ON T1.Railway_ID  =  T2.Railway_ID GROUP BY T2.Railway_ID ORDER BY COUNT(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "T2.Railway_ID"
                },
                {
                    "value": "T1.Builder"
                }
            ],
            "from": [
                {
                    "value": "railway",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "train",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Railway_ID",
                            "T2.Railway_ID"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T2.Railway_ID"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                5,
                "GER Stratford"
            ]
        ],
        "cypher_query": "MATCH (T1:`railway.railway`)-[]-(T2:`railway.train`)\nWITH T2.Railway_ID AS Railway_ID, T1.Builder AS Builder, count(T2.Railway_ID) AS count\nRETURN Railway_ID,Builder\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                1,
                "SECR Ashford"
            ]
        ]
    },
    {
        "db_id": "customers_and_products_contacts",
        "query": "Show names and phones of customers who do not have address information.",
        "sql_query": "SELECT customer_name ,  customer_phone FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM customer_address_history)",
        "parsed_sql": {
            "select": [
                {
                    "value": "customer_name"
                },
                {
                    "value": "customer_phone"
                }
            ],
            "from": "customers",
            "where": {
                "nin": [
                    "customer_id",
                    {
                        "select": {
                            "value": "customer_id"
                        },
                        "from": "customer_address_history"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "Kayley",
                "+87(9)5279161988"
            ],
            [
                "Caterina",
                "387.053.1225"
            ],
            [
                "Raymond",
                "1-513-427-0125"
            ],
            [
                "Brenna",
                "1-271-345-4681x1131"
            ],
            [
                "Cleo",
                "1-202-928-5395"
            ],
            [
                "Ottilie",
                "393-750-2077x72779"
            ]
        ],
        "cypher_query": "MATCH (customers:`customers_and_products_contacts.Customers`)\nWHERE NOT (customers:`customers_and_products_contacts.Customers`)-[]-(:`customers_and_products_contacts.Customer_Address_History`)\nRETURN customers.customer_name,customers.customer_phone",
        "cypher_ans": [
            [
                "Kayley",
                "+87(9)5279161988"
            ],
            [
                "Sterling",
                "896.685.8228x2786"
            ],
            [
                "Buford",
                "(192)144-4687"
            ],
            [
                "Caterina",
                "387.053.1225"
            ],
            [
                "Raymond",
                "1-513-427-0125"
            ],
            [
                "Cheyenne",
                "009-136-4509x19635"
            ],
            [
                "Cecelia",
                "672-559-0630x7875"
            ],
            [
                "Brenna",
                "1-271-345-4681x1131"
            ],
            [
                "Lela",
                "838.718.8618x23239"
            ],
            [
                "Cleo",
                "1-202-928-5395"
            ],
            [
                "Shany",
                "936.929.9929"
            ],
            [
                "Madaline",
                "097-514-4641"
            ],
            [
                "Melissa",
                "529.148.1926"
            ],
            [
                "Orion",
                "479-171-6355x66065"
            ],
            [
                "Ottilie",
                "393-750-2077x72779"
            ]
        ]
    },
    {
        "db_id": "customers_and_products_contacts",
        "query": "Show the name of the customer who has the most orders.",
        "sql_query": "SELECT T1.customer_name FROM customers AS T1 JOIN customer_orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T1.customer_name"
            },
            "from": [
                {
                    "value": "customers",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "customer_orders",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.customer_id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.customer_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Cleo"
            ]
        ],
        "cypher_query": "MATCH (T1:`customers_and_products_contacts.Customers`)-[]-(T2:`customers_and_products_contacts.Customer_Orders`)\nWITH T1.customer_name AS customer_name, count(T1.customer_id) AS count\nRETURN customer_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Sterling"
            ]
        ]
    },
    {
        "db_id": "customers_and_products_contacts",
        "query": "Show the minimum, maximum, average price for all products.",
        "sql_query": "SELECT min(product_price) ,  max(product_price) ,  avg(product_price) FROM products",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "min": "product_price"
                    }
                },
                {
                    "value": {
                        "max": "product_price"
                    }
                },
                {
                    "value": {
                        "avg": "product_price"
                    }
                }
            ],
            "from": "products"
        },
        "sql_ans": [
            [
                77.109961147471,
                310488248.48788,
                28612946.784182724
            ]
        ],
        "cypher_query": "MATCH (products:`customers_and_products_contacts.Products`)\nRETURN min(products.product_price),max(products.product_price),avg(products.product_price)",
        "cypher_ans": [
            [
                77.109961147471,
                310488248.48788,
                28612946.78418272
            ]
        ]
    },
    {
        "db_id": "dorm_1",
        "query": "Find the average age of all students living in the each city.",
        "sql_query": "SELECT avg(age) ,  city_code FROM student GROUP BY city_code",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "age"
                    }
                },
                {
                    "value": "city_code"
                }
            ],
            "from": "student",
            "groupby": {
                "value": "city_code"
            }
        },
        "sql_ans": [
            [
                20.0,
                "ATL"
            ],
            [
                18.5,
                "BAL"
            ],
            [
                18.0,
                "BOS"
            ],
            [
                20.0,
                "CHI"
            ],
            [
                18.0,
                "DAL"
            ],
            [
                17.0,
                "DET"
            ],
            [
                18.0,
                "HKG"
            ],
            [
                17.0,
                "HOU"
            ],
            [
                27.0,
                "LON"
            ],
            [
                18.0,
                "LOS"
            ],
            [
                18.0,
                "NAR"
            ],
            [
                20.333333333333332,
                "NYC"
            ],
            [
                17.0,
                "PEK"
            ],
            [
                19.666666666666668,
                "PHL"
            ],
            [
                19.0,
                "PIT"
            ],
            [
                20.0,
                "ROC"
            ],
            [
                21.0,
                "SFO"
            ],
            [
                21.666666666666668,
                "WAS"
            ],
            [
                22.5,
                "YYZ"
            ]
        ],
        "cypher_query": "MATCH (student:`dorm_1.Student`)\nWITH student.city_code AS city_code, count(student.city_code) AS count\nRETURN count,city_code",
        "cypher_ans": [
            [
                4,
                "BAL"
            ],
            [
                3,
                "HKG"
            ],
            [
                3,
                "WAS"
            ],
            [
                1,
                "CHI"
            ],
            [
                2,
                "YYZ"
            ],
            [
                4,
                "PIT"
            ],
            [
                1,
                "HOU"
            ],
            [
                3,
                "PHL"
            ],
            [
                1,
                "DAL"
            ],
            [
                1,
                "DET"
            ],
            [
                1,
                "LON"
            ],
            [
                3,
                "NYC"
            ],
            [
                1,
                "LOS"
            ],
            [
                1,
                "ROC"
            ],
            [
                1,
                "PEK"
            ],
            [
                1,
                "SFO"
            ],
            [
                1,
                "ATL"
            ],
            [
                1,
                "NAR"
            ],
            [
                1,
                "BOS"
            ]
        ]
    },
    {
        "db_id": "dorm_1",
        "query": "What is the average age for each city and what are those cities?",
        "sql_query": "SELECT avg(age) ,  city_code FROM student GROUP BY city_code",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "age"
                    }
                },
                {
                    "value": "city_code"
                }
            ],
            "from": "student",
            "groupby": {
                "value": "city_code"
            }
        },
        "sql_ans": [
            [
                20.0,
                "ATL"
            ],
            [
                18.5,
                "BAL"
            ],
            [
                18.0,
                "BOS"
            ],
            [
                20.0,
                "CHI"
            ],
            [
                18.0,
                "DAL"
            ],
            [
                17.0,
                "DET"
            ],
            [
                18.0,
                "HKG"
            ],
            [
                17.0,
                "HOU"
            ],
            [
                27.0,
                "LON"
            ],
            [
                18.0,
                "LOS"
            ],
            [
                18.0,
                "NAR"
            ],
            [
                20.333333333333332,
                "NYC"
            ],
            [
                17.0,
                "PEK"
            ],
            [
                19.666666666666668,
                "PHL"
            ],
            [
                19.0,
                "PIT"
            ],
            [
                20.0,
                "ROC"
            ],
            [
                21.0,
                "SFO"
            ],
            [
                21.666666666666668,
                "WAS"
            ],
            [
                22.5,
                "YYZ"
            ]
        ],
        "cypher_query": "MATCH (student:`dorm_1.Student`)\nWITH student.city_code AS city_code, count(student.city_code) AS count\nRETURN count,city_code",
        "cypher_ans": [
            [
                4,
                "BAL"
            ],
            [
                3,
                "HKG"
            ],
            [
                3,
                "WAS"
            ],
            [
                1,
                "CHI"
            ],
            [
                2,
                "YYZ"
            ],
            [
                4,
                "PIT"
            ],
            [
                1,
                "HOU"
            ],
            [
                3,
                "PHL"
            ],
            [
                1,
                "DAL"
            ],
            [
                1,
                "DET"
            ],
            [
                1,
                "LON"
            ],
            [
                3,
                "NYC"
            ],
            [
                1,
                "LOS"
            ],
            [
                1,
                "ROC"
            ],
            [
                1,
                "PEK"
            ],
            [
                1,
                "SFO"
            ],
            [
                1,
                "ATL"
            ],
            [
                1,
                "NAR"
            ],
            [
                1,
                "BOS"
            ]
        ]
    },
    {
        "db_id": "dorm_1",
        "query": "Find the number of dorms that have some amenity.",
        "sql_query": "SELECT count(DISTINCT dormid) FROM has_amenity",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "dormid"
                        }
                    }
                }
            },
            "from": "has_amenity"
        },
        "sql_ans": [
            [
                7
            ]
        ],
        "cypher_query": "MATCH (has_amenity:`dorm_1.Has_amenity`)\nRETURN count(DISTINCT has_amenity.dormid)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "dorm_1",
        "query": "How many dorms have amenities?",
        "sql_query": "SELECT count(DISTINCT dormid) FROM has_amenity",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "dormid"
                        }
                    }
                }
            },
            "from": "has_amenity"
        },
        "sql_ans": [
            [
                7
            ]
        ],
        "cypher_query": "MATCH (has_amenity:`dorm_1.Has_amenity`)\nRETURN count(DISTINCT has_amenity.dormid)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "dorm_1",
        "query": "Find the name of dorms that do not have any amenity",
        "sql_query": "SELECT dorm_name FROM dorm WHERE dormid NOT IN (SELECT dormid FROM has_amenity)",
        "parsed_sql": {
            "select": {
                "value": "dorm_name"
            },
            "from": "dorm",
            "where": {
                "nin": [
                    "dormid",
                    {
                        "select": {
                            "value": "dormid"
                        },
                        "from": "has_amenity"
                    }
                ]
            }
        },
        "sql_ans": [],
        "cypher_query": "MATCH (dorm:`dorm_1.Dorm`)\nWHERE NOT (dorm:`dorm_1.Dorm`)-[]-(:`dorm_1.Has_amenity`)\nRETURN dorm.dorm_name",
        "cypher_ans": [
            [
                "Smith Hall"
            ],
            [
                "Bud Jones Hall"
            ],
            [
                "Fawlty Towers"
            ],
            [
                "Dorm-plex 2000"
            ],
            [
                "Anonymous Donor Hall"
            ],
            [
                "University Hovels"
            ],
            [
                "Grad Student Asylum"
            ]
        ]
    },
    {
        "db_id": "dorm_1",
        "query": "What are the names of all the dorms that don't have any amenities?",
        "sql_query": "SELECT dorm_name FROM dorm WHERE dormid NOT IN (SELECT dormid FROM has_amenity)",
        "parsed_sql": {
            "select": {
                "value": "dorm_name"
            },
            "from": "dorm",
            "where": {
                "nin": [
                    "dormid",
                    {
                        "select": {
                            "value": "dormid"
                        },
                        "from": "has_amenity"
                    }
                ]
            }
        },
        "sql_ans": [],
        "cypher_query": "MATCH (dorm:`dorm_1.Dorm`)\nWHERE NOT (dorm:`dorm_1.Dorm`)-[]-(:`dorm_1.Has_amenity`)\nRETURN dorm.dorm_name",
        "cypher_ans": [
            [
                "Smith Hall"
            ],
            [
                "Bud Jones Hall"
            ],
            [
                "Fawlty Towers"
            ],
            [
                "Dorm-plex 2000"
            ],
            [
                "Anonymous Donor Hall"
            ],
            [
                "University Hovels"
            ],
            [
                "Grad Student Asylum"
            ]
        ]
    },
    {
        "db_id": "dorm_1",
        "query": "Find the code of city where most of students are living in.",
        "sql_query": "SELECT city_code FROM student GROUP BY city_code ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "city_code"
            },
            "from": "student",
            "groupby": {
                "value": "city_code"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "PIT"
            ]
        ],
        "cypher_query": "MATCH (student:`dorm_1.Student`)\nWITH student.city_code AS city_code, count(student.city_code) AS count\nRETURN city_code\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "BAL"
            ]
        ]
    },
    {
        "db_id": "dorm_1",
        "query": "What is the code of the city with the most students?",
        "sql_query": "SELECT city_code FROM student GROUP BY city_code ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "city_code"
            },
            "from": "student",
            "groupby": {
                "value": "city_code"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "PIT"
            ]
        ],
        "cypher_query": "MATCH (student:`dorm_1.Student`)\nWITH student.city_code AS city_code, count(student.city_code) AS count\nRETURN city_code\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "BAL"
            ]
        ]
    },
    {
        "db_id": "dorm_1",
        "query": "Find the total number of students living in the male dorm (with gender M).",
        "sql_query": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "student",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "lives_in",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.stuid",
                            "T2.stuid"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "dorm",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T3.dormid",
                            "T2.dormid"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T3.gender",
                    {
                        "literal": "M"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T2:`dorm_1.Lives_in`)-[]-(T3:`dorm_1.Dorm`)-[]-(T1:`dorm_1.Student`)-[]-(T2:`dorm_1.Lives_in`)\nWHERE T3.gender = 'M'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "dorm_1",
        "query": "What are the total number of students who are living in a male dorm?",
        "sql_query": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.gender  =  'M'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "student",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "lives_in",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.stuid",
                            "T2.stuid"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "dorm",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T3.dormid",
                            "T2.dormid"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T3.gender",
                    {
                        "literal": "M"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (T2:`dorm_1.Lives_in`)-[]-(T3:`dorm_1.Dorm`)-[]-(T1:`dorm_1.Student`)-[]-(T2:`dorm_1.Lives_in`)\nWHERE T3.gender = 'M'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "dorm_1",
        "query": "Find the number of female students (with F sex) living in Smith Hall",
        "sql_query": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.dorm_name  =  'Smith Hall' AND T1.sex  =  'F'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "student",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "lives_in",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.stuid",
                            "T2.stuid"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "dorm",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T3.dormid",
                            "T2.dormid"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T3.dorm_name",
                            {
                                "literal": "Smith Hall"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "T1.sex",
                            {
                                "literal": "F"
                            }
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (T2:`dorm_1.Lives_in`)-[]-(T3:`dorm_1.Dorm`)-[]-(T1:`dorm_1.Student`)-[]-(T2:`dorm_1.Lives_in`)\nWHERE T3.dorm_name = 'Smith Hall' AND T1.Sex = 'F'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "dorm_1",
        "query": "How many female students live in Smith Hall?",
        "sql_query": "SELECT count(*) FROM student AS T1 JOIN lives_in AS T2 ON T1.stuid  =  T2.stuid JOIN dorm AS T3 ON T3.dormid  =  T2.dormid WHERE T3.dorm_name  =  'Smith Hall' AND T1.sex  =  'F'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "student",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "lives_in",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.stuid",
                            "T2.stuid"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "dorm",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T3.dormid",
                            "T2.dormid"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T3.dorm_name",
                            {
                                "literal": "Smith Hall"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "T1.sex",
                            {
                                "literal": "F"
                            }
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (T2:`dorm_1.Lives_in`)-[]-(T3:`dorm_1.Dorm`)-[]-(T1:`dorm_1.Student`)-[]-(T2:`dorm_1.Lives_in`)\nWHERE T3.dorm_name = 'Smith Hall' AND T1.Sex = 'F'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "customer_complaints",
        "query": "Which city has the least number of customers whose type code is \"Good Credit Rating\"?",
        "sql_query": "SELECT town_city FROM customers WHERE customer_type_code  =  \"Good Credit Rating\" GROUP BY town_city ORDER BY count(*) LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "town_city"
            },
            "from": "customers",
            "where": {
                "eq": [
                    "customer_type_code",
                    "Good Credit Rating"
                ]
            },
            "groupby": {
                "value": "town_city"
            },
            "orderby": {
                "value": {
                    "count": "*"
                }
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Hansenbury"
            ]
        ],
        "cypher_query": "MATCH (customers:`customer_complaints.Customers`)\nWHERE customers.customer_type_code = 'Good Credit Rating'\nWITH count(customers.town_city) AS count, customers.town_city AS town_city\nRETURN town_city\nORDER BY count\nLIMIT 1",
        "cypher_ans": [
            [
                "Maryamport"
            ]
        ]
    },
    {
        "db_id": "customer_complaints",
        "query": "Return the city with the customer type code \"Good Credit Rating\" that had the fewest customers.",
        "sql_query": "SELECT town_city FROM customers WHERE customer_type_code  =  \"Good Credit Rating\" GROUP BY town_city ORDER BY count(*) LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "town_city"
            },
            "from": "customers",
            "where": {
                "eq": [
                    "customer_type_code",
                    "Good Credit Rating"
                ]
            },
            "groupby": {
                "value": "town_city"
            },
            "orderby": {
                "value": {
                    "count": "*"
                }
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Hansenbury"
            ]
        ],
        "cypher_query": "MATCH (customers:`customer_complaints.Customers`)\nWHERE customers.customer_type_code = 'Good Credit Rating'\nWITH count(customers.town_city) AS count, customers.town_city AS town_city\nRETURN town_city\nORDER BY count\nLIMIT 1",
        "cypher_ans": [
            [
                "Maryamport"
            ]
        ]
    },
    {
        "db_id": "customer_complaints",
        "query": "What is the average price of the products for each category?",
        "sql_query": "SELECT avg(product_price) ,  product_category_code FROM products GROUP BY product_category_code",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "product_price"
                    }
                },
                {
                    "value": "product_category_code"
                }
            ],
            "from": "products",
            "groupby": {
                "value": "product_category_code"
            }
        },
        "sql_ans": [
            [
                35.0,
                "Book"
            ],
            [
                2.88,
                "Food"
            ],
            [
                66.67,
                "Hardware"
            ]
        ],
        "cypher_query": "MATCH (products:`customer_complaints.Products`)\nWITH count(products.product_category_code) AS count, products.product_category_code AS product_category_code\nRETURN count,product_category_code",
        "cypher_ans": [
            [
                1,
                "Food"
            ],
            [
                1,
                "Book"
            ],
            [
                2,
                "Hardware"
            ]
        ]
    },
    {
        "db_id": "customer_complaints",
        "query": "Return the average price of products that have each category code.",
        "sql_query": "SELECT avg(product_price) ,  product_category_code FROM products GROUP BY product_category_code",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "product_price"
                    }
                },
                {
                    "value": "product_category_code"
                }
            ],
            "from": "products",
            "groupby": {
                "value": "product_category_code"
            }
        },
        "sql_ans": [
            [
                35.0,
                "Book"
            ],
            [
                2.88,
                "Food"
            ],
            [
                66.67,
                "Hardware"
            ]
        ],
        "cypher_query": "MATCH (products:`customer_complaints.Products`)\nWITH count(products.product_category_code) AS count, products.product_category_code AS product_category_code\nRETURN count,product_category_code",
        "cypher_ans": [
            [
                1,
                "Food"
            ],
            [
                1,
                "Book"
            ],
            [
                2,
                "Hardware"
            ]
        ]
    },
    {
        "db_id": "customer_complaints",
        "query": "Which state has the most customers?",
        "sql_query": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "state"
            },
            "from": "customers",
            "groupby": {
                "value": "state"
            },
            "orderby": {
                "value": {
                    "count": "*"
                }
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Colorado"
            ]
        ],
        "cypher_query": "MATCH (customers:`customer_complaints.Customers`)\nWITH customers.state AS state, count(customers.state) AS count\nRETURN state\nORDER BY count\nLIMIT 1",
        "cypher_ans": [
            [
                "Kansas"
            ]
        ]
    },
    {
        "db_id": "customer_complaints",
        "query": "Give the state that has the most customers.",
        "sql_query": "SELECT state FROM customers GROUP BY state ORDER BY count(*) LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "state"
            },
            "from": "customers",
            "groupby": {
                "value": "state"
            },
            "orderby": {
                "value": {
                    "count": "*"
                }
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Colorado"
            ]
        ],
        "cypher_query": "MATCH (customers:`customer_complaints.Customers`)\nWITH customers.state AS state, count(customers.state) AS count\nRETURN state\nORDER BY count\nLIMIT 1",
        "cypher_ans": [
            [
                "Kansas"
            ]
        ]
    },
    {
        "db_id": "workshop_paper",
        "query": "What is the average score of submissions?",
        "sql_query": "SELECT avg(Scores) FROM submission",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "Scores"
                }
            },
            "from": "submission"
        },
        "sql_ans": [
            [
                82.9
            ]
        ],
        "cypher_query": "MATCH (submission:`workshop_paper.submission`)\nRETURN avg(submission.Scores)",
        "cypher_ans": [
            [
                82.89999999999999
            ]
        ]
    },
    {
        "db_id": "workshop_paper",
        "query": "Compute the average score of submissions.",
        "sql_query": "SELECT avg(Scores) FROM submission",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "Scores"
                }
            },
            "from": "submission"
        },
        "sql_ans": [
            [
                82.9
            ]
        ],
        "cypher_query": "MATCH (submission:`workshop_paper.submission`)\nRETURN avg(submission.Scores)",
        "cypher_ans": [
            [
                82.89999999999999
            ]
        ]
    },
    {
        "db_id": "workshop_paper",
        "query": "Show the most common college of authors of submissions.",
        "sql_query": "SELECT College FROM submission GROUP BY College ORDER BY COUNT(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "College"
            },
            "from": "submission",
            "groupby": {
                "value": "College"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "West Texas State"
            ]
        ],
        "cypher_query": "MATCH (submission:`workshop_paper.submission`)\nWITH count(submission.College) AS count, submission.College AS College\nRETURN College\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Notre Dame"
            ]
        ]
    },
    {
        "db_id": "workshop_paper",
        "query": "Which college has the most authors with submissions?",
        "sql_query": "SELECT College FROM submission GROUP BY College ORDER BY COUNT(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "College"
            },
            "from": "submission",
            "groupby": {
                "value": "College"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "West Texas State"
            ]
        ],
        "cypher_query": "MATCH (submission:`workshop_paper.submission`)\nWITH count(submission.College) AS count, submission.College AS College\nRETURN College\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Notre Dame"
            ]
        ]
    },
    {
        "db_id": "tracking_share_transactions",
        "query": "Show the minimum amount of transactions whose type code is \"PUR\" and whose share count is bigger than 50.",
        "sql_query": "SELECT min(amount_of_transaction) FROM TRANSACTIONS WHERE transaction_type_code  =  \"PUR\" AND share_count  >  50",
        "parsed_sql": {
            "select": {
                "value": {
                    "min": "amount_of_transaction"
                }
            },
            "from": "TRANSACTIONS",
            "where": {
                "and": [
                    {
                        "eq": [
                            "transaction_type_code",
                            "PUR"
                        ]
                    },
                    {
                        "gt": [
                            "share_count",
                            50
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (transactions:`tracking_share_transactions.Transactions`)\nWHERE transactions.transaction_type_code = 'PUR' AND transactions.share_count > 50\nRETURN min(transactions.amount_of_transaction)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "tracking_share_transactions",
        "query": "Show the average transaction amount for different transaction types.",
        "sql_query": "SELECT transaction_type_code ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY transaction_type_code",
        "parsed_sql": {
            "select": [
                {
                    "value": "transaction_type_code"
                },
                {
                    "value": {
                        "avg": "amount_of_transaction"
                    }
                }
            ],
            "from": "TRANSACTIONS",
            "groupby": {
                "value": "transaction_type_code"
            }
        },
        "sql_ans": [
            [
                "PUR",
                25945880.3716125
            ],
            [
                "SALE",
                11198167.237771427
            ]
        ],
        "cypher_query": "MATCH (transactions:`tracking_share_transactions.Transactions`)\nWITH count(transactions.transaction_type_code) AS count, transactions.transaction_type_code AS transaction_type_code\nRETURN transaction_type_code,count",
        "cypher_ans": [
            [
                "SALE",
                7
            ],
            [
                "PUR",
                8
            ]
        ]
    },
    {
        "db_id": "tracking_share_transactions",
        "query": "Show the average share count of transactions for different investors.",
        "sql_query": "SELECT investor_id ,  avg(share_count) FROM TRANSACTIONS GROUP BY investor_id",
        "parsed_sql": {
            "select": [
                {
                    "value": "investor_id"
                },
                {
                    "value": {
                        "avg": "share_count"
                    }
                }
            ],
            "from": "TRANSACTIONS",
            "groupby": {
                "value": "investor_id"
            }
        },
        "sql_ans": [
            [
                2,
                831668.0
            ],
            [
                3,
                225053304.33333334
            ],
            [
                6,
                8718572.0
            ],
            [
                7,
                1522.0
            ],
            [
                8,
                930.0
            ],
            [
                14,
                8040.0
            ],
            [
                17,
                96178.0
            ],
            [
                18,
                298.0
            ],
            [
                19,
                47971.0
            ],
            [
                20,
                0.0
            ]
        ],
        "cypher_query": "MATCH (transactions:`tracking_share_transactions.Transactions`)\nWITH transactions.investor_id AS investor_id, count(transactions.investor_id) AS count\nRETURN investor_id,count",
        "cypher_ans": [
            [
                6,
                1
            ],
            [
                18,
                2
            ],
            [
                2,
                2
            ],
            [
                14,
                1
            ],
            [
                8,
                1
            ],
            [
                19,
                2
            ],
            [
                7,
                1
            ],
            [
                17,
                1
            ],
            [
                20,
                1
            ],
            [
                3,
                3
            ]
        ]
    },
    {
        "db_id": "tracking_share_transactions",
        "query": "Show the average amount of transactions for different investors.",
        "sql_query": "SELECT investor_id ,  avg(amount_of_transaction) FROM TRANSACTIONS GROUP BY investor_id",
        "parsed_sql": {
            "select": [
                {
                    "value": "investor_id"
                },
                {
                    "value": {
                        "avg": "amount_of_transaction"
                    }
                }
            ],
            "from": "TRANSACTIONS",
            "groupby": {
                "value": "investor_id"
            }
        },
        "sql_ans": [
            [
                2,
                24403.6612
            ],
            [
                3,
                61.06666666666666
            ],
            [
                6,
                302507.6996
            ],
            [
                7,
                822.803
            ],
            [
                8,
                0.0
            ],
            [
                14,
                4.5263
            ],
            [
                17,
                78035671.4424
            ],
            [
                18,
                14.1285
            ],
            [
                19,
                103742065.5898
            ],
            [
                20,
                82057.207
            ]
        ],
        "cypher_query": "MATCH (transactions:`tracking_share_transactions.Transactions`)\nWITH transactions.investor_id AS investor_id, count(transactions.investor_id) AS count\nRETURN investor_id,count",
        "cypher_ans": [
            [
                6,
                1
            ],
            [
                18,
                2
            ],
            [
                2,
                2
            ],
            [
                14,
                1
            ],
            [
                8,
                1
            ],
            [
                19,
                2
            ],
            [
                7,
                1
            ],
            [
                17,
                1
            ],
            [
                20,
                1
            ],
            [
                3,
                3
            ]
        ]
    },
    {
        "db_id": "cre_Theme_park",
        "query": "Show the average price range of hotels that have 5 star ratings and allow pets.",
        "sql_query": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  \"5\" AND pets_allowed_yn  =  1",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "price_range"
                }
            },
            "from": "HOTELS",
            "where": {
                "and": [
                    {
                        "eq": [
                            "star_rating_code",
                            "5"
                        ]
                    },
                    {
                        "eq": [
                            "pets_allowed_yn",
                            1
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                170031784.62282422
            ]
        ],
        "cypher_query": "MATCH (hotels:`cre_Theme_park.Hotels`)\nWHERE hotels.star_rating_code = '5' AND hotels.pets_allowed_yn = 1\nRETURN avg(hotels.price_range)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "cre_Theme_park",
        "query": "What is the average price range of five star hotels that allow pets?",
        "sql_query": "SELECT avg(price_range) FROM HOTELS WHERE star_rating_code  =  \"5\" AND pets_allowed_yn  =  1",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "price_range"
                }
            },
            "from": "HOTELS",
            "where": {
                "and": [
                    {
                        "eq": [
                            "star_rating_code",
                            "5"
                        ]
                    },
                    {
                        "eq": [
                            "pets_allowed_yn",
                            1
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                170031784.62282422
            ]
        ],
        "cypher_query": "MATCH (hotels:`cre_Theme_park.Hotels`)\nWHERE hotels.star_rating_code = '5' AND hotels.pets_allowed_yn = 1\nRETURN avg(hotels.price_range)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "cre_Theme_park",
        "query": "Show the average price of hotels for each star rating code.",
        "sql_query": "SELECT star_rating_code ,  avg(price_range) FROM HOTELS GROUP BY star_rating_code",
        "parsed_sql": {
            "select": [
                {
                    "value": "star_rating_code"
                },
                {
                    "value": {
                        "avg": "price_range"
                    }
                }
            ],
            "from": "HOTELS",
            "groupby": {
                "value": "star_rating_code"
            }
        },
        "sql_ans": [
            [
                "1",
                12725.062543725
            ],
            [
                "2",
                96606.48756549998
            ],
            [
                "3",
                2763278.3206
            ],
            [
                "4",
                19007487.73924
            ],
            [
                "5",
                113509913.4784335
            ]
        ],
        "cypher_query": "MATCH (hotels:`cre_Theme_park.Hotels`)\nWITH count(hotels.star_rating_code) AS count, hotels.star_rating_code AS star_rating_code\nRETURN star_rating_code,count",
        "cypher_ans": [
            [
                "5",
                9
            ],
            [
                "4",
                2
            ],
            [
                "3",
                2
            ],
            [
                "1",
                4
            ],
            [
                "2",
                3
            ]
        ]
    },
    {
        "db_id": "cre_Theme_park",
        "query": "What is the average price range of hotels for each each star rating code?",
        "sql_query": "SELECT star_rating_code ,  avg(price_range) FROM HOTELS GROUP BY star_rating_code",
        "parsed_sql": {
            "select": [
                {
                    "value": "star_rating_code"
                },
                {
                    "value": {
                        "avg": "price_range"
                    }
                }
            ],
            "from": "HOTELS",
            "groupby": {
                "value": "star_rating_code"
            }
        },
        "sql_ans": [
            [
                "1",
                12725.062543725
            ],
            [
                "2",
                96606.48756549998
            ],
            [
                "3",
                2763278.3206
            ],
            [
                "4",
                19007487.73924
            ],
            [
                "5",
                113509913.4784335
            ]
        ],
        "cypher_query": "MATCH (hotels:`cre_Theme_park.Hotels`)\nWITH count(hotels.star_rating_code) AS count, hotels.star_rating_code AS star_rating_code\nRETURN star_rating_code,count",
        "cypher_ans": [
            [
                "5",
                9
            ],
            [
                "4",
                2
            ],
            [
                "3",
                2
            ],
            [
                "1",
                4
            ],
            [
                "2",
                3
            ]
        ]
    },
    {
        "db_id": "cre_Theme_park",
        "query": "Show the average price of hotels for different pet policy.",
        "sql_query": "SELECT pets_allowed_yn ,  avg(price_range) FROM HOTELS GROUP BY pets_allowed_yn",
        "parsed_sql": {
            "select": [
                {
                    "value": "pets_allowed_yn"
                },
                {
                    "value": {
                        "avg": "price_range"
                    }
                }
            ],
            "from": "HOTELS",
            "groupby": {
                "value": "pets_allowed_yn"
            }
        },
        "sql_ans": [
            [
                "",
                989295.7443080185
            ],
            [
                "1",
                81426646.37909974
            ]
        ],
        "cypher_query": "MATCH (hotels:`cre_Theme_park.Hotels`)\nWITH hotels.pets_allowed_yn AS pets_allowed_yn, count(hotels.pets_allowed_yn) AS count\nRETURN pets_allowed_yn,count",
        "cypher_ans": [
            [
                "1",
                13
            ],
            [
                "",
                7
            ]
        ]
    },
    {
        "db_id": "cre_Theme_park",
        "query": "What are the average prices of hotels grouped by their pet policy.",
        "sql_query": "SELECT pets_allowed_yn ,  avg(price_range) FROM HOTELS GROUP BY pets_allowed_yn",
        "parsed_sql": {
            "select": [
                {
                    "value": "pets_allowed_yn"
                },
                {
                    "value": {
                        "avg": "price_range"
                    }
                }
            ],
            "from": "HOTELS",
            "groupby": {
                "value": "pets_allowed_yn"
            }
        },
        "sql_ans": [
            [
                "",
                989295.7443080185
            ],
            [
                "1",
                81426646.37909974
            ]
        ],
        "cypher_query": "MATCH (hotels:`cre_Theme_park.Hotels`)\nWITH hotels.pets_allowed_yn AS pets_allowed_yn, count(hotels.pets_allowed_yn) AS count\nRETURN pets_allowed_yn,count",
        "cypher_ans": [
            [
                "1",
                13
            ],
            [
                "",
                7
            ]
        ]
    },
    {
        "db_id": "cre_Theme_park",
        "query": "How many tourists did not make any visit?",
        "sql_query": "SELECT count(*) FROM Visitors WHERE Tourist_ID NOT IN ( SELECT Tourist_ID FROM Visits )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Visitors",
            "where": {
                "nin": [
                    "Tourist_ID",
                    {
                        "select": {
                            "value": "Tourist_ID"
                        },
                        "from": "Visits"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                9
            ]
        ],
        "cypher_query": "MATCH (visitors:`cre_Theme_park.Visitors`)\nWHERE NOT (visitors:`cre_Theme_park.Visitors`)-[]-(:`cre_Theme_park.Visits`)\nRETURN count(*)",
        "cypher_ans": [
            [
                20
            ]
        ]
    },
    {
        "db_id": "cre_Theme_park",
        "query": "Count the number of tourists who did not visit any place.",
        "sql_query": "SELECT count(*) FROM Visitors WHERE Tourist_ID NOT IN ( SELECT Tourist_ID FROM Visits )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Visitors",
            "where": {
                "nin": [
                    "Tourist_ID",
                    {
                        "select": {
                            "value": "Tourist_ID"
                        },
                        "from": "Visits"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                9
            ]
        ],
        "cypher_query": "MATCH (visitors:`cre_Theme_park.Visitors`)\nWHERE NOT (visitors:`cre_Theme_park.Visitors`)-[]-(:`cre_Theme_park.Visits`)\nRETURN count(*)",
        "cypher_ans": [
            [
                20
            ]
        ]
    },
    {
        "db_id": "game_1",
        "query": "Which game type has most number of games?",
        "sql_query": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "gtype"
            },
            "from": "Video_games",
            "groupby": {
                "value": "gtype"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Walking Simulator"
            ]
        ],
        "cypher_query": "MATCH (video_games:`game_1.Video_Games`)\nWITH count(video_games.GType) AS count, video_games.GType AS GType\nRETURN GType\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Collectible card game"
            ]
        ]
    },
    {
        "db_id": "game_1",
        "query": "What type has the most games?",
        "sql_query": "SELECT gtype FROM Video_games GROUP BY gtype ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "gtype"
            },
            "from": "Video_games",
            "groupby": {
                "value": "gtype"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Walking Simulator"
            ]
        ],
        "cypher_query": "MATCH (video_games:`game_1.Video_Games`)\nWITH count(video_games.GType) AS count, video_games.GType AS GType\nRETURN GType\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Collectible card game"
            ]
        ]
    },
    {
        "db_id": "game_1",
        "query": "What is the first name and last name of the student who have most number of sports?",
        "sql_query": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "T2.Fname"
                },
                {
                    "value": "T2.Lname"
                }
            ],
            "from": [
                {
                    "value": "Sportsinfo",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Student",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.StuID",
                            "T2.StuID"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.StuID"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "David",
                "Shieber"
            ]
        ],
        "cypher_query": "MATCH (T1:`game_1.SportsInfo`)-[]-(T2:`game_1.Student`)\nWITH T2.LName AS LName, T2.Fname AS Fname, count(T1.StuID) AS count\nRETURN Fname,LName\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Arthur",
                "Pang"
            ]
        ]
    },
    {
        "db_id": "game_1",
        "query": "What is the first and last name of the student who played the most sports?",
        "sql_query": "SELECT T2.Fname ,  T2.Lname FROM Sportsinfo AS T1 JOIN Student AS T2 ON T1.StuID  =  T2.StuID GROUP BY T1.StuID ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "T2.Fname"
                },
                {
                    "value": "T2.Lname"
                }
            ],
            "from": [
                {
                    "value": "Sportsinfo",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Student",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.StuID",
                            "T2.StuID"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.StuID"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "David",
                "Shieber"
            ]
        ],
        "cypher_query": "MATCH (T1:`game_1.SportsInfo`)-[]-(T2:`game_1.Student`)\nWITH T2.LName AS LName, T2.Fname AS Fname, count(T1.StuID) AS count\nRETURN Fname,LName\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Arthur",
                "Pang"
            ]
        ]
    },
    {
        "db_id": "game_1",
        "query": "How many students play video games?",
        "sql_query": "SELECT count(DISTINCT StuID) FROM Plays_games",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "StuID"
                        }
                    }
                }
            },
            "from": "Plays_games"
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (plays_games:`game_1.Plays_Games`)\nRETURN count(DISTINCT plays_games.StuID)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "game_1",
        "query": "How many different students play games?",
        "sql_query": "SELECT count(DISTINCT StuID) FROM Plays_games",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "StuID"
                        }
                    }
                }
            },
            "from": "Plays_games"
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (plays_games:`game_1.Plays_Games`)\nRETURN count(DISTINCT plays_games.StuID)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "customers_and_addresses",
        "query": "What is the average amount of items ordered in each order?",
        "sql_query": "SELECT avg(order_quantity) FROM order_items",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "order_quantity"
                }
            },
            "from": "order_items"
        },
        "sql_ans": [
            [
                6.333333333333333
            ]
        ],
        "cypher_query": "MATCH (order_items:`customers_and_addresses.Order_Items`)\nRETURN avg(order_items.order_quantity)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "customers_and_addresses",
        "query": "Find the average order quantity per order.",
        "sql_query": "SELECT avg(order_quantity) FROM order_items",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "order_quantity"
                }
            },
            "from": "order_items"
        },
        "sql_ans": [
            [
                6.333333333333333
            ]
        ],
        "cypher_query": "MATCH (order_items:`customers_and_addresses.Order_Items`)\nRETURN avg(order_items.order_quantity)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "roller_coaster",
        "query": "Show the names of countries and the average speed of roller coasters from each country.",
        "sql_query": "SELECT T1.Name ,  avg(T2.Speed) FROM country AS T1 JOIN roller_coaster AS T2 ON T1.Country_ID  =  T2.Country_ID GROUP BY T1.Name",
        "parsed_sql": {
            "select": [
                {
                    "value": "T1.Name"
                },
                {
                    "value": {
                        "avg": "T2.Speed"
                    }
                }
            ],
            "from": [
                {
                    "value": "country",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "roller_coaster",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Country_ID",
                            "T2.Country_ID"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.Name"
            }
        },
        "sql_ans": [
            [
                "Austria",
                58.666666666666664
            ],
            [
                "Finland",
                47.45
            ],
            [
                "Sweden",
                67.0
            ]
        ],
        "cypher_query": "MATCH (T1:`roller_coaster.country`)-[]-(T2:`roller_coaster.roller_coaster`)\nWITH T1.Name AS Name, count(T1.Name) AS count\nRETURN Name,count",
        "cypher_ans": [
            [
                "Austria",
                3
            ],
            [
                "Finland",
                2
            ],
            [
                "Sweden",
                1
            ]
        ]
    },
    {
        "db_id": "roller_coaster",
        "query": "How many countries do not have an roller coaster longer than 3000?",
        "sql_query": "SELECT count(*) FROM country WHERE country_id NOT IN ( SELECT country_id FROM roller_coaster WHERE LENGTH  >  3000 )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "country",
            "where": {
                "nin": [
                    "country_id",
                    {
                        "select": {
                            "value": "country_id"
                        },
                        "from": "roller_coaster",
                        "where": {
                            "gt": [
                                "LENGTH",
                                3000
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1
            ]
        ],
        "cypher_query": "MATCH (country:`roller_coaster.country`)\nWHERE NOT (country:`roller_coaster.country`)-[]-(:`roller_coaster.roller_coaster { Length : 3000 }`)\nRETURN count(*)",
        "cypher_ans": [
            [
                3
            ]
        ]
    },
    {
        "db_id": "ship_1",
        "query": "Find the name and flag of ships that are not steered by any captain with Midshipman rank.",
        "sql_query": "SELECT name ,  flag FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain WHERE rank  =  'Midshipman')",
        "parsed_sql": {
            "select": [
                {
                    "value": "name"
                },
                {
                    "value": "flag"
                }
            ],
            "from": "ship",
            "where": {
                "nin": [
                    "ship_id",
                    {
                        "select": {
                            "value": "ship_id"
                        },
                        "from": "captain",
                        "where": {
                            "eq": [
                                "rank",
                                {
                                    "literal": "Midshipman"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "HMS Destiny",
                "Panama"
            ],
            [
                "HMS Trojan",
                "Panama"
            ],
            [
                "HM Sloop Sparrow",
                "Panama"
            ],
            [
                "HMS Phalarope",
                "Panama"
            ],
            [
                "HMS Undine",
                "Malta"
            ]
        ],
        "cypher_query": "MATCH (ship:`ship_1.Ship`)\nWHERE NOT (ship:`ship_1.Ship`)-[]-(:`ship_1.captain { Rank : 'Midshipman' }`)\nRETURN ship.Name,ship.Flag",
        "cypher_ans": [
            [
                "HMS Manxman",
                "Panama"
            ],
            [
                "HMS Gorgon",
                "Panama"
            ],
            [
                "HM Cutter Avenger",
                "Panama"
            ],
            [
                "HM Schooner Hotspur",
                "Panama"
            ],
            [
                "HMS Destiny",
                "Panama"
            ],
            [
                "HMS Trojan",
                "Panama"
            ],
            [
                "HM Sloop Sparrow",
                "Panama"
            ],
            [
                "HMS Phalarope",
                "Panama"
            ],
            [
                "HMS Undine",
                "Malta"
            ]
        ]
    },
    {
        "db_id": "ship_1",
        "query": "What are the names and flags of ships that do not have a captain with the rank of Midshipman?",
        "sql_query": "SELECT name ,  flag FROM ship WHERE ship_id NOT IN (SELECT ship_id FROM captain WHERE rank  =  'Midshipman')",
        "parsed_sql": {
            "select": [
                {
                    "value": "name"
                },
                {
                    "value": "flag"
                }
            ],
            "from": "ship",
            "where": {
                "nin": [
                    "ship_id",
                    {
                        "select": {
                            "value": "ship_id"
                        },
                        "from": "captain",
                        "where": {
                            "eq": [
                                "rank",
                                {
                                    "literal": "Midshipman"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                "HMS Destiny",
                "Panama"
            ],
            [
                "HMS Trojan",
                "Panama"
            ],
            [
                "HM Sloop Sparrow",
                "Panama"
            ],
            [
                "HMS Phalarope",
                "Panama"
            ],
            [
                "HMS Undine",
                "Malta"
            ]
        ],
        "cypher_query": "MATCH (ship:`ship_1.Ship`)\nWHERE NOT (ship:`ship_1.Ship`)-[]-(:`ship_1.captain { Rank : 'Midshipman' }`)\nRETURN ship.Name,ship.Flag",
        "cypher_ans": [
            [
                "HMS Manxman",
                "Panama"
            ],
            [
                "HMS Gorgon",
                "Panama"
            ],
            [
                "HM Cutter Avenger",
                "Panama"
            ],
            [
                "HM Schooner Hotspur",
                "Panama"
            ],
            [
                "HMS Destiny",
                "Panama"
            ],
            [
                "HMS Trojan",
                "Panama"
            ],
            [
                "HM Sloop Sparrow",
                "Panama"
            ],
            [
                "HMS Phalarope",
                "Panama"
            ],
            [
                "HMS Undine",
                "Malta"
            ]
        ]
    },
    {
        "db_id": "flight_company",
        "query": "How many airports haven't the pilot 'Thompson' driven an aircraft?",
        "sql_query": "SELECT count(*) FROM airport WHERE id NOT IN ( SELECT airport_id FROM flight WHERE pilot  =  'Thompson' );",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "airport",
            "where": {
                "nin": [
                    "id",
                    {
                        "select": {
                            "value": "airport_id"
                        },
                        "from": "flight",
                        "where": {
                            "eq": [
                                "pilot",
                                {
                                    "literal": "Thompson"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (airport:`flight_company.airport`)\nWHERE NOT (airport:`flight_company.airport`)-[]-(:`flight_company.flight { Pilot : 'Thompson' }`)\nRETURN count(*)",
        "cypher_ans": [
            [
                9
            ]
        ]
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "query": "How many documents do not have any expense?",
        "sql_query": "SELECT count(*) FROM Documents WHERE document_id NOT IN ( SELECT document_id FROM Documents_with_expenses )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Documents",
            "where": {
                "nin": [
                    "document_id",
                    {
                        "select": {
                            "value": "document_id"
                        },
                        "from": "Documents_with_expenses"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (documents:`cre_Docs_and_Epenses.Documents`)\nWHERE NOT (documents:`cre_Docs_and_Epenses.Documents`)-[]-(:`cre_Docs_and_Epenses.Documents_with_Expenses`)\nRETURN count(*)",
        "cypher_ans": [
            [
                15
            ]
        ]
    },
    {
        "db_id": "cre_Docs_and_Epenses",
        "query": "Count the number of documents that do not have expenses.",
        "sql_query": "SELECT count(*) FROM Documents WHERE document_id NOT IN ( SELECT document_id FROM Documents_with_expenses )",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "Documents",
            "where": {
                "nin": [
                    "document_id",
                    {
                        "select": {
                            "value": "document_id"
                        },
                        "from": "Documents_with_expenses"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                5
            ]
        ],
        "cypher_query": "MATCH (documents:`cre_Docs_and_Epenses.Documents`)\nWHERE NOT (documents:`cre_Docs_and_Epenses.Documents`)-[]-(:`cre_Docs_and_Epenses.Documents_with_Expenses`)\nRETURN count(*)",
        "cypher_ans": [
            [
                15
            ]
        ]
    },
    {
        "db_id": "scientist_1",
        "query": "How many different scientists are assigned to any project?",
        "sql_query": "SELECT count(DISTINCT scientist) FROM assignedto",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "scientist"
                        }
                    }
                }
            },
            "from": "assignedto"
        },
        "sql_ans": [
            [
                12
            ]
        ],
        "cypher_query": "MATCH ()-[assignedto:`scientist_1.AssignedTo`]-()\nRETURN count(DISTINCT assignedto.Scientist)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "scientist_1",
        "query": "Count the number of different scientists assigned to any project.",
        "sql_query": "SELECT count(DISTINCT scientist) FROM assignedto",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "scientist"
                        }
                    }
                }
            },
            "from": "assignedto"
        },
        "sql_ans": [
            [
                12
            ]
        ],
        "cypher_query": "MATCH ()-[assignedto:`scientist_1.AssignedTo`]-()\nRETURN count(DISTINCT assignedto.Scientist)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "scientist_1",
        "query": "Find the average hours of all projects.",
        "sql_query": "SELECT avg(hours) FROM projects",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "hours"
                }
            },
            "from": "projects"
        },
        "sql_ans": [
            [
                1441.642857142857
            ]
        ],
        "cypher_query": "MATCH (projects:`scientist_1.Projects`)\nRETURN avg(projects.Hours)",
        "cypher_ans": [
            [
                1441.6428571428573
            ]
        ]
    },
    {
        "db_id": "scientist_1",
        "query": "What is the average hours across all projects?",
        "sql_query": "SELECT avg(hours) FROM projects",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "hours"
                }
            },
            "from": "projects"
        },
        "sql_ans": [
            [
                1441.642857142857
            ]
        ],
        "cypher_query": "MATCH (projects:`scientist_1.Projects`)\nRETURN avg(projects.Hours)",
        "cypher_ans": [
            [
                1441.6428571428573
            ]
        ]
    },
    {
        "db_id": "scientist_1",
        "query": "Find the name and hours of project that has the most number of scientists.",
        "sql_query": "SELECT T1.name ,  T1.hours FROM projects AS T1 JOIN assignedto AS T2 ON T1.code  =  T2.project GROUP BY T2.project ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "T1.name"
                },
                {
                    "value": "T1.hours"
                }
            ],
            "from": [
                {
                    "value": "projects",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "assignedto",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.code",
                            "T2.project"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T2.project"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Build Your Own Telescope",
                6546
            ]
        ],
        "cypher_query": "MATCH (T1:`scientist_1.Projects`)-[T2:`scientist_1.AssignedTo`]-()\nWITH count(T2.project) AS count, T1.Hours AS Hours, T1.Name AS Name\nRETURN Name,Hours\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Winds: Studying Bernoullis Principle",
                156
            ]
        ]
    },
    {
        "db_id": "scientist_1",
        "query": "What is the name and hours for the project which has the most scientists assigned to it?",
        "sql_query": "SELECT T1.name ,  T1.hours FROM projects AS T1 JOIN assignedto AS T2 ON T1.code  =  T2.project GROUP BY T2.project ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": [
                {
                    "value": "T1.name"
                },
                {
                    "value": "T1.hours"
                }
            ],
            "from": [
                {
                    "value": "projects",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "assignedto",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.code",
                            "T2.project"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T2.project"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Build Your Own Telescope",
                6546
            ]
        ],
        "cypher_query": "MATCH (T1:`scientist_1.Projects`)-[T2:`scientist_1.AssignedTo`]-()\nWITH count(T2.project) AS count, T1.Hours AS Hours, T1.Name AS Name\nRETURN Name,Hours\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Winds: Studying Bernoullis Principle",
                156
            ]
        ]
    },
    {
        "db_id": "wine_1",
        "query": "How many wines are produced at Robert Biale winery?",
        "sql_query": "SELECT count(*) FROM WINE WHERE Winery  =  \"Robert Biale\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "WINE",
            "where": {
                "eq": [
                    "Winery",
                    "Robert Biale"
                ]
            }
        },
        "sql_ans": [
            [
                4
            ]
        ],
        "cypher_query": "MATCH (wine:`wine_1.wine`)\nWHERE wine.Winery = 'Robert Biale'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "wine_1",
        "query": "Count the number of wines produced at Robert Biale winery.",
        "sql_query": "SELECT count(*) FROM WINE WHERE Winery  =  \"Robert Biale\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "WINE",
            "where": {
                "eq": [
                    "Winery",
                    "Robert Biale"
                ]
            }
        },
        "sql_ans": [
            [
                4
            ]
        ],
        "cypher_query": "MATCH (wine:`wine_1.wine`)\nWHERE wine.Winery = 'Robert Biale'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "wine_1",
        "query": "Give me the average prices of wines that are produced by appelations in Sonoma County.",
        "sql_query": "SELECT AVG(T2.Price) FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  \"Sonoma\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T2.Price"
                }
            },
            "from": [
                {
                    "value": "APPELLATIONS",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "WINE",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Appelation",
                            "T2.Appelation"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.County",
                    "Sonoma"
                ]
            }
        },
        "sql_ans": [
            [
                43.5
            ]
        ],
        "cypher_query": "MATCH (T1:`wine_1.appellations`)-[]-(T2:`wine_1.wine`)\nWHERE T1.County = 'Sonoma'\nRETURN avg(T2.Price)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "wine_1",
        "query": "What is the average price of wines produced in appelations in Sonoma County?",
        "sql_query": "SELECT AVG(T2.Price) FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  \"Sonoma\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "T2.Price"
                }
            },
            "from": [
                {
                    "value": "APPELLATIONS",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "WINE",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Appelation",
                            "T2.Appelation"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.County",
                    "Sonoma"
                ]
            }
        },
        "sql_ans": [
            [
                43.5
            ]
        ],
        "cypher_query": "MATCH (T1:`wine_1.appellations`)-[]-(T2:`wine_1.wine`)\nWHERE T1.County = 'Sonoma'\nRETURN avg(T2.Price)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "wine_1",
        "query": "Find the maximum price of wins from the appelations in Central Coast area and produced before the year of 2005.",
        "sql_query": "SELECT max(T2.Price) FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.Area  =  \"Central Coast\" AND T2.year  <  2005",
        "parsed_sql": {
            "select": {
                "value": {
                    "max": "T2.Price"
                }
            },
            "from": [
                {
                    "value": "APPELLATIONS",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "WINE",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Appelation",
                            "T2.Appelation"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.Area",
                            "Central Coast"
                        ]
                    },
                    {
                        "lt": [
                            "T2.year",
                            2005
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                60
            ]
        ],
        "cypher_query": "MATCH (T1:`wine_1.appellations`)-[]-(T2:`wine_1.wine`)\nWHERE T1.Area = 'Central Coast' AND T2.Year < 2005\nRETURN max(T2.Price)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "wine_1",
        "query": "What is the maximum price of wines from the appelation in the Central Coast area, which was produced before 2005?",
        "sql_query": "SELECT max(T2.Price) FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.Area  =  \"Central Coast\" AND T2.year  <  2005",
        "parsed_sql": {
            "select": {
                "value": {
                    "max": "T2.Price"
                }
            },
            "from": [
                {
                    "value": "APPELLATIONS",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "WINE",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.Appelation",
                            "T2.Appelation"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.Area",
                            "Central Coast"
                        ]
                    },
                    {
                        "lt": [
                            "T2.year",
                            2005
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                60
            ]
        ],
        "cypher_query": "MATCH (T1:`wine_1.appellations`)-[]-(T2:`wine_1.wine`)\nWHERE T1.Area = 'Central Coast' AND T2.Year < 2005\nRETURN max(T2.Price)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "wine_1",
        "query": "What are the average prices and cases of wines produced in the year of 2009 and made of Zinfandel grape?",
        "sql_query": "SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "Price"
                    }
                },
                {
                    "value": {
                        "avg": "Cases"
                    }
                }
            ],
            "from": "WINE",
            "where": {
                "and": [
                    {
                        "eq": [
                            "YEAR",
                            2009
                        ]
                    },
                    {
                        "eq": [
                            "Grape",
                            "Zinfandel"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                18.0,
                15000.0
            ]
        ],
        "cypher_query": "MATCH (wine:`wine_1.wine`)\nWHERE wine.Year = 2009 AND wine.Grape = 'Zinfandel'\nRETURN avg(wine.Price),avg(wine.Cases)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "wine_1",
        "query": "Give the average price and case of wines made from Zinfandel grapes in the year 2009.",
        "sql_query": "SELECT AVG(Price) ,  AVG(Cases) FROM WINE WHERE YEAR  =  2009 AND Grape  =  \"Zinfandel\"",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "Price"
                    }
                },
                {
                    "value": {
                        "avg": "Cases"
                    }
                }
            ],
            "from": "WINE",
            "where": {
                "and": [
                    {
                        "eq": [
                            "YEAR",
                            2009
                        ]
                    },
                    {
                        "eq": [
                            "Grape",
                            "Zinfandel"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                18.0,
                15000.0
            ]
        ],
        "cypher_query": "MATCH (wine:`wine_1.wine`)\nWHERE wine.Year = 2009 AND wine.Grape = 'Zinfandel'\nRETURN avg(wine.Price),avg(wine.Cases)",
        "cypher_ans": [
            [
                null,
                null
            ]
        ]
    },
    {
        "db_id": "wine_1",
        "query": "Find the average price of wines that are not produced from Sonoma county.",
        "sql_query": "SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "price"
                }
            },
            "from": "wine",
            "where": {
                "nin": [
                    "Appelation",
                    {
                        "select": {
                            "value": "T1.Appelation"
                        },
                        "from": [
                            {
                                "value": "APPELLATIONS",
                                "name": "T1",
                                "is_table": true
                            },
                            {
                                "join": {
                                    "name": "T2",
                                    "value": "WINE",
                                    "is_table": true
                                },
                                "on": {
                                    "eq": [
                                        "T1.Appelation",
                                        "T2.Appelation"
                                    ]
                                }
                            }
                        ],
                        "where": {
                            "eq": [
                                "T1.County",
                                {
                                    "literal": "Sonoma"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                46.53503184713376
            ]
        ],
        "cypher_query": "MATCH (wine:`wine_1.wine`)\nWHERE NOT (wine:`wine_1.wine`)-[]-(:`wine_1.appellations { County : 'Sonoma' }`)-[]-(:`wine_1.wine`)\nRETURN avg(wine.Price)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "wine_1",
        "query": "What is the average price for wines not produced in Sonoma county?",
        "sql_query": "SELECT avg(price) FROM wine WHERE Appelation NOT IN (SELECT T1.Appelation FROM APPELLATIONS AS T1 JOIN WINE AS T2 ON T1.Appelation  =  T2.Appelation WHERE T1.County  =  'Sonoma')",
        "parsed_sql": {
            "select": {
                "value": {
                    "avg": "price"
                }
            },
            "from": "wine",
            "where": {
                "nin": [
                    "Appelation",
                    {
                        "select": {
                            "value": "T1.Appelation"
                        },
                        "from": [
                            {
                                "value": "APPELLATIONS",
                                "name": "T1",
                                "is_table": true
                            },
                            {
                                "join": {
                                    "name": "T2",
                                    "value": "WINE",
                                    "is_table": true
                                },
                                "on": {
                                    "eq": [
                                        "T1.Appelation",
                                        "T2.Appelation"
                                    ]
                                }
                            }
                        ],
                        "where": {
                            "eq": [
                                "T1.County",
                                {
                                    "literal": "Sonoma"
                                }
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                46.53503184713376
            ]
        ],
        "cypher_query": "MATCH (wine:`wine_1.wine`)\nWHERE NOT (wine:`wine_1.wine`)-[]-(:`wine_1.appellations { County : 'Sonoma' }`)-[]-(:`wine_1.wine`)\nRETURN avg(wine.Price)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "train_station",
        "query": "What is the average and maximum number of total passengers for train stations in London or Glasgow?",
        "sql_query": "SELECT avg(total_passengers) ,  max(total_passengers) FROM station WHERE LOCATION  =  'London' OR LOCATION  =  'Glasgow'",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "avg": "total_passengers"
                    }
                },
                {
                    "value": {
                        "max": "total_passengers"
                    }
                }
            ],
            "from": "station",
            "where": {
                "or": [
                    {
                        "eq": [
                            "LOCATION",
                            {
                                "literal": "London"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "LOCATION",
                            {
                                "literal": "Glasgow"
                            }
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                48.01500000000001,
                103.534
            ]
        ],
        "cypher_query": "MATCH (station:`train_station.station`)\nWHERE station.Location = 'London' OR station.Location = 'Glasgow'\nRETURN avg(station.Total_Passengers),max(station.Total_Passengers)",
        "cypher_ans": [
            [
                48.015,
                103.534
            ]
        ]
    },
    {
        "db_id": "train_station",
        "query": "Show the station name and number of trains in each station.",
        "sql_query": "SELECT T2.name ,  count(*) FROM train_station AS T1 JOIN station AS T2 ON T1.station_id  =  T2.station_id GROUP BY T1.station_id",
        "parsed_sql": {
            "select": [
                {
                    "value": "T2.name"
                },
                {
                    "value": {
                        "count": "*"
                    }
                }
            ],
            "from": [
                {
                    "value": "train_station",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "station",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.station_id",
                            "T2.station_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.station_id"
            }
        },
        "sql_ans": [
            [
                "London Waterloo",
                3
            ],
            [
                "London Victoria",
                1
            ],
            [
                "London Bridge",
                1
            ],
            [
                "London Euston",
                1
            ],
            [
                "London King's Cross",
                1
            ],
            [
                "Glasgow Central",
                2
            ],
            [
                "East Croydon",
                2
            ]
        ],
        "cypher_query": "MATCH ()-[T1:`train_station.train_station`]-(T2:`train_station.station`)\nWITH count(T1.Station_ID) AS count, T2.Name AS Name\nRETURN Name,count",
        "cypher_ans": [
            [
                "London Waterloo",
                0
            ],
            [
                "London Victoria",
                0
            ],
            [
                "London Bridge",
                0
            ],
            [
                "London Euston",
                0
            ],
            [
                "London King's Cross",
                0
            ],
            [
                "Glasgow Central",
                0
            ],
            [
                "East Croydon",
                0
            ]
        ]
    },
    {
        "db_id": "driving_school",
        "query": "What is maximum, minimum and average amount of outstanding of customer?",
        "sql_query": "SELECT max(amount_outstanding) ,  min(amount_outstanding) ,  avg(amount_outstanding) FROM Customers;",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "amount_outstanding"
                    }
                },
                {
                    "value": {
                        "min": "amount_outstanding"
                    }
                },
                {
                    "value": {
                        "avg": "amount_outstanding"
                    }
                }
            ],
            "from": "Customers"
        },
        "sql_ans": [
            [
                9500.0,
                255.0,
                5643.733333333334
            ]
        ],
        "cypher_query": "MATCH (customers:`driving_school.Customers`)\nRETURN max(customers.amount_outstanding),min(customers.amount_outstanding),avg(customers.amount_outstanding)",
        "cypher_ans": [
            [
                9500.0,
                255.0,
                5643.733333333333
            ]
        ]
    },
    {
        "db_id": "driving_school",
        "query": "What is the maximum, minimum, and average amount of money outsanding for all customers?",
        "sql_query": "SELECT max(amount_outstanding) ,  min(amount_outstanding) ,  avg(amount_outstanding) FROM Customers;",
        "parsed_sql": {
            "select": [
                {
                    "value": {
                        "max": "amount_outstanding"
                    }
                },
                {
                    "value": {
                        "min": "amount_outstanding"
                    }
                },
                {
                    "value": {
                        "avg": "amount_outstanding"
                    }
                }
            ],
            "from": "Customers"
        },
        "sql_ans": [
            [
                9500.0,
                255.0,
                5643.733333333334
            ]
        ],
        "cypher_query": "MATCH (customers:`driving_school.Customers`)\nRETURN max(customers.amount_outstanding),min(customers.amount_outstanding),avg(customers.amount_outstanding)",
        "cypher_ans": [
            [
                9500.0,
                255.0,
                5643.733333333333
            ]
        ]
    },
    {
        "db_id": "activity_1",
        "query": "Which building has most faculty members?",
        "sql_query": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "building"
            },
            "from": "Faculty",
            "groupby": {
                "value": "building"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Krieger"
            ]
        ],
        "cypher_query": "MATCH (faculty:`activity_1.Faculty`)\nWITH count(faculty.Building) AS count, faculty.Building AS Building\nRETURN Building\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Barton"
            ]
        ]
    },
    {
        "db_id": "activity_1",
        "query": "Find the building that has the largest number of faculty members.",
        "sql_query": "SELECT building FROM Faculty GROUP BY building ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "building"
            },
            "from": "Faculty",
            "groupby": {
                "value": "building"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Krieger"
            ]
        ],
        "cypher_query": "MATCH (faculty:`activity_1.Faculty`)\nWITH count(faculty.Building) AS count, faculty.Building AS Building\nRETURN Building\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "Barton"
            ]
        ]
    },
    {
        "db_id": "activity_1",
        "query": "Which rank has the smallest number of faculty members?",
        "sql_query": "SELECT rank FROM Faculty GROUP BY rank ORDER BY count(*) ASC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "rank"
            },
            "from": "Faculty",
            "groupby": {
                "value": "rank"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "asc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "AssocProf"
            ]
        ],
        "cypher_query": "MATCH (faculty:`activity_1.Faculty`)\nWITH count(faculty.Rank) AS count, faculty.Rank AS Rank\nRETURN Rank\nORDER BY count ASC\nLIMIT 1",
        "cypher_ans": [
            [
                "Instructor"
            ]
        ]
    },
    {
        "db_id": "activity_1",
        "query": "Find the faculty rank that has the least members.",
        "sql_query": "SELECT rank FROM Faculty GROUP BY rank ORDER BY count(*) ASC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "rank"
            },
            "from": "Faculty",
            "groupby": {
                "value": "rank"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "asc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "AssocProf"
            ]
        ],
        "cypher_query": "MATCH (faculty:`activity_1.Faculty`)\nWITH count(faculty.Rank) AS count, faculty.Rank AS Rank\nRETURN Rank\nORDER BY count ASC\nLIMIT 1",
        "cypher_ans": [
            [
                "Instructor"
            ]
        ]
    },
    {
        "db_id": "activity_1",
        "query": "How many faculty members participate in an activity?",
        "sql_query": "SELECT count(DISTINCT FacID) FROM Faculty_participates_in",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "FacID"
                        }
                    }
                }
            },
            "from": "Faculty_participates_in"
        },
        "sql_ans": [
            [
                18
            ]
        ],
        "cypher_query": "MATCH (faculty_participates_in:`activity_1.Faculty_Participates_in`)\nRETURN count(DISTINCT faculty_participates_in.FacID)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "activity_1",
        "query": "Give me the number of faculty members who participate in an activity",
        "sql_query": "SELECT count(DISTINCT FacID) FROM Faculty_participates_in",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "FacID"
                        }
                    }
                }
            },
            "from": "Faculty_participates_in"
        },
        "sql_ans": [
            [
                18
            ]
        ],
        "cypher_query": "MATCH (faculty_participates_in:`activity_1.Faculty_Participates_in`)\nRETURN count(DISTINCT faculty_participates_in.FacID)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "activity_1",
        "query": "How many activities does Mark Giuliano participate in?",
        "sql_query": "SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  \"Mark\" AND T1.lname  =  \"Giuliano\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "Faculty",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Faculty_participates_in",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.facID",
                            "T2.facID"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.fname",
                            "Mark"
                        ]
                    },
                    {
                        "eq": [
                            "T1.lname",
                            "Giuliano"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (T1:`activity_1.Faculty`)-[]-(T2:`activity_1.Faculty_Participates_in`)\nWHERE T1.Fname = 'Mark' AND T1.Lname = 'Giuliano'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "activity_1",
        "query": "Find the number of activities Mark Giuliano is involved in.",
        "sql_query": "SELECT count(*) FROM Faculty AS T1 JOIN Faculty_participates_in AS T2 ON T1.facID  =  T2.facID WHERE T1.fname  =  \"Mark\" AND T1.lname  =  \"Giuliano\"",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "Faculty",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "Faculty_participates_in",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.facID",
                            "T2.facID"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T1.fname",
                            "Mark"
                        ]
                    },
                    {
                        "eq": [
                            "T1.lname",
                            "Giuliano"
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                3
            ]
        ],
        "cypher_query": "MATCH (T1:`activity_1.Faculty`)-[]-(T2:`activity_1.Faculty_Participates_in`)\nWHERE T1.Fname = 'Mark' AND T1.Lname = 'Giuliano'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "How many airlines are there?",
        "sql_query": "SELECT count(*) FROM airlines",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "airlines"
        },
        "sql_ans": [
            [
                6162
            ]
        ],
        "cypher_query": "MATCH (airlines:`flight_4.airlines`)\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "What is the total number of airlines?",
        "sql_query": "SELECT count(*) FROM airlines",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "airlines"
        },
        "sql_ans": [
            [
                6162
            ]
        ],
        "cypher_query": "MATCH (airlines:`flight_4.airlines`)\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "How many airlines does Russia has?",
        "sql_query": "SELECT count(*) FROM airlines WHERE country  =  'Russia'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "airlines",
            "where": {
                "eq": [
                    "country",
                    {
                        "literal": "Russia"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                238
            ]
        ],
        "cypher_query": "MATCH (airlines:`flight_4.airlines`)\nWHERE airlines.country = 'Russia'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "What is the number of airlines based in Russia?",
        "sql_query": "SELECT count(*) FROM airlines WHERE country  =  'Russia'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "airlines",
            "where": {
                "eq": [
                    "country",
                    {
                        "literal": "Russia"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                238
            ]
        ],
        "cypher_query": "MATCH (airlines:`flight_4.airlines`)\nWHERE airlines.country = 'Russia'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "What is the maximum elevation of all airports in the country of Iceland?",
        "sql_query": "SELECT max(elevation) FROM airports WHERE country  =  'Iceland'",
        "parsed_sql": {
            "select": {
                "value": {
                    "max": "elevation"
                }
            },
            "from": "airports",
            "where": {
                "eq": [
                    "country",
                    {
                        "literal": "Iceland"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1030
            ]
        ],
        "cypher_query": "MATCH (airports:`flight_4.airports`)\nWHERE airports.country = 'Iceland'\nRETURN max(airports.elevation)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "What is the highest elevation of an airport in the country of Iceland?",
        "sql_query": "SELECT max(elevation) FROM airports WHERE country  =  'Iceland'",
        "parsed_sql": {
            "select": {
                "value": {
                    "max": "elevation"
                }
            },
            "from": "airports",
            "where": {
                "eq": [
                    "country",
                    {
                        "literal": "Iceland"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1030
            ]
        ],
        "cypher_query": "MATCH (airports:`flight_4.airports`)\nWHERE airports.country = 'Iceland'\nRETURN max(airports.elevation)",
        "cypher_ans": [
            [
                null
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "Find the number of airports whose name contain the word 'International'.",
        "sql_query": "SELECT count(*) FROM airports WHERE name LIKE '%International%'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "airports",
            "where": {
                "like": [
                    "name",
                    {
                        "literal": "%International%"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                876
            ]
        ],
        "cypher_query": "MATCH (airports:`flight_4.airports`)\nWHERE airports.name =~'.*[I|i]nternational.*'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "How many airports' names have the word Interanation in them?",
        "sql_query": "SELECT count(*) FROM airports WHERE name LIKE '%International%'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "airports",
            "where": {
                "like": [
                    "name",
                    {
                        "literal": "%International%"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                876
            ]
        ],
        "cypher_query": "MATCH (airports:`flight_4.airports`)\nWHERE airports.name =~'.*[I|i]nternational.*'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "How many different cities do have some airport in the country of Greenland?",
        "sql_query": "SELECT count(DISTINCT city) FROM airports WHERE country  =  'Greenland'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "city"
                        }
                    }
                }
            },
            "from": "airports",
            "where": {
                "eq": [
                    "country",
                    {
                        "literal": "Greenland"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                21
            ]
        ],
        "cypher_query": "MATCH (airports:`flight_4.airports`)\nWHERE airports.country = 'Greenland'\nRETURN count(DISTINCT airports.city)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "In how many cities are there airports in the country of Greenland?",
        "sql_query": "SELECT count(DISTINCT city) FROM airports WHERE country  =  'Greenland'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "city"
                        }
                    }
                }
            },
            "from": "airports",
            "where": {
                "eq": [
                    "country",
                    {
                        "literal": "Greenland"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                21
            ]
        ],
        "cypher_query": "MATCH (airports:`flight_4.airports`)\nWHERE airports.country = 'Greenland'\nRETURN count(DISTINCT airports.city)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "Find the number of routes operated by American Airlines.",
        "sql_query": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "airlines",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "routes",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.alid",
                            "T2.alid"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.name",
                    {
                        "literal": "American Airlines"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2352
            ]
        ],
        "cypher_query": "MATCH (T1:`flight_4.airlines`)-[]-(T2:`flight_4.routes`)\nWHERE T1.name = 'American Airlines'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "How many routes does American Airlines operate?",
        "sql_query": "SELECT count(*) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "airlines",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "routes",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.alid",
                            "T2.alid"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.name",
                    {
                        "literal": "American Airlines"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2352
            ]
        ],
        "cypher_query": "MATCH (T1:`flight_4.airlines`)-[]-(T2:`flight_4.routes`)\nWHERE T1.name = 'American Airlines'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "Find the number of routes whose destination airports are in Canada.",
        "sql_query": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE country  =  'Canada'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "airports",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "routes",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.apid",
                            "T2.dst_apid"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "country",
                    {
                        "literal": "Canada"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1847
            ]
        ],
        "cypher_query": "MATCH (T1:`flight_4.airports`)-[]-(T2:`flight_4.routes`)\nWHERE T1.country = 'Canada'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "How many routes end in a Canadian airport?",
        "sql_query": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE country  =  'Canada'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "airports",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "routes",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.apid",
                            "T2.dst_apid"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "country",
                    {
                        "literal": "Canada"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1847
            ]
        ],
        "cypher_query": "MATCH (T1:`flight_4.airports`)-[]-(T2:`flight_4.routes`)\nWHERE T1.country = 'Canada'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "Find the number of different airports which are the destinations of the American Airlines.",
        "sql_query": "SELECT count(DISTINCT dst_apid) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "dst_apid"
                        }
                    }
                }
            },
            "from": [
                {
                    "value": "airlines",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "routes",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.alid",
                            "T2.alid"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.name",
                    {
                        "literal": "American Airlines"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                431
            ]
        ],
        "cypher_query": "MATCH (T1:`flight_4.airlines`)-[]-(T2:`flight_4.routes`)\nWHERE T1.name = 'American Airlines'\nRETURN count(DISTINCT T2.dst_apid)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "What is the number of different different airports that are destinations for American Airlines?",
        "sql_query": "SELECT count(DISTINCT dst_apid) FROM airlines AS T1 JOIN routes AS T2 ON T1.alid  =  T2.alid WHERE T1.name  =  'American Airlines'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "dst_apid"
                        }
                    }
                }
            },
            "from": [
                {
                    "value": "airlines",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "routes",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.alid",
                            "T2.alid"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.name",
                    {
                        "literal": "American Airlines"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                431
            ]
        ],
        "cypher_query": "MATCH (T1:`flight_4.airlines`)-[]-(T2:`flight_4.routes`)\nWHERE T1.name = 'American Airlines'\nRETURN count(DISTINCT T2.dst_apid)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "Find the number of routes with destination airports in Italy.",
        "sql_query": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid WHERE T2.country  =  'Italy'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "routes",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "airports",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.dst_apid",
                            "T2.apid"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.country",
                    {
                        "literal": "Italy"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1779
            ]
        ],
        "cypher_query": "MATCH (T1:`flight_4.routes`)-[]-(T2:`flight_4.airports`)\nWHERE T2.country = 'Italy'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "What is the number of routes whose destinations are Italian airports?",
        "sql_query": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid WHERE T2.country  =  'Italy'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "routes",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "airports",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.dst_apid",
                            "T2.apid"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T2.country",
                    {
                        "literal": "Italy"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                1779
            ]
        ],
        "cypher_query": "MATCH (T1:`flight_4.routes`)-[]-(T2:`flight_4.airports`)\nWHERE T2.country = 'Italy'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "Return the number of routes with destination airport in Italy operated by the airline with name 'American Airlines'.",
        "sql_query": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  'Italy' AND T3.name  =  'American Airlines'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "routes",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "airports",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.dst_apid",
                            "T2.apid"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "airlines",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.alid",
                            "T3.alid"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T2.country",
                            {
                                "literal": "Italy"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "T3.name",
                            {
                                "literal": "American Airlines"
                            }
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                13
            ]
        ],
        "cypher_query": "MATCH (T3:`flight_4.airlines`)-[]-(T1:`flight_4.routes`)-[]-(T1:`flight_4.routes`)-[]-(T2:`flight_4.airports`)\nWHERE T2.country = 'Italy' AND T3.name = 'American Airlines'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "What is the number of routes operated by the airline American Airlines whose destinations are in Italy?",
        "sql_query": "SELECT count(*) FROM routes AS T1 JOIN airports AS T2 ON T1.dst_apid  =  T2.apid JOIN airlines AS T3 ON T1.alid  =  T3.alid WHERE T2.country  =  'Italy' AND T3.name  =  'American Airlines'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "routes",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "airports",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.dst_apid",
                            "T2.apid"
                        ]
                    }
                },
                {
                    "join": {
                        "name": "T3",
                        "value": "airlines",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.alid",
                            "T3.alid"
                        ]
                    }
                }
            ],
            "where": {
                "and": [
                    {
                        "eq": [
                            "T2.country",
                            {
                                "literal": "Italy"
                            }
                        ]
                    },
                    {
                        "eq": [
                            "T3.name",
                            {
                                "literal": "American Airlines"
                            }
                        ]
                    }
                ]
            }
        },
        "sql_ans": [
            [
                13
            ]
        ],
        "cypher_query": "MATCH (T3:`flight_4.airlines`)-[]-(T1:`flight_4.routes`)-[]-(T1:`flight_4.routes`)-[]-(T2:`flight_4.airports`)\nWHERE T2.country = 'Italy' AND T3.name = 'American Airlines'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "Find the number of routes that have destination John F Kennedy International Airport.",
        "sql_query": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "airports",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "routes",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.apid",
                            "T2.dst_apid"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.name",
                    {
                        "literal": "John F Kennedy International Airport"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                455
            ]
        ],
        "cypher_query": "MATCH (T1:`flight_4.airports`)-[]-(T2:`flight_4.routes`)\nWHERE T1.name = 'John F Kennedy International Airport'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "flight_4",
        "query": "What is the number of routes that end at John F Kennedy International Airport?",
        "sql_query": "SELECT count(*) FROM airports AS T1 JOIN routes AS T2 ON T1.apid  =  T2.dst_apid WHERE T1.name  =  'John F Kennedy International Airport'",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": [
                {
                    "value": "airports",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "routes",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.apid",
                            "T2.dst_apid"
                        ]
                    }
                }
            ],
            "where": {
                "eq": [
                    "T1.name",
                    {
                        "literal": "John F Kennedy International Airport"
                    }
                ]
            }
        },
        "sql_ans": [
            [
                455
            ]
        ],
        "cypher_query": "MATCH (T1:`flight_4.airports`)-[]-(T2:`flight_4.routes`)\nWHERE T1.name = 'John F Kennedy International Airport'\nRETURN count(*)",
        "cypher_ans": [
            [
                0
            ]
        ]
    },
    {
        "db_id": "tracking_orders",
        "query": "What is the name of the customer who has the most orders?",
        "sql_query": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T1.customer_name"
            },
            "from": [
                {
                    "value": "customers",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "orders",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.customer_id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.customer_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Jeramie"
            ]
        ],
        "cypher_query": "MATCH (T1:`tracking_orders.Customers`)-[]-(T2:`tracking_orders.Orders`)\nWITH T1.customer_name AS customer_name, count(T1.customer_id) AS count\nRETURN customer_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "George"
            ]
        ]
    },
    {
        "db_id": "tracking_orders",
        "query": "Which customer made the most orders? Find the customer name.",
        "sql_query": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T1.customer_name"
            },
            "from": [
                {
                    "value": "customers",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "orders",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.customer_id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.customer_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Jeramie"
            ]
        ],
        "cypher_query": "MATCH (T1:`tracking_orders.Customers`)-[]-(T2:`tracking_orders.Orders`)\nWITH T1.customer_name AS customer_name, count(T1.customer_id) AS count\nRETURN customer_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "George"
            ]
        ]
    },
    {
        "db_id": "tracking_orders",
        "query": "What is the customer id of the customer who has the most orders?",
        "sql_query": "SELECT T1.customer_id FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T1.customer_id"
            },
            "from": [
                {
                    "value": "customers",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "orders",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.customer_id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.customer_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                15
            ]
        ],
        "cypher_query": "MATCH (T1:`tracking_orders.Customers`)-[]-(T2:`tracking_orders.Orders`)\nWITH count(T1.customer_id) AS count, T1.customer_id AS customer_id\nRETURN customer_id\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                2
            ]
        ]
    },
    {
        "db_id": "tracking_orders",
        "query": "Find the id of the customer who made the most orders.",
        "sql_query": "SELECT T1.customer_id FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T1.customer_id"
            },
            "from": [
                {
                    "value": "customers",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "orders",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.customer_id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.customer_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                15
            ]
        ],
        "cypher_query": "MATCH (T1:`tracking_orders.Customers`)-[]-(T2:`tracking_orders.Orders`)\nWITH count(T1.customer_id) AS count, T1.customer_id AS customer_id\nRETURN customer_id\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                2
            ]
        ]
    },
    {
        "db_id": "tracking_orders",
        "query": "What is the name of the customer who has the largest number of orders?",
        "sql_query": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T1.customer_name"
            },
            "from": [
                {
                    "value": "customers",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "orders",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.customer_id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.customer_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Jeramie"
            ]
        ],
        "cypher_query": "MATCH (T1:`tracking_orders.Customers`)-[]-(T2:`tracking_orders.Orders`)\nWITH T1.customer_name AS customer_name, count(T1.customer_id) AS count\nRETURN customer_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "George"
            ]
        ]
    },
    {
        "db_id": "tracking_orders",
        "query": "Find the name of the customer who made the most orders.",
        "sql_query": "SELECT T1.customer_name FROM customers AS T1 JOIN orders AS T2 ON T1.customer_id = T2.customer_id GROUP BY T1.customer_id ORDER BY count(*) DESC LIMIT 1",
        "parsed_sql": {
            "select": {
                "value": "T1.customer_name"
            },
            "from": [
                {
                    "value": "customers",
                    "name": "T1",
                    "is_table": true
                },
                {
                    "join": {
                        "name": "T2",
                        "value": "orders",
                        "is_table": true
                    },
                    "on": {
                        "eq": [
                            "T1.customer_id",
                            "T2.customer_id"
                        ]
                    }
                }
            ],
            "groupby": {
                "value": "T1.customer_id"
            },
            "orderby": {
                "value": {
                    "count": "*"
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [
            [
                "Jeramie"
            ]
        ],
        "cypher_query": "MATCH (T1:`tracking_orders.Customers`)-[]-(T2:`tracking_orders.Orders`)\nWITH T1.customer_name AS customer_name, count(T1.customer_id) AS count\nRETURN customer_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                "George"
            ]
        ]
    },
    {
        "db_id": "architecture",
        "query": "How many architects haven't built a mill before year 1850?",
        "sql_query": "SELECT count(*) FROM architect WHERE id NOT IN ( SELECT architect_id FROM mill WHERE built_year  <  1850 );",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "*"
                }
            },
            "from": "architect",
            "where": {
                "nin": [
                    "id",
                    {
                        "select": {
                            "value": "architect_id"
                        },
                        "from": "mill",
                        "where": {
                            "lt": [
                                "built_year",
                                1850
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                2
            ]
        ],
        "cypher_query": "MATCH (architect:`architecture.architect`)\nWHERE NOT (architect:`architecture.architect`)-[]-(:`architecture.mill { built_year : 1850 }`)\nRETURN count(*)",
        "cypher_ans": [
            [
                5
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what are the states",
        "sql_query": "SELECT state_name FROM state;",
        "parsed_sql": {
            "select": {
                "value": "state_name"
            },
            "from": "state"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (state:`geo.state`)\nRETURN state.state_name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "list the states",
        "sql_query": "SELECT state_name FROM state;",
        "parsed_sql": {
            "select": {
                "value": "state_name"
            },
            "from": "state"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (state:`geo.state`)\nRETURN state.state_name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "give me all the states of usa",
        "sql_query": "SELECT state_name FROM state;",
        "parsed_sql": {
            "select": {
                "value": "state_name"
            },
            "from": "state"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (state:`geo.state`)\nRETURN state.state_name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what states have no bordering state",
        "sql_query": "SELECT state_name FROM state WHERE state_name NOT IN ( SELECT state_name FROM border_info );",
        "parsed_sql": {
            "select": {
                "value": "state_name"
            },
            "from": "state",
            "where": {
                "nin": [
                    "state_name",
                    {
                        "select": {
                            "value": "state_name"
                        },
                        "from": "border_info"
                    }
                ]
            }
        },
        "sql_ans": [],
        "cypher_query": "MATCH (state:`geo.state`)\nWHERE NOT (state:`geo.state`)-[:`geo.border_info`]-()\nRETURN state.state_name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "name the states which have no surrounding states",
        "sql_query": "SELECT state_name FROM state WHERE state_name NOT IN ( SELECT state_name FROM border_info );",
        "parsed_sql": {
            "select": {
                "value": "state_name"
            },
            "from": "state",
            "where": {
                "nin": [
                    "state_name",
                    {
                        "select": {
                            "value": "state_name"
                        },
                        "from": "border_info"
                    }
                ]
            }
        },
        "sql_ans": [],
        "cypher_query": "MATCH (state:`geo.state`)\nWHERE NOT (state:`geo.state`)-[:`geo.border_info`]-()\nRETURN state.state_name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "which states border no other states",
        "sql_query": "SELECT state_name FROM state WHERE state_name NOT IN ( SELECT state_name FROM border_info );",
        "parsed_sql": {
            "select": {
                "value": "state_name"
            },
            "from": "state",
            "where": {
                "nin": [
                    "state_name",
                    {
                        "select": {
                            "value": "state_name"
                        },
                        "from": "border_info"
                    }
                ]
            }
        },
        "sql_ans": [],
        "cypher_query": "MATCH (state:`geo.state`)\nWHERE NOT (state:`geo.state`)-[:`geo.border_info`]-()\nRETURN state.state_name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how high is the highest point in america",
        "sql_query": "SELECT MAX ( highest_elevation ) FROM highlow;",
        "parsed_sql": {
            "select": {
                "value": {
                    "max": "highest_elevation"
                }
            },
            "from": "highlow"
        },
        "sql_ans": [
            [
                null
            ]
        ],
        "cypher_query": "MATCH (highlow:`geo.highlow`)\nRETURN max(highlow.highest_elevation)",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what is the highest elevation in the united states",
        "sql_query": "SELECT MAX ( highest_elevation ) FROM highlow;",
        "parsed_sql": {
            "select": {
                "value": {
                    "max": "highest_elevation"
                }
            },
            "from": "highlow"
        },
        "sql_ans": [
            [
                null
            ]
        ],
        "cypher_query": "MATCH (highlow:`geo.highlow`)\nRETURN max(highlow.highest_elevation)",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what is the elevation of the highest point in the usa",
        "sql_query": "SELECT MAX ( highest_elevation ) FROM highlow;",
        "parsed_sql": {
            "select": {
                "value": {
                    "max": "highest_elevation"
                }
            },
            "from": "highlow"
        },
        "sql_ans": [
            [
                null
            ]
        ],
        "cypher_query": "MATCH (highlow:`geo.highlow`)\nRETURN max(highlow.highest_elevation)",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what is the height of the highest point in the usa",
        "sql_query": "SELECT MAX ( highest_elevation ) FROM highlow;",
        "parsed_sql": {
            "select": {
                "value": {
                    "max": "highest_elevation"
                }
            },
            "from": "highlow"
        },
        "sql_ans": [
            [
                null
            ]
        ],
        "cypher_query": "MATCH (highlow:`geo.highlow`)\nRETURN max(highlow.highest_elevation)",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how many cities are there in the united states",
        "sql_query": "SELECT COUNT ( city_name ) FROM city;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "city_name"
                }
            },
            "from": "city"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (city:`geo.city`)\nRETURN count(city.city_name)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how many cities does the usa have",
        "sql_query": "SELECT COUNT ( city_name ) FROM city;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "city_name"
                }
            },
            "from": "city"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (city:`geo.city`)\nRETURN count(city.city_name)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how many cities are there in the us",
        "sql_query": "SELECT COUNT ( city_name ) FROM city;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "city_name"
                }
            },
            "from": "city"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (city:`geo.city`)\nRETURN count(city.city_name)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how many cities are there in usa",
        "sql_query": "SELECT COUNT ( city_name ) FROM city;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "city_name"
                }
            },
            "from": "city"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (city:`geo.city`)\nRETURN count(city.city_name)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how many cities are there in us",
        "sql_query": "SELECT COUNT ( city_name ) FROM city;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "city_name"
                }
            },
            "from": "city"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (city:`geo.city`)\nRETURN count(city.city_name)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how many states are in the usa",
        "sql_query": "SELECT COUNT ( state_name ) FROM state;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "state_name"
                }
            },
            "from": "state"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (state:`geo.state`)\nRETURN count(state.state_name)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how many states are there",
        "sql_query": "SELECT COUNT ( state_name ) FROM state;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "state_name"
                }
            },
            "from": "state"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (state:`geo.state`)\nRETURN count(state.state_name)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how many states are there in the usa",
        "sql_query": "SELECT COUNT ( state_name ) FROM state;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "state_name"
                }
            },
            "from": "state"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (state:`geo.state`)\nRETURN count(state.state_name)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how many states does usa have",
        "sql_query": "SELECT COUNT ( state_name ) FROM state;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "state_name"
                }
            },
            "from": "state"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (state:`geo.state`)\nRETURN count(state.state_name)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how many states are in the united states",
        "sql_query": "SELECT COUNT ( state_name ) FROM state;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "state_name"
                }
            },
            "from": "state"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (state:`geo.state`)\nRETURN count(state.state_name)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how many states are there in united states",
        "sql_query": "SELECT COUNT ( state_name ) FROM state;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "state_name"
                }
            },
            "from": "state"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (state:`geo.state`)\nRETURN count(state.state_name)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what are the highest points of all the states",
        "sql_query": "SELECT highest_point FROM highlow;",
        "parsed_sql": {
            "select": {
                "value": "highest_point"
            },
            "from": "highlow"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (highlow:`geo.highlow`)\nRETURN highlow.highest_point",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what are the population densities of each us state",
        "sql_query": "SELECT density FROM state;",
        "parsed_sql": {
            "select": {
                "value": "density"
            },
            "from": "state"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (state:`geo.state`)\nRETURN state.density",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what river flows through the most states",
        "sql_query": "SELECT river_name FROM river GROUP BY ( river_name ) ORDER BY COUNT ( DISTINCT traverse ) DESC LIMIT 1;",
        "parsed_sql": {
            "select": {
                "value": "river_name"
            },
            "from": "river",
            "groupby": {
                "value": "river_name"
            },
            "orderby": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "traverse"
                        }
                    }
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH (river:`geo.river`)\nWITH river.river_name AS river_name, count(river.river_name) AS count\nRETURN river_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "which river goes through the most states",
        "sql_query": "SELECT river_name FROM river GROUP BY ( river_name ) ORDER BY COUNT ( DISTINCT traverse ) DESC LIMIT 1;",
        "parsed_sql": {
            "select": {
                "value": "river_name"
            },
            "from": "river",
            "groupby": {
                "value": "river_name"
            },
            "orderby": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "traverse"
                        }
                    }
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH (river:`geo.river`)\nWITH river.river_name AS river_name, count(river.river_name) AS count\nRETURN river_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "which river runs through most states",
        "sql_query": "SELECT river_name FROM river GROUP BY ( river_name ) ORDER BY COUNT ( DISTINCT traverse ) DESC LIMIT 1;",
        "parsed_sql": {
            "select": {
                "value": "river_name"
            },
            "from": "river",
            "groupby": {
                "value": "river_name"
            },
            "orderby": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "traverse"
                        }
                    }
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH (river:`geo.river`)\nWITH river.river_name AS river_name, count(river.river_name) AS count\nRETURN river_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "which river traverses most states",
        "sql_query": "SELECT river_name FROM river GROUP BY ( river_name ) ORDER BY COUNT ( DISTINCT traverse ) DESC LIMIT 1;",
        "parsed_sql": {
            "select": {
                "value": "river_name"
            },
            "from": "river",
            "groupby": {
                "value": "river_name"
            },
            "orderby": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "traverse"
                        }
                    }
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH (river:`geo.river`)\nWITH river.river_name AS river_name, count(river.river_name) AS count\nRETURN river_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what river traverses the most states",
        "sql_query": "SELECT river_name FROM river GROUP BY ( river_name ) ORDER BY COUNT ( DISTINCT traverse ) DESC LIMIT 1;",
        "parsed_sql": {
            "select": {
                "value": "river_name"
            },
            "from": "river",
            "groupby": {
                "value": "river_name"
            },
            "orderby": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "traverse"
                        }
                    }
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH (river:`geo.river`)\nWITH river.river_name AS river_name, count(river.river_name) AS count\nRETURN river_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "which river runs through the most states",
        "sql_query": "SELECT river_name FROM river GROUP BY ( river_name ) ORDER BY COUNT ( DISTINCT traverse ) DESC LIMIT 1;",
        "parsed_sql": {
            "select": {
                "value": "river_name"
            },
            "from": "river",
            "groupby": {
                "value": "river_name"
            },
            "orderby": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "traverse"
                        }
                    }
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH (river:`geo.river`)\nWITH river.river_name AS river_name, count(river.river_name) AS count\nRETURN river_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what river runs through the most states",
        "sql_query": "SELECT river_name FROM river GROUP BY ( river_name ) ORDER BY COUNT ( DISTINCT traverse ) DESC LIMIT 1;",
        "parsed_sql": {
            "select": {
                "value": "river_name"
            },
            "from": "river",
            "groupby": {
                "value": "river_name"
            },
            "orderby": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "traverse"
                        }
                    }
                },
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH (river:`geo.river`)\nWITH river.river_name AS river_name, count(river.river_name) AS count\nRETURN river_name\nORDER BY count DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "where are mountains",
        "sql_query": "SELECT state_name FROM mountain;",
        "parsed_sql": {
            "select": {
                "value": "state_name"
            },
            "from": "mountain"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (mountain:`geo.mountain`)\nRETURN mountain.state_name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "which rivers do not run through tennessee",
        "sql_query": "SELECT river_name FROM river WHERE river_name NOT IN ( SELECT river_name FROM river WHERE traverse  =  \"tennessee\" );",
        "parsed_sql": {
            "select": {
                "value": "river_name"
            },
            "from": "river",
            "where": {
                "nin": [
                    "river_name",
                    {
                        "select": {
                            "value": "river_name"
                        },
                        "from": "river",
                        "where": {
                            "eq": [
                                "traverse",
                                "tennessee"
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [],
        "cypher_query": "MATCH (river:`geo.river`)\nWHERE NOT (river:`geo.river`)-[]-(:`geo.river { traverse : 'tennessee' }`)\nRETURN river.river_name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what rivers do not run through tennessee",
        "sql_query": "SELECT river_name FROM river WHERE river_name NOT IN ( SELECT river_name FROM river WHERE traverse  =  \"tennessee\" );",
        "parsed_sql": {
            "select": {
                "value": "river_name"
            },
            "from": "river",
            "where": {
                "nin": [
                    "river_name",
                    {
                        "select": {
                            "value": "river_name"
                        },
                        "from": "river",
                        "where": {
                            "eq": [
                                "traverse",
                                "tennessee"
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [],
        "cypher_query": "MATCH (river:`geo.river`)\nWHERE NOT (river:`geo.river`)-[]-(:`geo.river { traverse : 'tennessee' }`)\nRETURN river.river_name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "which rivers do not run through usa",
        "sql_query": "SELECT river_name FROM river WHERE country_name != \"usa\";",
        "parsed_sql": {
            "select": {
                "value": "river_name"
            },
            "from": "river",
            "where": {
                "neq": [
                    "country_name",
                    "usa"
                ]
            }
        },
        "sql_ans": [],
        "cypher_query": "MATCH (river:`geo.river`)\nWHERE river.country_name <> 'usa'\nRETURN river.river_name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "which states have a river",
        "sql_query": "SELECT traverse FROM river;",
        "parsed_sql": {
            "select": {
                "value": "traverse"
            },
            "from": "river"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (river:`geo.river`)\nRETURN river.traverse",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what states have rivers running through them",
        "sql_query": "SELECT traverse FROM river;",
        "parsed_sql": {
            "select": {
                "value": "traverse"
            },
            "from": "river"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (river:`geo.river`)\nRETURN river.traverse",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how many rivers do not traverse the state with the capital albany",
        "sql_query": "SELECT COUNT ( river_name ) FROM river WHERE traverse NOT IN ( SELECT state_name FROM state WHERE capital  =  \"albany\" );",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "river_name"
                }
            },
            "from": "river",
            "where": {
                "nin": [
                    "traverse",
                    {
                        "select": {
                            "value": "state_name"
                        },
                        "from": "state",
                        "where": {
                            "eq": [
                                "capital",
                                "albany"
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (river:`geo.river`)\nWHERE NOT (river:`geo.river`)-[]-(:`geo.state { capital : 'albany' }`)\nRETURN count(river.river_name)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how many rivers are there in us",
        "sql_query": "SELECT COUNT ( river_name ) FROM river;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": "river_name"
                }
            },
            "from": "river"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (river:`geo.river`)\nRETURN count(river.river_name)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "name the 50 capitals in the usa",
        "sql_query": "SELECT DISTINCT capital FROM state;",
        "parsed_sql": {
            "select": {
                "value": {
                    "distinct": {
                        "value": "capital"
                    }
                }
            },
            "from": "state"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (state:`geo.state`)\nRETURN DISTINCT state.capital",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "how high are the highest points of all the states",
        "sql_query": "SELECT highest_elevation FROM highlow;",
        "parsed_sql": {
            "select": {
                "value": "highest_elevation"
            },
            "from": "highlow"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (highlow:`geo.highlow`)\nRETURN highlow.highest_elevation",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "name all the lakes of us",
        "sql_query": "SELECT lake_name FROM lake;",
        "parsed_sql": {
            "select": {
                "value": "lake_name"
            },
            "from": "lake"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (lake:`geo.lake`)\nRETURN lake.lake_name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what is the area of the states",
        "sql_query": "SELECT area FROM state;",
        "parsed_sql": {
            "select": {
                "value": "area"
            },
            "from": "state"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (state:`geo.state`)\nRETURN state.area",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what is the size of the largest state in the usa",
        "sql_query": "SELECT MAX ( area ) FROM state;",
        "parsed_sql": {
            "select": {
                "value": {
                    "max": "area"
                }
            },
            "from": "state"
        },
        "sql_ans": [
            [
                null
            ]
        ],
        "cypher_query": "MATCH (state:`geo.state`)\nRETURN max(state.area)",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what is the area of the largest state",
        "sql_query": "SELECT MAX ( area ) FROM state;",
        "parsed_sql": {
            "select": {
                "value": {
                    "max": "area"
                }
            },
            "from": "state"
        },
        "sql_ans": [
            [
                null
            ]
        ],
        "cypher_query": "MATCH (state:`geo.state`)\nRETURN max(state.area)",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "give me the cities in usa",
        "sql_query": "SELECT city_name FROM city;",
        "parsed_sql": {
            "select": {
                "value": "city_name"
            },
            "from": "city"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (city:`geo.city`)\nRETURN city.city_name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "what are the major rivers in the us",
        "sql_query": "SELECT river_name FROM river;",
        "parsed_sql": {
            "select": {
                "value": "river_name"
            },
            "from": "river"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (river:`geo.river`)\nRETURN river.river_name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "geo",
        "query": "which states does not border texas",
        "sql_query": "SELECT state_name FROM state WHERE state_name NOT IN ( SELECT border FROM border_info WHERE state_name  =  \"texas\" );",
        "parsed_sql": {
            "select": {
                "value": "state_name"
            },
            "from": "state",
            "where": {
                "nin": [
                    "state_name",
                    {
                        "select": {
                            "value": "border"
                        },
                        "from": "border_info",
                        "where": {
                            "eq": [
                                "state_name",
                                "texas"
                            ]
                        }
                    }
                ]
            }
        },
        "sql_ans": [],
        "cypher_query": "MATCH (state:`geo.state`)\nWHERE NOT (state:`geo.state`)-[:`geo.border_info`]-()\nRETURN state.state_name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "scholar",
        "query": "papers that were not published in the last year",
        "sql_query": "SELECT DISTINCT paperid FROM paper WHERE YEAR != 2015;",
        "parsed_sql": {
            "select": {
                "value": {
                    "distinct": {
                        "value": "paperid"
                    }
                }
            },
            "from": "paper",
            "where": {
                "neq": [
                    "YEAR",
                    2015
                ]
            }
        },
        "sql_ans": [],
        "cypher_query": "MATCH (paper:`scholar.paper`)\nWHERE paper.year <> 2015\nRETURN DISTINCT paper.paperId",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "academic",
        "query": "return me all the keywords .",
        "sql_query": "SELECT keyword FROM keyword;",
        "parsed_sql": {
            "select": {
                "value": "keyword"
            },
            "from": "keyword"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (keyword:`academic.keyword`)\nRETURN keyword.keyword",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "academic",
        "query": "return me all the organizations .",
        "sql_query": "SELECT name FROM organization;",
        "parsed_sql": {
            "select": {
                "value": "name"
            },
            "from": "organization"
        },
        "sql_ans": [],
        "cypher_query": "MATCH (organization:`academic.organization`)\nRETURN organization.name",
        "cypher_ans": [
            [
                ""
            ]
        ]
    },
    {
        "db_id": "academic",
        "query": "return me the number of keywords .",
        "sql_query": "SELECT COUNT ( DISTINCT keyword ) FROM keyword;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "keyword"
                        }
                    }
                }
            },
            "from": "keyword"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (keyword:`academic.keyword`)\nRETURN count(DISTINCT keyword.keyword)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "academic",
        "query": "return me the number of the organizations .",
        "sql_query": "SELECT COUNT ( DISTINCT name ) FROM organization;",
        "parsed_sql": {
            "select": {
                "value": {
                    "count": {
                        "distinct": {
                            "value": "name"
                        }
                    }
                }
            },
            "from": "organization"
        },
        "sql_ans": [
            [
                0
            ]
        ],
        "cypher_query": "MATCH (organization:`academic.organization`)\nRETURN count(DISTINCT organization.name)",
        "cypher_ans": [
            [
                1
            ]
        ]
    },
    {
        "db_id": "academic",
        "query": "return me the paper with the most citations .",
        "sql_query": "SELECT title FROM publication ORDER BY citation_num DESC LIMIT 1;",
        "parsed_sql": {
            "select": {
                "value": "title"
            },
            "from": "publication",
            "orderby": {
                "value": "citation_num",
                "sort": "desc"
            },
            "limit": 1
        },
        "sql_ans": [],
        "cypher_query": "MATCH (publication:`academic.publication`)\nRETURN publication.title\nORDER BY publication.citation_num DESC\nLIMIT 1",
        "cypher_ans": [
            [
                ""
            ]
        ]
    }
]